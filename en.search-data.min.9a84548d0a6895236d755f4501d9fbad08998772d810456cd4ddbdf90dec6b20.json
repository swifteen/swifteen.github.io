[{"id":0,"href":"/posts/Google%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/","title":"Google编程规范总结","section":"Blog","content":"版本说明 #   Google编程规范总结     日期 版本 修改内容     20211029 V0.1 创建    目的 #  使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要.\n项目主页:\n  Google Style Guide  Google 开源项目风格指南 - 中文版  代码规范 #  头文件 #  前置声明 #    尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可\n  前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。\n If a class only appears in the header as a pointer or reference, then a forward declaration is sufficient\n   也就是说，类在头文件中，只是以指针或者引用的形式存在时，使用前置声明就够了。但原则上还是尽量避免使用前置声明\n内联函数 #    只有当函数只有 10 行甚至更少时才将其定义为内联函数.\n  内联那些包含循环或 switch 语句的函数常常是得不偿失\n  有些函数即使声明为内联的也不一定会被编译器内联， 虚函数和递归函数就不会被正常内联\n  类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cc 文件里\n  #include 的路径及顺序 #  dir2/foo2.h (优先位置, 详情如下)，让别人的头文件先出错，避免首先怀疑自己的头文件出现错误\n  C 系统文件\n  C++ 系统文件\n  其他库的 .h 文件\n  本项目内 .h 文件\n  在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯\n#include \u0026#34;foo/public/fooserver.h\u0026#34; // 优先位置 #include \u0026lt;sys/types.h\u0026gt;//C 系统文件#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;hash_map\u0026gt;//C++ 系统文件 #include \u0026lt;vector\u0026gt; #include \u0026#34;base/basictypes.h\u0026#34;//其他库的 .h 文件#include \u0026#34;base/commandlineflags.h\u0026#34; #include \u0026#34;foo/public/bar.h\u0026#34; //本项目内 .h 文件作用域 #  命名空间 #    不应该使用 using 指示 引入整个命名空间的标识符号\n  不要在命名空间 std 内声明任何东西\n  不要在头文件中使用 命名空间别名\n  禁止用内联命名空间\n  匿名命名空间和静态变量 #   https://roachsinai.github.io/Cpp-learning-notes/declaration/namespace/anonymous.html\n  在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static\n  单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间\n//推荐 namespace myproject { namespace foo_bar { void Function1(); void Function2(); } // namespace foo_bar } // namespace myproject //不推荐 namespace myproject { class FooBar {  public:  static void Function1();  static void Function2(); }; } // namespace myproject   非成员函数、静态成员函数和全局函数 #  如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 2.1. 命名空间 或 static 链接关键字 (如 static int Foo() {\u0026hellip;}) 限定其作用域.\n局部变量 #    C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值\nint j = g(); // 好——初始化时声明  int i; i = f(); // 坏——初始化和声明分离   局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」\n  注意别在循环犯大量构造和析构的低级错误\n Foo f; // 构造函数和析构函数只调用 1 次  for (int i = 0; i \u0026lt; 1000000; ++i) {  f.DoSomething(i);  } // 低效的实现 for (int i = 0; i \u0026lt; 1000000; ++i) {  Foo f; // 构造函数和析构函数分别调用 1000000 次!  f.DoSomething(i); }   静态全局变量Static and Global Variables #   不推荐给非局部变量动态分配空间，通常禁止这样做   Dynamic initialization of nonlocal variables is discouraged, and in general it is forbidden.\n 允许给静态局部变量动态分配空间   Dynamic initialization of static local variables is allowed (and common).\n 当一个初始化指向另一个具有静态存储期限的变量时，有可能导致一个对象在其生命周期开始前（或在其生命周期结束后）被访问。此外，当一个程序启动的线程在退出时没有加入，如果对象的析构器已经运行，这些线程可能试图在其生命周期结束后访问对象。   When one initialization refers to another variable with static storage duration, it is possible that this causes an object to be accessed before its lifetime has begun (or after its lifetime has ended). Moreover, when a program starts threads that are not joined at exit, those threads may attempt to access objects after their lifetime has ended if their destructor has already run.\n  静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体\n  只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])来作为静态变量。\n  多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug\n  禁止使用类的 静态储存周期 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。\n  尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;\n   同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。\n 类 #  构造函数 #    构造函数不得调用虚函数。 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患\n  不要在无法报出错误时进行可能失败的初始化。如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法\n  隐式类型转换 #   转换运算符和单参数构造函数, 请使用 explicit 关键字   This keyword is a declaration specifier that can only be applied to in-class constructor declarations . An explicit constructor cannot take part in implicit conversions. It can only be used to explicitly construct an object 。\n  https://www.jianshu.com/p/af8034ec0e7a\n为避免隐式转换, 需将单参数构造函数声明为 explicit;   explicit的作用是用来声明类构造函数是显示调用的，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的\n 可拷贝类型和可移动类型 #    拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.\n  如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之\n  //MyClass is neither copyable nor movable. MyClass(const MyClass\u0026amp;) = delete; MyClass\u0026amp; operator=(const MyClass\u0026amp;) = delete;  如果你的基类需要可复制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现.\n  为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;\nprivate: \tMyClass(const MyClass \u0026amp;other); \tMyClass \u0026amp;operator = (const MyClass \u0026amp;other);    If a class contains pointer-type member variables, the copy constructor and the Assignment operator should either be explicitly implemented or declared as \u0026ldquo;private\u0026rdquo; (and not implemented). This ensures that the compiler does not generate any defaults for these methods that produce a \u0026ldquo;flat\u0026rdquo; copy of such objects and thus possibly create memory problems.\n 对于有指针成员变量的类，拷贝构造和赋值构造必须显式实现或者声明为私有\n结构体 VS. 类 #  仅当只有数据成员时使用 struct, 其它一概使用 class\n继承 #    如果使用继承的话, 定义为 public 继承.\n  必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数.\n  子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做\n  如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.\n  只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.\n  存取控制 #  将所有数据成员声明为 private, 除非是 static const 类型成员\n声明顺序 #    将相似的声明放在一起, 将 public 部分放在最前.\n  类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:\n  建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员\nMyClass { public:  typedef xxx  {  int x,  }yyy;   const int kMyValue = 100; public:  MyClass();  MyClass(const MyClass\u0026amp;);  ~MyClass(); protected:  void func_a(); private:  void func_b(); private:  int m_iValue; };   不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中\n  函数 #  参数顺序 #    将所有的输入参数置于输出参数之前\n  在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.\n  引用参数 #    定义引用参数可以防止出现 (*pval)++ 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针\n  大多时候输入形参往往是 const T\u0026amp;. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑\n  函数重载 #   如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append().  缺省参数 #    对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作.\n  我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。\n  智能指针 #    scoped_ptr 和 auto_ptr 已过时. 现在是 shared_ptr 和 uniqued_ptr 的天下了。不要使用 std::auto_ptr, 使用 std::unique_ptr 代替它\n  如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 std::unique_ptr 来明确所有权传递\n   std::unique_ptr\u0026lt;Foo\u0026gt; FooFactory();\rvoid FooConsumer(std::unique_ptr\u0026lt;Foo\u0026gt; ptr); 如果确实要使用共享所有权, 建议于使用 std::shared_ptr  其它C++特性 #  友元 #  如果你只允许另一个类访问该类的私有成员时\n异常 #    Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难\n  很多 C++ 书籍上都提到当构造失败时只有异常可以处理\n   https://www.zhihu.com/question/22889420\n  类型转换 #  C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类\n  用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.\n  用 const_cast 去掉 const 限定符.\n  用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换.\n  流 #    不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.\n  使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.\n  前置自增和自减 #  对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).\nconst 用法 #   关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.  const int* foo; //提倡但不强制 int const *foo; 注意初始化 const 对象时，必须在初始化的同时值初始化  整型 #  int 与 unsigned int 运算时，前者被提升为 unsigned int 而有可能溢出\n//无限循环 for (unsigned int i = foo.Length()-1; i \u0026gt;= 0; --i) ... 使用断言来指出变量为非负数, 而不是使用无符号型!不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.\n预处理宏 #    宏具有全局作用域\n  用 # 字符串化, 用 ## 连接\n  不要在 .h 文件中定义宏\n  在马上要使用时才进行 #define, 使用后要立即 #undef\n  0, nullptr 和 NULL #    整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 \u0026lsquo;\\0\u0026rsquo;.\n  C++11 项目用 nullptr; C++03 项目则用 NULL\n  sizeof #  尽可能用 sizeof(varname) 代替 sizeof(type)\n//下面代码存在错误，只对data的前4个字节执行了memset Struct* data = NULL; data = new Struct; memset(data, 0, sizeof(data)); auto #    auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。\n  永远别列表初始化 auto 变量\n  auto 在涉及迭代器的循环语句里挺常用\n  命名约定 #  函数命名, 变量命名, 文件命名要有描述性; 少用缩写\n文件命名 #  文件名要全部小写, 可以包含下划线 (_)\n定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar\n类型命名 #  类型名称的每个单词首字母均大写, 不包含下划线。类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n// 类和结构体 class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ...  // 类型定义 typedef hash_map\u0026lt;UrlTableProperties *, string\u0026gt; PropertiesMap;  // using 别名 using PropertiesMap = hash_map\u0026lt;UrlTableProperties *, string\u0026gt;;  // 枚举 enum UrlTableErrors { ... 变量命名 #  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接\n常量命名 #  声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合\nconst int kDaysInAWeek = 7; 函数命名 #  常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配。写作 StartRpc() 而非 StartRPC()。驼峰变量名\n枚举命名 #  单独的枚举值应该优先采用 常量 的命名方式\nenum UrlTableErrors {  kOK = 0,  kErrorOutOfMemory,  kErrorMalformedInput, }; 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式\n注释 #  如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起。不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.\n函数声明 #    函数是否分配了必须由调用者释放的空间.\n  参数是否可以为空指针\n  实现注释 #  对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.\n实现技巧 #   如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例.  ProductOptions options; options.set_precision_decimals(7); options.set_use_cache(ProductOptions::kDontUseCache); const DecimalNumber product =  CalculateProduct(values, options, /*completion_callback=*/nullptr); 你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化.  if (!IsAlreadyProcessed(element)) {  Process(element); } TODO 注释 #  // TODO(kl@gmail.com): Use a \u0026#34;*\u0026#34; here for concatenation operator. // TODO(Zeke) change this to use relations. // TODO(bug 12345): remove the \u0026#34;Last visitors\u0026#34; feature 格式 #  制表符 #  不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.\n函数声明与定义 #    左圆括号总是和函数名在同一行.\n  函数名和左圆括号间永远没有空格\n  圆括号与参数间没有空格\n  左大括号总在最后一个参数同一行的末尾处, 不另起新行.\n  右圆括号和左大括号间总是有一个空格\n  条件语句 #  if (condition) { // 好 - IF 和 { 都与空格紧邻.\n预处理指令 #  预处理指令不要缩进, 从行首开始\n// 好 - 指令从行首开始  if (lopsided_score) { #if DISASTER_PENDING // 正确 - 从行首开始  DropEverything(); # if NOTIFY // 非必要 - # 后跟空格  NotifyClient(); # endif #endif  BackToNormal();  } 命名空间内容不缩进\nnamespace {  void foo() { // 正确. 命名空间内没有额外的缩进.  ... }  } / 垂直留白 #  垂直留白越少越好,同一屏可以显示的代码越多, 越容易理解程序的控制流\n"},{"id":1,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","title":"深入理解计算机系统","section":"读书笔记","content":"  第一章  3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   第二章  9rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   "},{"id":2,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/1.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++/","title":"1.让自己习惯C++","section":"Effective Cpp","content":"将构造函数声明为explicit，可阻止被用来执行隐式类型转换，仍可被用来进行显示类型转换\nclass C{ public:  explicit C(int x); } Accustoming Yourself to C++ #  1.View C++ as a federation of languages #   C Object-Oriented C++ Template C++ STL  2.Perfer consts,enums,and inlines to#defines #  一旦宏被定义，在其后的编译过程中一直有效，除非在某处被#undef\nconst double AspectRatio = 1.653; const char* const authorName = \u0026#34;Scott Meyers\u0026#34;; const std::string authorName(\u0026#34;Scott Meyers\u0026#34;); 对于单纯常量，最好以const对象或者enums替换#defines\nclass GamePlayer{ private: \tstatic const int NumTurns = 5;//新一点的编译器才支持声明时定义  int scores[NumTurns]; } class GamePlayer{ private: \tenum{ NumTurns = 5};  int scores[NumTurns]; } 对于形似函数的宏（macros），最好改用inline函数替换#defines\n#define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) //不建议  //建议使用inline,宁可用编译器替换预处理器 template\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a,const T\u0026amp; b) {  f(a \u0026gt; b ? a : b); } 3.Use const whenever possible #  char greeting[] = \u0026#34;Hello\u0026#34;; const char* p = greeting;//non-const pointer,const data char* const p = greeting;//const pointer,non-const data const char* const p = greeting;//const pointer,const data 迭代器中使用const\nstd::vector\u0026lt;int\u0026gt; vec; const std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); *iter = 10; ++iter;//错误  std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin(); *cIter = 10;//错误 ++cIter; 4.Make sure that objects are initialized before they\u0026rsquo;re used #   永远在使用对象之前 先将它初始化 为内置对象进行手工初始化，因为C++不保证初始化它们 确保每一个构造函数都将对象的每一个成员初始化 总是使用成员初始列(member initialization list) 当你在成员初始值列中条列各个成员时，最好总是以其声明次序为次序  ABEntry::ABEntry()  :theName(),//调用theName的default构造函数 \ttheAddress(), \tthe Phones(), \tnumTimesConsulted() { }  为免除“跨编译单元之初始化次序问题”，主以local static 对象替换non-local static 对象  所谓编译单元(translation unit)是指产出单一目标文件(single object file)的那些源码\nnon-local static 对象：global或位于namespace作用域内，抑或在class内或file 作用域内被声明为static的对象\n如果某编译单元内的某个non-local static 对象的初始化动作使用了另一编译单元内的某个non-local static 对象，它所用到的这个对象可能尚未被 初始化，因为C++对“定义于不同编译单元内的non-local static 对象”的初始化次序并无明确定义\n"},{"id":3,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","title":"Git常用配置","section":"Git","content":"Github国内加速克隆及下载 #  fastgit.org https://doc.fastgit.org/\ngitclone.com https://gitclone.com/\ngitee https://gitee.com/mirrors\ncnpmjs.org https://github.com.cnpmjs.org/\nGithub documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot).\ngit代理 #  git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 #  Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e [--global]  # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34;  自定义配置： #  git config --global core.editor \u0026#34;vim\u0026#34; git config --global alias.unstage \u0026#34;reset HEAD\u0026#34; #chmod产生的变化应该忽略 git config --global core.filemode false git config --global core.autocrlf true git config --global gui.encoding utf-8 git config --global core.quotepath false git config --global color.ui true git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.cp cherry-pick git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit --date=format:\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;\u0026#34; 增加全局git配置文件/etc/gitconfig\nroot@3520f78b5030:/home/pi# cat /etc/gitconfig [color]  ui = true [alias]  co = checkout  ci = commit  br = branch  lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd) %C(white blue bold)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit --date=iso  st = status  unstage = reset HEAD  cp = cherry-pick  lgg = log --color --graph --pretty=format:\u0026#39;%C(yellow)%d%Creset %s \u0026#39; --abbrev-commit  alias = ! git config --get-regexp ^alias\\\\. | sed -e s/^alias\\\\.// -e s/\\\\ /\\\\ =\\\\ /  lggg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(white blue bold)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit [gui]  encoding = utf-8 [push]  default = current [credential]  helper = store [core]  quotepath = false  fileMode = false  sharedRepository = true "},{"id":4,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/","title":"工具","section":"Linux World","content":"Linux必备工具\n  Git  Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   Vim  配置 vim退出时不清除屏幕内容 # 1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示： 2、然后执行source /etc/profile即可 vim设置colorSchema # mkdir -p ~/.vim/colors https://github.com/tomasr/molokai 设置蓝色 # eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34; alias ls=\u0026#39;ls --color=auto\u0026#39; #alias dir=\u0026#39;dir --color=auto\u0026#39; #alias vdir=\u0026#39;vdir --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.   常用 Linux命令  find ./ -type d -name \u0026#34;Backup\u0026#34; -exec rm -rf {} \\; sed -i \u0026#34;s/\u0026lt;cups\\/cups.h\u0026gt;/\\\u0026#34;cups\\/cups.h\\\u0026#34;/g\u0026#34; `grep \u0026#34;cups/cups.h\u0026#34; -rl .` find . -type f -size +100M -print0 | xargs -0 du -h | sort -nr cat *.txt | sort | uniq \u0026gt; test #导出svn版本差异 for i in $(svn diff --summarize -r 248:276 svn://192.168.10.200/rootfs/ | awk \u0026#39;{ print $2 }\u0026#39;); do p=$(echo $i | sed -e \u0026#39;s{svn://192.168.10.200/rootfs/{{\u0026#39;); mkdir -p $(dirname $p); svn export $i $p; done #获取awk .   "},{"id":5,"href":"/docs/Qt%E6%80%BB%E7%BB%93/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%BD%BF%E7%94%A8/","title":"常见类使用","section":"Qt总结","content":"常见类使用 #  QTableWidget #  关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。\n//每次调用 clearContents 都会自动清理之前的item ui-\u0026gt;tableWidget-\u0026gt;clearContents(); for (int i = 0; i \u0026lt; count; ++i) {  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 0, new QTableWidgetItem(\u0026#34;aaa\u0026#34;));  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 1, new QTableWidgetItem(\u0026#34;bbb\u0026#34;));  ui-\u0026gt;tableWidget-\u0026gt;setCellWidget(i, 2, new QPushButton(\u0026#34;ccc\u0026#34;)); } QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充，\n//方法1：字符串空格填充 ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;测 试\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;人员管理\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;系统设置\u0026#34;);  //方法2：识别尺寸改变事件自动设置最小宽度 void MainWindow::resizeEvent(QResizeEvent *e) {  int count = ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;count();  int width = this-\u0026gt;width() - 30;  QString qss = QString(\u0026#34;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(width / count);  this-\u0026gt;setStyleSheet(qss); }  //方法3：设置全局样式，不同选项卡个数的设置不同的宽度 QStringList list; list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;2\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(100); list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;3\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(70); qApp-\u0026gt;setStyleSheet(list.join(\u0026#34;\u0026#34;)); //设置了tabCount弱属性自动去找对应的宽度设置 ui-\u0026gt;tabWidget-\u0026gt;setProperty(\u0026#34;tabCount\u0026#34;, 2); ui-\u0026gt;tabWidget-\u0026gt;setProperty(\u0026#34;tabCount\u0026#34;, 3);  //方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置 //Qt4的tabBar()是propected的，所以建议还是通过样式表设置 ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setDocumentMode(true); ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setExpanding(true); //样式表一步到位不用每个都单独设置 QString(\u0026#34;QTabBar{qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;}\u0026#34;); //在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。 //5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。 QTableView #  关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列。\nvoid frmSimple::initForm() {  //实例化数据模型  model = new QStandardItemModel(this);   //设置行数列数  row = 100;  column = 10;  //设置列名列宽  for (int i = 0; i \u0026lt; column; ++i) {  columnNames \u0026lt;\u0026lt; QString(\u0026#34;列%1\u0026#34;).arg(i + 1);  columnWidths \u0026lt;\u0026lt; 60;  } }  void frmSimple::on_btnLoad1_clicked() {  //先设置数据模型,否则 setColumnWidth 不起作用  ui-\u0026gt;tableView-\u0026gt;setModel(model);   //设置列数及列标题和列宽  model-\u0026gt;setColumnCount(column);  //简便方法设置列标题集合  model-\u0026gt;setHorizontalHeaderLabels(columnNames);  for (int i = 0; i \u0026lt; column; ++i) {  ui-\u0026gt;tableView-\u0026gt;setColumnWidth(i, columnWidths.at(i));  }   //循环添加行数据  QDateTime now = QDateTime::currentDateTime();  model-\u0026gt;setRowCount(row);  for (int i = 0; i \u0026lt; row; ++i) {  for (int j = 0; j \u0026lt; column; ++j) {  QStandardItem *item = new QStandardItem;  //最后一列显示时间区别开来  if (j == column - 1) {  item-\u0026gt;setText(now.addSecs(i).toString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;));  } else {  item-\u0026gt;setText(QString(\u0026#34;%1_%2\u0026#34;).arg(i + 1).arg(j + 1));  }  model-\u0026gt;setItem(i, j, item);  }  } }  void frmSimple::on_btnLoad2_clicked() {  //设置列标题和列数及列宽  ui-\u0026gt;tableWidget-\u0026gt;setColumnCount(column);  //简便方法设置列标题集合  ui-\u0026gt;tableWidget-\u0026gt;setHorizontalHeaderLabels(columnNames);  for (int i = 0; i \u0026lt; column; ++i) {  ui-\u0026gt;tableWidget-\u0026gt;setColumnWidth(i, columnWidths.at(i));  }   //添加数据  QDateTime now = QDateTime::currentDateTime();  ui-\u0026gt;tableWidget-\u0026gt;setRowCount(row);  for (int i = 0; i \u0026lt; row; ++i) {  for (int j = 0; j \u0026lt; column; ++j) {  QTableWidgetItem *item = new QTableWidgetItem;  //最后一列显示时间区别开来  if (j == column - 1) {  item-\u0026gt;setText(now.addSecs(i).toString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;));  } else {  item-\u0026gt;setText(QString(\u0026#34;%1_%2\u0026#34;).arg(i + 1).arg(j + 1));  }  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, j, item);  }  } } Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。\nvoid QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit) {  //奇数偶数行颜色交替  tableView-\u0026gt;setAlternatingRowColors(false);  //垂直表头是否可见  tableView-\u0026gt;verticalHeader()-\u0026gt;setVisible(headVisible);  //选中一行表头是否加粗  tableView-\u0026gt;horizontalHeader()-\u0026gt;setHighlightSections(false);  //最后一行拉伸填充  tableView-\u0026gt;horizontalHeader()-\u0026gt;setStretchLastSection(true);  //行标题最小宽度尺寸  tableView-\u0026gt;horizontalHeader()-\u0026gt;setMinimumSectionSize(0);  //行标题最大高度  tableView-\u0026gt;horizontalHeader()-\u0026gt;setMaximumHeight(rowHeight);  //默认行高  tableView-\u0026gt;verticalHeader()-\u0026gt;setDefaultSectionSize(rowHeight);  //选中时一行整体选中  tableView-\u0026gt;setSelectionBehavior(QAbstractItemView::SelectRows);  //只允许选择单个  tableView-\u0026gt;setSelectionMode(QAbstractItemView::SingleSelection);   //表头不可单击 #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,0,0))  tableView-\u0026gt;horizontalHeader()-\u0026gt;setSectionsClickable(false); #else  tableView-\u0026gt;horizontalHeader()-\u0026gt;setClickable(false); #endif   //鼠标按下即进入编辑模式  if (edit) {  tableView-\u0026gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);  } else {  tableView-\u0026gt;setEditTriggers(QAbstractItemView::NoEditTriggers);  } } QSqlTableModel #  QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯。\n//实例化数据库表模型 QSqlTableModel *model = new QSqlTableModel(this); //指定表名 model-\u0026gt;setTable(\u0026#34;table\u0026#34;); //设置列排序 model-\u0026gt;setSort(0, Qt::AscendingOrder); //设置提交模式 model-\u0026gt;setEditStrategy(QSqlTableModel::OnManualSubmit); //立即查询一次 model-\u0026gt;select(); //将数据库表模型设置到表格上 ui-\u0026gt;tableView-\u0026gt;setModel(model);  //测试发现过滤条件中除了可以带where语句还可以带排序及limit等 model-\u0026gt;setFilter(\u0026#34;1=1 order by id desc limit 100\u0026#34;);  //如果在过滤条件中设置了排序语句则不可以再使用setSort方法 //下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。 model-\u0026gt;setSort(0, Qt::AscendingOrder); model-\u0026gt;setFilter(\u0026#34;1=1 order by id desc limit 100\u0026#34;);  //通过setFilter设置单纯的where语句可以不用加1=1 model-\u0026gt;setFilter(\u0026#34;name=\u0026#39;张三\u0026#39;\u0026#34;); //如果还有其他语句比如排序或者limit等则需要最前面加上1=1 //下面表示按照id升序排序，查询结果显示第5-15条记录。 model-\u0026gt;setFilter(\u0026#34;1=1 order by id asc limit 5,10\u0026#34;);  //多个条件用and连接 //建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。 model-\u0026gt;setFilter(\u0026#34;1=1 and name=\u0026#39;张三\u0026#39; and result\u0026gt;=70;\u0026#34;);  //下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。 model-\u0026gt;setFilter(\u0026#34;1=1 and name=\u0026#39;张三\u0026#39; order by id desc limit 10,100;\u0026#34;);  //在第3行开始添加一条记录 model-\u0026gt;insertRow(2); //立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。 model-\u0026gt;setData(model-\u0026gt;index(2, 0), 100); model-\u0026gt;setData(model-\u0026gt;index(2, 1), \u0026#34;张三\u0026#34;); //提交更新 model-\u0026gt;submitAll();  //删除第4行 model-\u0026gt;removeRow(3); model-\u0026gt;submitAll();  //总之有增删改操作后都需要调用model-\u0026gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。  //撤销更改 model-\u0026gt;revertAll(); QList、QMap、QHash #  Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。\n//qwindowdefs.h typedef QList\u0026lt;QWidget *\u0026gt; QWidgetList; typedef QList\u0026lt;QWindow *\u0026gt; QWindowList; typedef QHash\u0026lt;WId, QWidget *\u0026gt; QWidgetMapper; typedef QSet\u0026lt;QWidget *\u0026gt; QWidgetSet;  //qmetatype.h typedef QList\u0026lt;QVariant\u0026gt; QVariantList; typedef QMap\u0026lt;QString, QVariant\u0026gt; QVariantMap; typedef QHash\u0026lt;QString, QVariant\u0026gt; QVariantHash; typedef QList\u0026lt;QByteArray\u0026gt; QByteArrayList; QLocale #  QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换。\n//格式化输出受到本地操作系统语言的影响  //英文操作系统 //这样获取到的是Mon到Sun，英文星期的3个字母的缩写。 QDateTime::currentDateTime().toString(\u0026#34;ddd\u0026#34;); //这样获取到的是Monday到Sunday，英文星期完整单词。 QDateTime::currentDateTime().toString(\u0026#34;dddd\u0026#34;);  //中文操作系统 //这样获取到的是周一到周日。 QDateTime::currentDateTime().toString(\u0026#34;ddd\u0026#34;); //这样获取到的是星期一到星期日。 QDateTime::currentDateTime().toString(\u0026#34;dddd\u0026#34;);  //主动指定语言转换 //如果没有指定本地语言则默认采用系统的语言环境。 QLocale locale; //QLocale locale = QLocale::Chinese; //QLocale locale = QLocale::English; //QLocale locale = QLocale::Japanese;C  //下面永远输出中文的周一到周日 locale.toString(QDateTime::currentDateTime(), \u0026#34;ddd\u0026#34;); //下面永远输出中文的星期一到星期日 locale.toString(QDateTime::currentDateTime(), \u0026#34;dddd\u0026#34;); QApplication #  Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。\n//如果是控制台程序则下面的QApplication换成QCoreApplication //如果是quick/qml程序则下面的QApplication换成QGuiApplication int main(int argc, char *argv[]) {  //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard  qputenv(\u0026#34;QT_IM_MODULE\u0026#34;, QByteArray(\u0026#34;qtvirtualkeyboard\u0026#34;));   //设置不应用操作系统设置比如字体  QApplication::setDesktopSettingsAware(false);  #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(6,0,0))  //设置高分屏缩放舍入策略  QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,6,0))  //设置启用高分屏缩放支持  //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下  QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);  //设置启用高分屏图片支持  QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,4,0))  //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL  //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速  //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2  //QApplication::setAttribute(Qt::AA_UseOpenGLES);  //设置opengl共享上下文  QApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif   QApplication a(argc, argv);  QWidget w;  w.show();  return a.exec(); } QRandomGenerator #  Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。\n//早期处理办法 先初始化随机数种子然后取随机数 qsrand(QTime::currentTime().msec()); //取 0-10 之间的随机数 qrand() % 10; //取 0-1 之间的浮点数 qrand() / double(RAND_MAX);  //新版处理办法 支持5.10以后的所有版本包括qt6 QRandomGenerator::global()-\u0026gt;bounded(10); //生成一个0和10之间的整数 QRandomGenerator::global()-\u0026gt;bounded(10.123); //生成一个0和10.123之间的浮点数 QRandomGenerator::global()-\u0026gt;bounded(10, 15); //生成一个10和15之间的整数  //兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数 srand(QTime::currentTime().msec()); rand() % 10; rand() / double(RAND_MAX);  //通用公式 a是起始值,n是整数的范围 int value = a + rand() % n; //(min, max)的随机数 int value = min + 1 + (rand() % (max - min - 1)); //(min, max]的随机数 int value = min + 1 + (rand() % (max - min + 0)); //[min, max)的随机数 int value = min + 0 + (rand() % (max - min + 0)); //[min, max]的随机数 int value = min + 0 + (rand() % (max - min + 1));  //如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。 //取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。 //切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大 srand((long long)currentThreadId()); qrand((long long)currentThreadId()); QString #  QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串\nQString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。\nQString s1, s2; s1 = \u0026#34;666.5567124\u0026#34;; s2.setNum(888.5632123, \u0026#39;f\u0026#39;, 7); qDebug() \u0026lt;\u0026lt; qSetRealNumberPrecision(10) \u0026lt;\u0026lt; s1.toDouble() \u0026lt;\u0026lt; s2.toDouble(); "},{"id":6,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"读书笔记","section":"Introduction","content":"记录读书笔记，看过的书隔段时间总会忘记，总结在此，方便检索\n  深入理解计算机系统  第一章 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   Effective Cpp  1.让自己习惯C\u0026#43;\u0026#43; 将构造函数声明为explicit，可阻止被用来执行隐式类型转换，仍可被用来进行显示类型转换 class C{ public: explicit C(int x); } Accustoming Yourself to C++ # 1.View C++ as a federation of languages # C Object-Oriented C++ Template C++ STL 2.Perfer consts,enums,and inlines to#defines # 一旦宏被定义，在其后的编译过程中一直有效，除非在某处被#undef const double AspectRatio = 1.653; const char* const authorName = \u0026#34;Scott Meyers\u0026#34;; const std::string authorName(\u0026#34;Scott Meyers\u0026#34;); 对于单纯常量，最好以const对象或者enums替换#defines class GamePlayer{ private: static const int NumTurns = 5;//新一点的编译器才支持声明时定义 int scores[NumTurns]; } class GamePlayer{ private: enum{ NumTurns = 5}; int scores[NumTurns]; } 对于形似函数的宏（macros），最好改用inline函数替换#defines 2.   Advanced Qt Programming  Table Model Qt\u0026rsquo;s model/view architecture # Qt\u0026rsquo;s model hierarchy # 关联Table Model中的数据到QComboBox，并过滤重复数据 # void MainWindow::createComboBoxModel(QComboBox *comboBox, int column) { delete comboBox-\u0026gt;model(); UniqueProxyModel *uniqueProxyModel = new UniqueProxyModel(column,this); uniqueProxyModel-\u0026gt;setSourceModel(model); uniqueProxyModel-\u0026gt;sort(column, Qt::AscendingOrder); comboBox-\u0026gt;setModel(uniqueProxyModel); comboBox-\u0026gt;setModelColumn(column); } 清除QTableView中的选择 # QItemSelectionModel *selectionModel = tableView-\u0026gt;selectionModel(); selectionModel-\u0026gt;clearSelection(); QItemSelection和QItemSelectionModel进行任意行组合选择 # QItemSelection selection; int firstSelectedRow = -1; for (int row = 0; row \u0026lt; proxyModel-\u0026gt;rowCount(); ++row) { QModelIndex index = proxyModel-\u0026gt;index(row, Zipcode); QItemSelection rowSelection(index, index); selection. Tree Model   "},{"id":7,"href":"/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90/","title":"浮点数计算误差分析","section":"Blog","content":"版本说明 #   内容: 浮点数计算误差分析 时间: 2022/02/28 版本: V 0.1  浮点数计算误差分析 #  通过分析汇编代码，分析浮点数运行产生的误差\n测试程序 #  例子 1 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*sizeof(short)*(a); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 例子 2 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*1000*sizeof(short)* (double)(a/1000.0); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 例子1输出878800 例子2输出878799\n为何会产生差异呢，只能从汇编代码入手，一点一点分析浮点计算的过程\n例子1汇编代码 #  例子1不涉及浮点数，因此汇编代码比较简单，先通过例子1的汇编代码进行了解。\n将例子1生成汇编文件，把汇编代码分4个重要部分说明，如下\n片段1 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-stack-manage.html\nThe push instruction at the beginning of this function:\n Pushes the return address, the value contained in the lr register, onto the stack. Pushes the caller\u0026rsquo;s frame pointer, the value contained in the fp register, onto the stack. Updates the sp to show that two 32-bit values have been pushed onto the top of the stack.  The add instruction adds 4 to the value in the sp register and stores the sum in the fp register, thus setting the frame pointer for this function such that it points to the location on the stack where the frame pointer of the calling function is stored.\npush\t{fp, lr}\t; 1、返回地址保存在lr (r13) 寄存器中，将lr寄存器中的值入栈;2、将fp寄存器中的值入栈\r.save {fp, lr}\r.setfp fp, sp, #4\radd\tfp, sp, #4\t; 将sp寄存器中的值加4之后的和，保存到fp寄存器中\r.pad #16\rsub\tsp, sp, #16 .save .setfp .pad\n片段2 #  ldr\tr3, .L3\t; 将.L3处的值加载到r3寄存器中 代码中.L3处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-16]\t; 将r3寄存器中的值保存到栈fp-16的位置\rldr\tr3, [fp, #-16]\t; 将栈fp-16位置的值加载到r3寄存器中，这里为何多此一举，担心其它进程覆盖r3吗？ 片段3 #  mov\tr2, r3\t; 将r3寄存器中的值拷贝到r2寄存器中\rmov\tr3, r2\t; 将r2寄存器中的值拷贝到r3寄存器中，这里为何多此一举\rlsl\tr3, r3, #1\t; Logical shift left逻辑左移1位，相当于乘以2\radd\tr3, r3, r2\t; 将r2寄存器和r3寄存器中的值相加得到的和，保存到r3寄存器中\rlsl\tr3, r3, #2\t; Logical shift left逻辑左移2位，相当于乘以4，这里把r3寄存器中值乘以4\radd\tr3, r3, r2\t; 将r2寄存器和r3寄存器中的值相加得到的和，保存到r3寄存器中\rlsl\tr3, r3, #1\t; Logical shift left逻辑左移1位，相当于乘以2\rmov\tr2, r3\t; 将r3寄存器中的值拷贝到r2寄存器中\rmov\tr3, #0\t; 将数值0拷贝到r3寄存器中\rstrd\tr2, [fp, #-12]\t; 将r2寄存器中的值保存到栈fp-12位置\rldrd\tr2, [fp, #-12]\t; 将栈fp-12位置的值保存到r2寄存器中\rldr\tr0, .L3+4\t; 将.L3+4处的值保存到r0寄存器中，代码中.L3+4代表[%lld]\\012\\000，即为printf函数的输入参数 13 * 2 * 33800 = [ (33800 * 2 + 33800) * 4 + 33800 ] * 2\n可知数字13会被分解成 (2 + 1) * 4 + 1\n片段4 #  bl\tprintf\t; 调用printf函数\rmov\tr3, #0\rmov\tr0, r3\rsub\tsp, fp, #4\r@ sp needed\rpop\t{fp, pc}\r.L3:\r.word\t33800\r.word\t.LC0 解释1：A calling function uses the bl instruction to call a function, which places the return address in the lr (r13) register.\n解释2：So this instruction effectively pops the caller\u0026rsquo;s frame pointer off the top of the stack, back into the fp register. Then the return address is popped into the pc, and the stack pointer, sp, is updated to the new top of the stack. This acts as an epilogue to clean up the stack after performing the algorithm that is the purpose of this function.\npop {fp, pc} 例子2汇编代码 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*1000*sizeof(short)* (double)(a/1000.0); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 汇编片段 #  .LC0:\r.ascii\t\u0026#34;[%lld]\\012\\000\u0026#34;\r.text\r.align\t2\r.global\tmain\r.arch armv6\r.syntax unified\r.arm\r.fpu vfp\r.type\tmain, %function .LFB0: ......\t;省略了部分\rsub\tsp, sp, #16\rldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置 对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中\rvmov\ts15, r3\t@ int\t; 将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中\rvcvt.f64.s32\td6, s15\t; 将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0)\rvldr.64\td5, .L3\t; 将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位\rvdiv.f64\td7, d6, d5\t; 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中\rvldr.64\td6, .L3+8\t; 将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736\rvmul.f64\td7, d7, d6\t; 将d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中\rvmov\tr0, r1, d7\t; 将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中\rbl\t__aeabi_d2lz\t; double to long long C-style conversion ,此时r0, r1为输入参数\rmov\tr2, r0\rmov\tr3, r1\rstrd\tr2, [fp, #-20]\rldrd\tr2, [fp, #-20]\rldr\tr0, .L3+20\rbl\tprintf\rmov\tr3, #0\rmov\tr0, r3\rsub\tsp, fp, #4\r@ sp needed\rpop\t{fp, pc}\r.L3:\r.word\t0\t;double类型1000.0的低32位\r.word\t1083129856\t;double类型1000.0的高32位\r.word\t0\t;double类型26000.0的低32位 编译时就进行了计算得到26000\r.word\t1087988736\t;double类型26000.0的高32位 编译时就进行了计算得到26000\r.word\t33800\r.word\t.LC0 运算步骤 #   将32位整型33800赋值到单精度浮点寄存器s15中 将单精度浮点寄存器s15中的值转换为双精度浮点数，保存到双精度浮点寄存器d6中(33800.0) 加载1000.0这个双精度浮点数(编译时就转换为双精度了)到双精度浮点寄存器d5中 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中 加载26000.0这个双精度浮点数(编译时就进行了计算得到26000，并转换为双精度了)到双精度浮点寄存器d6中 将d7保存的double值乘以d6保存的double值(26000.0)，得到值保存到d7双精度浮点寄存器中 将d7双精度浮点寄存器中的高32位保存到r0寄存器中，低32位保存到r1寄存器中 调用__aeabi_d2lz指令，以r0和r1中保存的浮点数为参数，将浮点数转换成long long类型  代码中的浮点数常量 #  根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：\n  (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 M表示有效数字，大于等于1，小于2。 2^E表示指数位。  对于double双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数，其中指数域称为阶码\n   高32位十进制 2位二进制表示 S e的二进制 e的十进制 E(E = e - 1023) M V     1083129856 0100 0000 1000 1111 0100 0000 0000 0000 0 100 0000 1000 1032 1032-1023=9 1.111101 1000   1087988736 0100 0000 1101 1001 0110 0100 0000 0000 0 100 0000 1101 1037 1037-1023=14 1.1001011001 26000    由上可知26000和1000.0在编译时就已经提前转换为双精度浮点数保存到.L3指定的常量区域了\ngdb调试跟踪每条指令 #  gdb基本命令 #  先从简单的gdb命令入手，参考https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb1.html#p-342\n(gdb) li\t#打印行号 (gdb) br 8\t#在第8行打一个断点 (gdb) s\t#执行到下一个断点 (gdb) print b #打印变量b Starting program: /home/pi/shared/boox/test_double1_gdb  Breakpoint 1, main () at test_double1_gdb.cpp:6 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); (gdb) li 1 #include \u0026lt;stdio.h\u0026gt; 2 int main() 3 { 4 int a = 33800; 5 //long long b = 13*1000*sizeof(short)* (double)(a/1000.0); 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); 7 long long c = b; 8 printf(\u0026#34;[%lf][%lld]\\n\u0026#34;,b,c); 9 } (gdb) br 8 Note: breakpoint 3 also set at pc 0x10508. Breakpoint 4 at 0x10508: file test_double1_gdb.cpp, line 8. (gdb) r The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/pi/shared/boox/test_double1_gdb  Breakpoint 1, main () at test_double1_gdb.cpp:6 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); (gdb) s  Breakpoint 2, main () at test_double1_gdb.cpp:7 7 long long c = b; (gdb) s  Breakpoint 3, main () at test_double1_gdb.cpp:8 8 printf(\u0026#34;[%lf][%lld]\\n\u0026#34;,b,c); (gdb) print b $6 = 878799.99999999988 (gdb) print c $7 = 878799 从上面可知浮点计算得到878799.99999999988后，再强制转换为long long丢掉了小数部分，导致最后结果为878799\n对比添加-g选项生成汇编文件 #  由下图可知，编译时添加-g选项后，并不影响真正有用的汇编代码，也不影响寄存器的使用，只是插入了一些辅助的指令而已\n gdb打印所有寄存器中的值 #  通过info all-registers命令可以打印通用寄存器、双精度浮点寄存器d0~d31、单精度浮点寄存器s0~s31的值。使用寄存器的值时，要注意字节序\n(gdb) info all-registers r0 0xd68cf 878799 r1 0x0 0 r2 0xd68cf 878799 r3 0x0 0 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x10504 0x10504 \u0026lt;main()+68\u0026gt; cpsr 0x20000010 536870928  //以下只列出了使用到的几个双精度浮点寄存器 d5 { u32 = {0x0, 0x41f00000}, u64 = 0x41f0000000000000, f32 = {0x0, 0x1e}, f64 = 0x100000000} d6 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf} d7 { u32 = {0x0, 0xd68cf}, u64 = 0xd68cf00000000, f32 = {0x0, 0x0}, f64 = 0x0}  //以下只列出了使用到的几个单精度浮点寄存器 s11 30 (raw 0x41f00000) s12 -nan(0x7fffff) (raw 0xffffffff) s13 10.676177 (raw 0x412ad19f) s14 0 (raw 0x00000000) s15 1.23145969e-39 (raw 0x000d68cf) 汇编分解 #  将例子2中的汇编指令进行指令级分解，观察每次指令操作后寄存器中值的变化，进而了解浮点运算的每一步动作。\n需要使用的gdb命令：\n参考https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error\n(gdb) display/i $pc\t#告诉gdb显示下一个汇编指令\r(gdb) si\t#执行下一条汇编指令 step instruction\r(gdb) info all-registers\t#打印通用寄存器、双精度浮点寄存器d0~d31、单精度浮点寄存器s0~s31的值 在关键位置打好断点后，先输入s，进入打断点的位置，然后重复输入si，查看每次的汇编指令，同时输入info all-registers查看每次执行一条汇编指令后，寄存器中的值。\n下面逐步分解上面例子2中对应的汇编指令执行后的寄存器状态，只分析最关键的浮点操作部分汇编\nldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置\t对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中\rvmov\ts15, r3\t@ int\t; 将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中\rvcvt.f64.s32\td6, s15\t; 将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0)\rvldr.64\td5, .L3\t; 将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位\rvdiv.f64\td7, d6, d5\t; 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中\rvldr.64\td6, .L3+8\t; 将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736\rvmul.f64\td7, d7, d6\t; 将d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中\rvmov\tr0, r1, d7\t; 将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中\rbl\t__aeabi_d2lz\t; double to long long C-style conversion ,此时r0, r1为输入参数 1.初始寄存器状态，r3中保存的值为局布变量a的值33800 #  此时所有双精度浮点寄存器和单精度浮点寄存器的值都为0，下面故意没有展示出来，没必要展示。\nldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置\t对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中 r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104d8 0x104d8 \u0026lt;main()+24\u0026gt; cpsr 0x60000010 1610612752 2.将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中 #  0x104d8 \u0026lt;main()+24\u0026gt;: vmov s15, r3\tr0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104dc 0x104dc \u0026lt;main()+28\u0026gt; cpsr 0x60000010 1610612752  d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0} s15 4.73638881e-41 (raw 0x00008408) 3.将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0) #  0x104dc \u0026lt;main()+28\u0026gt;: vcvt.f64.s32 d6, s15 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e0 0x104e0 \u0026lt;main()+32\u0026gt; cpsr 0x60000010 1610612752  d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0}  s13 7.01574707 (raw 0x40e08100) s14 0 (raw 0x00000000) s15 4.73638881e-41 (raw 0x00008408) 可以看出此时d6寄存器中f64值为0x8408，代表浮点数33800.0\n4.将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位 #  =\u0026gt; 0x104e0 \u0026lt;main()+32\u0026gt;: vldr d5, [pc, #56] ; 0x10520 \u0026lt;main()+96\u0026gt; (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e4 0x104e4 \u0026lt;main()+36\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 7.01574707 (raw 0x40e08100) s14 0 (raw 0x00000000) s15 4.73638881e-41 (raw 0x00008408) 可以看出此时d5寄存器中f64值为0x3e8，代表浮点数1000.0\n5.将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中 #  =\u0026gt; 0x104e4 \u0026lt;main()+36\u0026gt;: vdiv.f64 d7, d6, d5 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e8 0x104e8 \u0026lt;main()+40\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x66666666, 0x4040e666}, u64 = 0x4040e66666666666, f32 = {0xffffffff, 0x3}, f64 = 0x21}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 7.01574707 (raw 0x40e08100) s14 2.72008302e+23 (raw 0x66666666) s15 3.0140624 (raw 0x4040e666) 可以看出此时d7寄存器中f64值为0x21，代表浮点数33.0\n6.将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736 #  =\u0026gt; 0x104e8 \u0026lt;main()+40\u0026gt;: vldr d6, [pc, #56] ; 0x10528 \u0026lt;main()+104\u0026gt; (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104ec 0x104ec \u0026lt;main()+44\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0x66666666, 0x4040e666}, u64 = 0x4040e66666666666, f32 = {0xffffffff, 0x3}, f64 = 0x21}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 2.72008302e+23 (raw 0x66666666) s15 3.0140624 (raw 0x4040e666) 可以看出此时d6寄存器中f64值为0x6590，代表浮点数26000.0\n7.d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中 #  =\u0026gt; 0x104ec \u0026lt;main()+44\u0026gt;: vmul.f64 d7, d7, d6 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104f0 0x104f0 \u0026lt;main()+48\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 可以看出此时d7寄存器中f64值为0xd68cf，代表浮点数878799.0\n其中高32位为0x412ad19f，低32位为0xffffffff，见下图分解\n 8.将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中 #  =\u0026gt; 0x104f0 \u0026lt;main()+48\u0026gt;: vmov r0, r1, d7 (gdb) info all-registers r0 0xffffffff 4294967295 r1 0x412ad19f 1093325215 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104f4 0x104f4 \u0026lt;main()+52\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 其中r0为浮点数d7寄存器中的低32位0xffffffff，r1为浮点数d7寄存器中的高32位0x412ad19f\n9.double to long long C-style conversion ,此时r0, r1为输入参数 #  =\u0026gt; 0x104f4 \u0026lt;main()+52\u0026gt;: bl 0x10538 \u0026lt;__fixdfdi\u0026gt; (gdb) info all-registers r0 0xffffffff 4294967295 r1 0x412ad19f 1093325215 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x10538 0x10538 \u0026lt;__fixdfdi\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 10.将d7寄存器的高32位保存到r0寄存器中，将d7寄存器的低32位保存到r1寄存器中 #  从以下寄存器中的值可以看出，__fixdfdi函数执行后，将转换后的long long 值保存在了d7寄存器中，然后d7寄存器中的值转移到r0和r1，从而得到double转换为long long 的结果\r =\u0026gt; 0x10538 \u0026lt;__fixdfdi\u0026gt;: vmov d7, r0, r1 (gdb) info all-registers r0 0xd68cf 878799 r1 0x0 0 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x104f8 0x104f8 \u0026lt;main()+56\u0026gt; cpsr 0x20000010 536870928  d5 { u32 = {0x0, 0x41f00000}, u64 = 0x41f0000000000000, f32 = {0x0, 0x1e}, f64 = 0x100000000} d6 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf} d7 { u32 = {0x0, 0xd68cf}, u64 = 0xd68cf00000000, f32 = {0x0, 0x0}, f64 = 0x0}  fpscr 0x20000010 536870928 s0 0 (raw 0x00000000) s1 0 (raw 0x00000000) s2 0 (raw 0x00000000) s3 0 (raw 0x00000000) s4 0 (raw 0x00000000) s5 0 (raw 0x00000000) s6 0 (raw 0x00000000) s7 0 (raw 0x00000000) s8 0 (raw 0x00000000) s9 0 (raw 0x00000000) s10 0 (raw 0x00000000) s11 30 (raw 0x41f00000) s12 -nan(0x7fffff) (raw 0xffffffff) s13 10.676177 (raw 0x412ad19f) s14 0 (raw 0x00000000) s15 1.23145969e-39 (raw 0x000d68cf) 总结 #  1、不要将浮点运算得到的值，用来做精确的比较后去做某事\n2、计算机中的浮点数也是用二进制表示的，不是所有浮点数都能用二进制精确的表示。\n比如0.2，二进制小数0.00110011，对应的十进制小数0.19921875\n 使用二进制表达十进制的小数时，某些数字无法被有限位的二进制小数表示； 单精度和双精度的浮点数只包括 7 位或者 15 位的有效小数位，存储需要无限位表示的小数时只能存储近似值；  参考知识 #  gcc参数 #  使用-save-temps参数产生所有的中间步骤的文件 #  -save-temps可以做4,5,6步骤的工作。通过这个参数，所有中间阶段的文件都会存储在当前文件夹中，注意它也会产生可执行文件。\n$ gcc -save-temps main.c  $ ls a.out main.c main.i main.o main.s 从例子中我们可以看到各个中间文件以及可执行文件。\n-Wl #   用来向链接器指定参数 gcc -Wl, --wrap,malloc -Wl,--wrap,free -o int1 A.o B.o 则链接器的参数会有两个 --wrap malloc --wrap free 可以看到--wrap,free 变成了--wrap free 也就是, 变成了空格\n objdump反汇编 #  pi@raspberrypi:~/shared/boox $ objdump -d test_double2.o  test_double2.o: file format elf32-littlearm   Disassembly of section .text:  00000000 \u0026lt;main\u0026gt;:  0: e92d4800 push {fp, lr}  4: e28db004 add fp, sp, #4  8: e24dd010 sub sp, sp, #16  c: e59f3048 ldr r3, [pc, #72] ; 5c \u0026lt;main+0x5c\u0026gt;  10: e50b3010 str r3, [fp, #-16]  14: e51b3010 ldr r3, [fp, #-16]  18: e1a02003 mov r2, r3  1c: e1a03002 mov r3, r2  20: e1a03083 lsl r3, r3, #1  24: e0833002 add r3, r3, r2  28: e1a03103 lsl r3, r3, #2  2c: e0833002 add r3, r3, r2  30: e1a03083 lsl r3, r3, #1  34: e1a02003 mov r2, r3  38: e3a03000 mov r3, #0  3c: e14b20fc strd r2, [fp, #-12]  40: e14b20dc ldrd r2, [fp, #-12]  44: e59f0014 ldr r0, [pc, #20] ; 60 \u0026lt;main+0x60\u0026gt;  48: ebfffffe bl 0 \u0026lt;printf\u0026gt;  4c: e3a03000 mov r3, #0  50: e1a00003 mov r0, r3  54: e24bd004 sub sp, fp, #4  58: e8bd8800 pop {fp, pc}  5c: 00008408 .word 0x00008408  60: 00000000 .word 0x00000000 nm查看符号表 #  pi@raspberrypi:~/shared/boox $ nm test_double2.o  U __aeabi_unwind_cpp_pr1 00000000 T main  U printf fp寄存器解释 #  The frame pointer ($fp) points to the start of the stack frame and does not move for the duration of the subroutine call. This points to the base of the stack frame, and the parameters that are passed in to the subroutine remain at a constant spot relative to the frame pointer.\n 寄存器用途 #  The column labeled “Restore Contents?” shows whether the function needs to ensure that the value in the register is the same when it returns to the calling function as it contained when the this function was called.\n   Register Synonym（相同） Restore Contents Purpose     r0  N argument/results   r1  N argument/results   r2  N argument/results   r3  N argument/results   r4  Y local variable   r5  Y local variable   r6  Y local variable   r7  Y local variable   r8  Y local variable   r9  Y depends on platform standard   r10  Y local variable   r11 fp Y frame pointer/local variable   r12 ip N intra-procedure-call scratch   r13 sp Y stack pointer   r14 lr N link register   r15 pc N program counter    汇编指令 #  BL #   LDR #   STR #   LSL、LSR #   VMOV #   VCVT #   VLDR #   参考https://www.codenong.com/cs106577545/\n https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-instrs-1.html#instr-ldr\n四、参考链接 #  浮点数转换 #   https://blog.csdn.net/weixin_43955216/article/details/107385732?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0\u0026spm=1001.2101.3001.4242\n汇编指令 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-stack-manage.html\ngdb调试 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb1.html#p-342\n https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb2.html\nYou can use stepi or nexti (which can be abbreviated to si or ni) to step through your machine code.\nThe most useful thing you can do here is display/i $pc, before using stepi as already suggested in R Samuel Klatchko\u0026rsquo;s answer. This tells gdb to disassemble the current instruction just before printing the prompt each time; then you can just keep hitting Enter to repeat the stepi command.\n https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error\n"},{"id":8,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/2.%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/","title":"2.构造、析构、赋值运算","section":"Effective Cpp","content":"Constructors,Destructors,and Assignment Operators #  5.Know what functions C++ silently writes and calls #    编译器可以暗自为class创建default构造函数 、copy构造函数、copy assignment操作符，以及析构函数\n区分copy构造和copy赋值\nclass Widget{ public:  Widget();//default构造  Widget(const Widget\u0026amp; rhs);//copy构造  Widget\u0026amp; operator=(const Widget\u0026amp; rhs);//copy assignment操作符 }; Widget w1;//default构造 Widget w2(w1);//copy构造 w1 = w2;//copy assignment操作符 Widget w3 = w2;//copy构造 通过是否真正产生新的对象来区分copy构造和拷贝赋值   6.Explicitly disallow the use of compiler-generated functions you do not want #    所有编译器产出的函数都是public，为驳回编译器自动提供的机能，可将相应的成员函数声明为Private并且不予实现\n#define Q_DISABLE_COPY(Class) \\ \tClass(const Class \u0026amp;) = delete;\\ \tClass \u0026amp;operator=(const Class \u0026amp;) = delete; class Uncopyable { protected://允许derived对象构造和析构  Uncopyable(){}  ~Uncopyable(){} private:  Uncopyable(const Uncopyable\u0026amp;);  Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); } //继承Uncopyable可以阻止HomeForSale对象被拷贝 class HomeForSale:private Uncopyable {  ... }   7.Declare destructors virtual in polymorphic base classes #    只有当class内含至少一个virtual函数才为它声明virtual析构函数\n  标准string和STL窗口都不被设计作为base classed使用，因为它们的析构函数都不带virtual\n  8.Prevent exceptions from leaving destructors #    析构函数绝对不能抛出异常\n  通常通过调用abort结束程序，来阻止异常从析构函数传播出去\n  DBConn::~DBCOnn() {  try{  db.close();//可能抛出异常  }  catch(...){  std::abort();  } } 9.Never call virtual functions during construction or destruction #  禁止在构造函数和析构函数中调用virtual函数，并且在它们调用的所有函数也都服从这一约束，因为此时derived class的成员变量处于未定义的状态\nclass Transaction{ public:  Transaction();  virtual void logTransaction() const = 0; }  Transaction::Transaction() {  ...  logTransaction();//错误，构造和析构中禁止调用虚函数 }  class BuyTransaction:public Transaction{ public:  virtual void logTransaction() const = 0; } 10.Have assignment operators return a reference to *this #  让赋值assignment操作符返回一个reference to *this\nclass Widget{ public:  Widget\u0026amp; operator+=(const Widget\u0026amp; rhs)  {  ...  return *this;  }  Widget\u0026amp; operator=(int rhs)  {  ...  return *this;  } } 11.Handle assignment to self in operator= #  Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs) {  if(this == \u0026amp;rhs)  return *this;  delete pb;  pb = new Bitmap(*rhs.pb);  return *this; } 12.Copy all parts of an object #  Copying函数应该确保复制对象内的所有成员变量及所有base class成分\n//调用所有base classes内的适当的copying函数 class PriorityCUstomer::PriorityCUstomer(const PriorityCustomer\u0026amp; rhs) \t:Customer(rhs),//调用base class的copy构造函数 \tpriority(rhs.priority) { } //不该令copy assignment操作符调用copy构造函数，也不在copy构造函数调用copy assignment操作符 PriorityCUstomer\u0026amp; PriorityCUstomer::operator=(const PriorityCUstomer\u0026amp; rhs) {  Customer::operator=(rhs);//调用base class的赋值动作  priority = rhs.priority;  return *this; } "},{"id":9,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/FalconMode/","title":"FalconMode模式","section":"工程实践","content":"版本说明 #   FalconMode模式    日期 版本 修改内容     2021/11/21 V0.1 创建      FalconMode模式 #  Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel\nFalcon mode: U-Boot SPL -\u0026gt; Kernel\n https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7\nOnce you are booted up into the Linux Kernel there should be NO difference.\n 测试启动时间 #     模式 文件系统 tftp下载时间 内核到telnet时间     正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒   正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒   Falcon模式       Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK\nMulti-user refers to an Initialization Run Time Target or Run Level. This is the initialization for the OOB PLSDK.\nSingle-user refers to shell.\n官方README.falcon #   https://github.com/u-boot/u-boot/blob/master/doc/README.falcon\nFalcon Mode relies on the SPL framework. In fact, to make booting faster, U-Boot is split into two parts: the SPL (Secondary Program Loader) and U-Boot image.\nuse the \u0026ldquo;spl export\u0026rdquo; command to generate the kernel parameters area or the DT\nHowever at the end of an succesful \u0026lsquo;spl export\u0026rsquo; run it will print the RAM address of temporary storage. The RAM address of FDT will also be set in the environment variable \u0026lsquo;fdtargsaddr\u0026rsquo;, the new length of the prepared FDT will be set in the environment variable \u0026lsquo;fdtargslen\u0026rsquo;. These environment variables can be used in scripts for writing updated FDT to persistent storage.\nsetenv falcon_args_file args setenv boot_os 1 setenv spl_load_image_fat_os uImage setenv falcon_image_file uImage   https://blog.csdn.net/donglicaiju76152/article/details/77920015\nnand read 0x82000000 NAND.kernel nand read 0x88000000 NAND.u-boot-spl-os run nandargs spl export fdt 0x82000000 - 0x88000000 md \u0026lt;address\u0026gt; nand write \u0026lt;address\u0026gt; bootparms 0x4000 注意事项 #  需要使用uImage，不能使用zImage\nThe falcon mode is supported only by uImage. You should make uImage with the LOADADDR=0x80008000.\n=\u0026gt; run args_mmc =\u0026gt; run loadimage 8942296 bytes read in 610 ms (14 MiB/s) =\u0026gt; run loadfdt 58129 bytes read in 56 ms (1013.7 KiB/s) =\u0026gt; spl export fdt ${loadaddr} - ${fdtaddr}  https://e2e.ti.com/support/processors-group/processors/f/processors-forum/544446/how-to-use-falcon-mode-in-u-boot\n./mkimage -A arm -O linux -T kernel -C none -a 0x80008000 -e fdtoverlay工具使用 #  Falcon mode assumes one dtb, so you either patch your based device tree or you manually use fdtoverlay to apply the overlay to the base dtb: voodoo@hestia:~$ fdtoverlay \u0026ndash;help Usage: apply a number of overlays to a base blob fdtoverlay  [\u0026lt;overlay.dtbo\u0026gt; [\u0026lt;overlay.dtbo\u0026gt;]]  s=string,…\ndebian@beaglebone:~$ fdtoverlay --help Usage: apply a number of overlays to a base blob  fdtoverlay \u0026lt;options\u0026gt; [\u0026lt;overlay.dtbo\u0026gt; [\u0026lt;overlay.dtbo\u0026gt;]]  \u0026lt;type\u0026gt; s=string, i=int, u=unsigned, x=hex  Optional modifier prefix:  hh or b=byte, h=2 byte, l=4 byte (default)  Options: -[i:o:vhV]  -i, --input \u0026lt;arg\u0026gt; Input base DT blob  -o, --output \u0026lt;arg\u0026gt; Output DT blob  -v, --verbose Verbose messages  -h, --help Print this help and exit  -V, --version Print version and exit  #下面命令将am335x-boneblack-uboot.dtb这个基础设备树上，添加了4层设备配置节点，生成了一个新的am335x-falcon.dtb设备树 fdtoverlay -i am335x-boneblack-uboot.dtb BB-BONE-eMMC1-01-00A0.dtbo BB-HDMI-TDA998x-00A0.dtbo BB-ADC-00A0.dtbo BB-UART1-00A0.dtbo -o am335x-falcon.dtb 设备树DTB #  $ sudo apt-get install device-tree-compiler  Device trees do not need to be compiled with \u0026#34;architecture-aware\u0026#34; tools. The dtc compiler on your ubuntu machine is probably current enough to compile your device tree. Or you can download the latest source and compile it yourself. The dtc compiler can be found here:  https://git.kernel.org/pub/scm/utils/dtc/dtc.git  There are some good documents in that package that will help you better understand device trees in general.  It\u0026#39;s pretty easy to compile (and disassemble) device trees. For example  $ dtc -O dtb -o p4080ds.dtb p4080ds.dts To get the device tree in text from from the device tree blob, do this:  $ dtc -I dtb -O dts p4080ds.dtb On linux we can directly open dtb file by using fdtdump\nfdtdump dtb_file.dtb \u0026gt; /tmp/test.txt  https://elinux.org/Device_Tree_Usage\n https://elinux.org/Device_Tree_Reference\n减少启动时间 #  从硬件角度 #  1、从更快的存储设备上启动\n2、Power Management Integrated Circuits (PMIC)\n3、Processor Operating Performance Point (OPP)\nAM335x from PORz runs ROM at 600MHz OPP100 voltage.After MLO loads and runs, the processor clock and voltages are set as needed.\n从软件角度 #  uBoot阶段 #   使用Falcon模式，跳过uBoot，直接加载内核 内核命令行参数添加quiet Add loops per jiffy LPJ to the command line （在BBB板子上测试了两次，都是lpj=4980736） DisableConsole - Turn off serial console output during boot  kernel阶段 #   修改内核编译选项，减少内核大小 使用压缩的内核镜像，切换内核压缩方式到LZ4 修改设备树只开启必要的功能 选择哪一些驱动被初始化 No Probe Missing Devices - Disable probes for non-existent devices (including keyboards, etc.) Load Drivers Later - Use modules where possible to move driver initialization later in the boot sequence  rc脚本 #   减少rc脚本 延后rc脚本  用户空间 #    用户空间使用单用户，不要使用多用户模式\n  文件系统分区，将只读分区与写分区隔离\n  Avoid writes to flash memory\n  Keep writable files in RAM, and write them to flash after boot\n  Stripping your program,To get the highest savings, use \u0026ldquo;strip \u0026ndash;strip-unneeded \u0026rdquo;\n  Compiler options for program size,You can use \u0026ldquo;gcc -Os\u0026rdquo; to optimize for size.\n  LPJ值 #   https://elinux.org/Preset_LPJ\n测试了两次，都是lpj=4980736\nMay 24 14:08:04 user.info kernel: [ 0.000000] OMAP clockevent source: timer2 at 24000000 Hz May 24 14:08:04 user.info kernel: [ 0.000014] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns May 24 14:08:04 user.info kernel: [ 0.000033] clocksource: timer1: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns May 24 14:08:04 user.info kernel: [ 0.000041] OMAP clocksource: timer1 at 24000000 Hz May 24 14:08:04 user.crit kernel: [ 0.000283] timer_probe: no matching timers found May 24 14:08:04 user.info kernel: [ 0.000457] Console: colour dummy device 80x30 May 24 14:08:04 user.err kernel: [ 0.000493] WARNING: Your \u0026#39;console=ttyO0\u0026#39; has been replaced by \u0026#39;ttyS0\u0026#39; May 24 14:08:04 user.err kernel: [ 0.000499] This ensures that you still see kernel messages. Please May 24 14:08:04 user.err kernel: [ 0.000503] update your kernel commandline. May 24 14:08:04 user.info kernel: [ 0.000549] Calibrating delay loop... 996.14 BogoMIPS (lpj=4980736) May 24 14:08:04 user.info kernel: [ 0.089150] pid_max: default: 32768 minimum: 301 May 24 14:08:04 user.info kernel: [ 0.089359] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) May 24 14:08:04 user.info kernel: [ 0.089372] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) May 24 14:08:04 user.info kernel: [ 0.090211] CPU: Testing write buffer coherency: ok May 24 14:08:04 user.info kernel: [ 0.090275] CPU0: Spectre v2: using BPIALL workaround Library Optimizer Tool #   http://libraryopt.sourceforge.net/\nThe Library Optimizer Tool is used to reduce the size of shared libraries for an embedded system or other size-contrained environment.\nStatic Linking #  If your set of applications is small, sometimes it makes more sense to statically link your applications than to use shared libraries. Shared libraries by default include all symbols (functions and data structures) for the features a library provides. However, when you static link a program to a library, only the symbols that are actually referenced are linked in and included in the program.\n/proc/meminfo #   https://lwn.net/Articles/28345/\nMTD #   http://www.linux-mtd.infradead.org/faq/general.html\n http://www.linux-mtd.infradead.org/doc/ubi.html\n http://www.linux-mtd.infradead.org/faq/ubi.html\nmmap函数 #  Using mmap() instead of read() for initial application data load\nAn application may load a large amount of data when it is first initialized. This can result in a long delay as the file data is read into memory. It is possible to avoid the initial cost of this read, by using mmap() instead of read().\nInstead of loading all of the data into memory with the read system call, the file can be mapped into memory with the mmap system call. Once the data file is mapped, individual pages will be demand loaded during execution, when the application reads them. Depending on the initial working set size of the data in the file, this can result in significant time savings. (For example, if an application only initially uses 50% of the data from the file, then only 50% of the data will be read into memory from persistent storage. There is extra overhead due to the cost of page-faults incurred in loading the pages on demand. However, this page fault overhead is offset by the savings in the number of page reads (compared to the read() case).\n http://0pointer.de/blog/projects/systemd.html\nStarting more in parallel means that if we have to run something, we should not serialize its start-up (as sysvinit does), but run it all at the same time, so that the available CPU and disk IO bandwidth is maxed out, and hence the overall start-up time minimized.\nTraditionally on Unix a process that does double-forking can escape the supervision of its parent,\ntiny_fs启动日志 #  Starting kernel ...  [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 5.4.106-g023faefa70 (oe-user@oe-host) (gcc version 9.2.1 20191025 (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10))) #1 PREEMPT Mon May 24 09:04:10 UTC 2021 [ 0.000000] CPU: ARMv7 Processor [413fc082] revision 2 (ARMv7), cr=10c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache [ 0.000000] OF: fdt: Machine model: TI AM335x BeagleBone Black [ 0.000000] Memory policy: Data cache writeback [ 0.000000] efi: Getting EFI parameters from FDT: [ 0.000000] efi: UEFI not found. [ 0.000000] cma: Reserved 48 MiB at 0x9c800000 [ 0.000000] CPU: All CPU(s) started in SVC mode. [ 0.000000] AM335X ES2.1 (sgx neon) [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 129666 [ 0.000000] Kernel command line: console=ttyO0,115200n8 root=/dev/nfs rw rootfstype=ext4 rootwait fixrtc nfsroot=192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm,vers=3 ip=192.168.31.87:192.168.31.85:192.168.31.1:255.255.255.0::eth0:off [ 0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes, linear) [ 0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes, linear) [ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off [ 0.000000] Memory: 453832K/523264K available (9216K kernel code, 295K rwdata, 3092K rodata, 1024K init, 254K bss, 20280K reserved, 49152K cma-reserved, 0K highmem) [ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] rcu: Preemptible hierarchical RCU implementation. [ 0.000000] Tasks RCU enabled. [ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies. [ 0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16 [ 0.000000] IRQ: Found an INTC at 0x(ptrval) (revision 5.0) with 128 interrupts [ 0.000000] random: get_random_bytes called from start_kernel+0x2b4/0x470 with crng_init=0 [ 0.000000] OMAP clockevent source: timer2 at 24000000 Hz [ 0.000015] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns [ 0.000033] clocksource: timer1: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns [ 0.000042] OMAP clocksource: timer1 at 24000000 Hz [ 0.000286] timer_probe: no matching timers found [ 0.000457] Console: colour dummy device 80x30 [ 0.000493] WARNING: Your \u0026#39;console=ttyO0\u0026#39; has been replaced by \u0026#39;ttyS0\u0026#39; [ 0.000498] This ensures that you still see kernel messages. Please [ 0.000502] update your kernel commandline. [ 0.000550] Calibrating delay loop... 996.14 BogoMIPS (lpj=4980736) [ 0.089147] pid_max: default: 32768 minimum: 301 [ 0.089357] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) [ 0.089369] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) [ 0.090201] CPU: Testing write buffer coherency: ok [ 0.090268] CPU0: Spectre v2: using BPIALL workaround [ 0.091064] Setting up static identity map for 0x80100000 - 0x80100060 [ 0.091200] rcu: Hierarchical SRCU implementation. [ 0.091276] EFI services will not be available. [ 0.091648] devtmpfs: initialized [ 0.101487] VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 3 [ 0.101853] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.101874] futex hash table entries: 256 (order: -1, 3072 bytes, linear) [ 0.105462] pinctrl core: initialized pinctrl subsystem [ 0.106218] DMI not present or invalid. [ 0.106672] NET: Registered protocol family 16 [ 0.108840] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.132269] l3-aon-clkctrl:0000:0: failed to disable [ 0.134331] cpuidle: using governor ladder [ 0.134359] cpuidle: using governor menu [ 0.149334] No ATAGs? [ 0.149344] hw-breakpoint: debug architecture 0x4 unsupported. [ 0.164048] debugfs: Directory \u0026#39;49000000.edma\u0026#39; with parent \u0026#39;dmaengine\u0026#39; already present! [ 0.164083] edma 49000000.edma: TI EDMA DMA engine driver [ 0.165756] iommu: Default domain type: Translated [ 0.167761] SCSI subsystem initialized [ 0.168195] mc: Linux media interface: v0.10 [ 0.168239] videodev: Linux video capture interface: v2.00 [ 0.168326] pps_core: LinuxPPS API ver. 1 registered [ 0.168334] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti \u0026lt;giometti@linux.it\u0026gt; [ 0.168353] PTP clock support registered [ 0.168384] EDAC MC: Ver: 3.0.0 [ 0.169692] Advanced Linux Sound Architecture Driver Initialized. [ 0.170897] clocksource: Switched to clocksource timer1 [ 0.177850] thermal_sys: Registered thermal governor \u0026#39;fair_share\u0026#39; [ 0.177859] thermal_sys: Registered thermal governor \u0026#39;bang_bang\u0026#39; [ 0.177875] thermal_sys: Registered thermal governor \u0026#39;step_wise\u0026#39; [ 0.177881] thermal_sys: Registered thermal governor \u0026#39;user_space\u0026#39; [ 0.177886] thermal_sys: Registered thermal governor \u0026#39;power_allocator\u0026#39; [ 0.178442] NET: Registered protocol family 2 [ 0.179511] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear) [ 0.179542] TCP established hash table entries: 4096 (order: 2, 16384 bytes, linear) [ 0.179580] TCP bind hash table entries: 4096 (order: 2, 16384 bytes, linear) [ 0.179617] TCP: Hash tables configured (established 4096 bind 4096) [ 0.179730] UDP hash table entries: 256 (order: 0, 4096 bytes, linear) [ 0.179748] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear) [ 0.179909] NET: Registered protocol family 1 [ 0.180480] RPC: Registered named UNIX socket transport module. [ 0.180493] RPC: Registered udp transport module. [ 0.180498] RPC: Registered tcp transport module. [ 0.180503] RPC: Registered tcp NFSv4.1 backchannel transport module. [ 0.180518] PCI: CLS 0 bytes, default 64 [ 0.181556] hw perfevents: enabled with armv7_cortex_a8 PMU driver, 5 counters available [ 0.182739] Initialise system trusted keyrings [ 0.183094] workingset: timestamp_bits=14 max_order=17 bucket_order=3 [ 0.187549] squashfs: version 4.0 (2009/01/31) Phillip Lougher [ 0.188342] NFS: Registering the id_resolver key type [ 0.188381] Key type id_resolver registered [ 0.188388] Key type id_legacy registered [ 0.188429] ntfs: driver 2.1.32 [Flags: R/O]. [ 0.189098] Key type asymmetric registered [ 0.189113] Asymmetric key parser \u0026#39;x509\u0026#39; registered [ 0.189162] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 244) [ 0.189172] io scheduler mq-deadline registered [ 0.189179] io scheduler kyber registered [ 0.194203] OMAP GPIO hardware version 0.1 [ 0.219145] omap-mailbox 480c8000.mailbox: omap mailbox rev 0x400 [ 0.232000] pinctrl-single 44e10800.pinmux: 142 pins, size 568 [ 0.278706] Serial: 8250/16550 driver, 10 ports, IRQ sharing enabled [ 0.283028] 44e09000.serial: ttyS0 at MMIO 0x44e09000 (irq = 29, base_baud = 3000000) is a 8250 [ 0.910654] printk: console [ttyS0] enabled [ 0.917463] omap_rng 48310000.rng: Random Number Generator ver. 20 [ 0.923850] random: fast init done [ 0.927477] random: crng init done [ 0.947065] brd: module loaded [ 0.956774] loop: module loaded [ 0.964693] libphy: Fixed MDIO Bus: probed [ 1.030923] davinci_mdio 4a101000.mdio: davinci mdio revision 1.6, bus freq 1000000 [ 1.038628] libphy: 4a101000.mdio: probed [ 1.044140] davinci_mdio 4a101000.mdio: phy[0]: device 4a101000.mdio:00, driver SMSC LAN8710/LAN8720 [ 1.053556] cpsw 4a100000.ethernet: initialized cpsw ale version 1.4 [ 1.059940] cpsw 4a100000.ethernet: ALE Table size 1024 [ 1.065342] cpsw 4a100000.ethernet: cpts: overflow check period 500 (jiffies) [ 1.072635] cpsw 4a100000.ethernet: Detected MACID = 64:33:db:30:5c:a6 [ 1.081079] i2c /dev entries driver [ 1.087040] cpuidle: enable-method property \u0026#39;ti,am3352\u0026#39; found operations [ 1.094525] sdhci: Secure Digital Host Controller Interface driver [ 1.100737] sdhci: Copyright(c) Pierre Ossman [ 1.106464] omap_gpio 44e07000.gpio: Could not set line 6 debounce to 200000 microseconds (-22) [ 1.115257] omap_hsmmc 48060000.mmc: Got CD GPIO [ 1.171240] omap_hsmmc 47810000.mmc: RX DMA channel request failed [ 1.177990] sdhci-pltfm: SDHCI platform and OF driver helper [ 1.186248] ledtrig-cpu: registered to indicate activity on CPUs [ 1.196794] davinci-mcasp 48038000.mcasp: IRQ common not found [ 1.204286] NET: Registered protocol family 10 [ 1.210089] Segment Routing with IPv6 [ 1.214008] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver [ 1.220619] NET: Registered protocol family 17 [ 1.225569] Key type dns_resolver registered [ 1.230093] omap_voltage_late_init: Voltage driver support not added [ 1.237154] Loading compiled-in X.509 certificates [ 1.267316] mmc1: new high speed MMC card at address 0001 [ 1.273483] mmcblk1: mmc1:0001 M62704 3.56 GiB [ 1.278259] mmcblk1boot0: mmc1:0001 M62704 partition 1 2.00 MiB [ 1.284810] mmcblk1boot1: mmc1:0001 M62704 partition 2 2.00 MiB [ 1.291419] mmcblk1rpmb: mmc1:0001 M62704 partition 3 512 KiB, chardev (243:0) [ 1.302104] mmcblk1: p1 [ 1.311542] tps65217 0-0024: TPS65217 ID 0xe version 1.2 [ 1.453148] tda998x 0-0070: found TDA19988 [ 1.460370] tilcdc 4830e000.lcdc: bound 0-0070 (ops tda998x_ops) [ 1.466493] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013). [ 1.473148] [drm] No driver support for vblank timestamp query. [ 1.479736] [drm] Initialized tilcdc 1.0.0 20121205 for 4830e000.lcdc on minor 0 [ 1.624968] Console: switching to colour frame buffer device 240x67 [ 1.664525] tilcdc 4830e000.lcdc: fb0: tilcdcdrmfb frame buffer device [ 1.671308] omap_i2c 44e0b000.i2c: bus 0 rev0.11 at 400 kHz [ 1.678948] omap_i2c 4819c000.i2c: bus 2 rev0.11 at 100 kHz [ 1.689514] hctosys: unable to open rtc device (rtc0) [ 1.696161] cpsw 4a100000.ethernet: initializing cpsw version 1.12 (0) [ 1.801937] SMSC LAN8710/LAN8720 4a101000.mdio:00: attached PHY driver [SMSC LAN8710/LAN8720] (mii_bus:phy_addr=4a101000.mdio:00, irq=POLL) [ 3.921758] cpsw 4a100000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off [ 3.950973] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready [ 3.981089] IP-Config: Complete: [ 3.984352] device=eth0, hwaddr=64:33:db:30:5c:a6, ipaddr=192.168.31.87, mask=255.255.255.0, gw=192.168.31.1 [ 3.994813] host=192.168.31.87, domain=, nis-domain=(none) [ 4.000767] bootserver=192.168.31.85, rootserver=192.168.31.85, rootpath= [ 4.008715] ALSA device list: [ 4.011980] No soundcards found. [ 4.049139] VFS: Mounted root (nfs filesystem) on device 0:17. [ 4.055963] devtmpfs: mounted [ 4.062264] Freeing unused kernel memory: 1024K [ 4.081524] Run /sbin/init as init process INIT: version 2.96 booting "},{"id":10,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"git基本使用","section":"Git","content":"版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      Git对比SVN #   1.小步提交，互不干扰 #  并行开发过程中各开发人员可以随时多次commit代码且互不影响，最后在merage到主分支，并且能记录所有成员的所有commint记录。SVN只能大量的一次性提交到中心库。\n2.打断开发：在开发新功能过程中，突然需要你去修复一个Bug #  使用Git，你可以直接stash/commit当前改动，然后switch到主分支去修复Bug，之后在pop/switch回你原来的分支继续开发。\n3.Git分支切换-指针移动，SVN分支切换-Copy项目 #  Git支持本地无限Branches，当我们个体在本地创建多个branches用于不同目的的时候（修改，新增，探索），分支轻量化，秒创分支，创建分支满足客户定制化需求\n4.Git Tag-指针标示，SVN Tag-Copy项目 #  Git管理的项目要比SVN小得多。Git初次拉取代码的速度也远小于SVN。\n5.两级提交 #  本地创建分支开发，本地提交，需要合并时再提交到远程\n6.日志查看 #  Git本地包含了完整的日志，闪电的速度查看（并且无需网络)。SVN需要从服务拉取。\n7.安全 #  Git是分布式版本控制系统，每个用户都相当于一份备份， 管理员无需为数据备份而担心。SVN作为集中式版本控制系统，存在单点故障的风险。备份版本库的任务非常繁重。\nlinus在google的演讲感悟 链接：https://www.zhihu.com/question/19601997/answer/95363587\n 自洽的、最少依赖的个人工作得到支持。1000多人的Linux开发团队是分布在世界各地的，使用git也就不必依赖中心服务器、不必需要很少的网络。就在自己的电脑上就有完整的仓库，可以做任何版本管理，除了分享代码。SVN显然是不合适的，因为单点故障大家甚至无法提交，更加无法开分支，这是无法忍受的。 剔除害群之马很简单。如果Linus经过观察，发现有些程序员特别容易出漏子，那么封杀的办法就是不必拉取即可。实际上Linus就是这样干过。如果是SVN，就变成了撤销惹麻烦的开发者的账号或者限定他的访问范围，并且从仓库中移除麻烦的代码提交。就是说，封杀的方法在git而言，是不做某事即可，SVN是做一系列事情才可以。一正一反，大家可以体会一下。Linus喜欢前者，并且得心应手。这样的工作流程就避开了很多“政治”问题，让他的集成代码过程变得主动。 可以使用信任网络。Linux太大了，不可能完全看完补丁代码的方式来识别信任，这个Linus曾经干过，最后的结果当然是放弃。如果发现有些程序员特别优秀，他只要选择拉取他们的实现。这些程序员也只是拉取他们信任的程序员的实现。这样的信任网络是可以层次化的，因此对应于1000多人的开发者来说，这样做确实可以通过分层的信任网络达成大规模的团队协作。如果是SVN，我不知道如何做可以更好 轻量的分支开销鼓励大量被使用。对于这样的团队，为了敏捷的迭代，如果有想法就分支（这样的开发隔离想法是很有价值的），那么在svn上分支是海量的并且全局的大家互相影响，因此是要命的。而对于Git总数当然是海量，但是每个人的分支都在自己的仓库内，不会影响到他人。且分支无需连接服务器，因此是飞速的。  Git工作流 #   http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n https://www.jianshu.com/p/5e847c12709c\n http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\nGit 作为一个源码管理系统，不可避免涉及到多人协作。\n协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。\u0026ldquo;工作流程\u0026quot;在英语里，叫做\u0026quot;workflow\u0026quot;或者\u0026quot;flow\u0026rdquo;，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。\n都采用 \u0026ldquo;功能驱动式开发\u0026rdquo;（Feature-driven development，简称FDD）。\n它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。\n   工作流 策略 缺点     Git flow 2个长期分支(master| develop)、3种短期分支(feature |hotfix |release) 经常要切换分支，非常烦人   Github flow 1个长期分支 master,发起一个 pull request（简称PR）    Gitlab flow \u0026ldquo;上游优先\u0026rdquo;（upsteam first）     对于\u0026quot;版本发布\u0026quot;的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。\n以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。\ngit flow工作流程： #    devloper：新功能开发分支一般命名为（feature_name或feature/name）；开发人员在进行功能开发的时候，先从master 分支checkout新的feature分支（例如feature/open_activity）,分支拉取后，开发人员在当前分支开发自己的功能，开发完成后，merge feature/open_activity到 qa分支进行功能测试，经过QA测试该功能没有问题，merge feature/open_activity 到 release 分支（release 分支不能直接push代码，需要request merge,code review之后，就可以在灰度环境测试，然后上线了），到此为止新的功能已经上线完成，delete feature/open_activity分支、 merge release 分支到master 分支，并且打下tag。整个一个开发流程结束，新的需求一个轮回又开始了； bugfix:bugfix分支一般命名为（bugfix_name或bugfix/name）； bugfix 是对重大bug的修改，修改完成后，需要合并到qa分支进行测试，整个流程与 #devloper# 的流程一致； hotfix: hotfix分支一般命名为（hotfix_name或hotfix/name）； hotfix为线上代码的热更新，比如配置文件的修改或者极小的功能修改。开发人员从master 拉取hotfix/mysql_config分支，然后进行bug fix ,完成后，merger 到release分支code review之后上线。到此bug热修复完成，delete hotfix/mysql_config分支、merge release 分支到master 分支，hotfix一般不需要打tag；  Git命令 #  Git命令流程图 #      http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n一、新建代码库 #   # 在当前目录新建一个Git代码库 $ git init  # 新建一个目录，将其初始化为Git代码库 $ git init [project-name]  # 下载一个项目和它的整个代码历史 $ git clone [url]  二、配置 #  Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e [--global]  # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34;  三、增加/删除文件 #   # 添加指定文件到暂存区 $ git add [file1] [file2] ...  # 添加指定目录到暂存区，包括子目录 $ git add [dir]  # 添加当前目录的所有文件到暂存区 $ git add .  # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p  # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ...  # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file]  # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]  四、代码提交 #   # 提交暂存区到仓库区 $ git commit -m [message]  # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message]  # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a  # 提交时显示所有diff信息 $ git commit -v  # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message]  # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...  五、分支 #   # 列出所有本地分支 $ git branch  # 列出所有远程分支 $ git branch -r  # 列出所有本地分支和远程分支 $ git branch -a  # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name]  # 新建一个分支，并切换到该分支 $ git checkout -b [branch]  # 新建一个分支，指向指定commit $ git branch [branch] [commit]  # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch]  # 切换到指定分支，并更新工作区 $ git checkout [branch-name]  # 切换到上一个分支 $ git checkout -  # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch]  # 合并指定分支到当前分支 $ git merge [branch]  # 选择一个commit，合并进当前分支 $ git cherry-pick [commit]  # 删除分支 $ git branch -d [branch-name]  # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]  六、标签 #   # 列出所有tag $ git tag  # 新建一个tag在当前commit $ git tag [tag]  # 新建一个tag在指定commit $ git tag [tag] [commit]  # 删除本地tag $ git tag -d [tag]  # 删除远程tag $ git push origin :refs/tags/[tagName]  # 查看tag信息 $ git show [tag]  # 提交指定tag $ git push [remote] [tag]  # 提交所有tag $ git push [remote] --tags  # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]  七、查看信息 #   # 显示有变更的文件 $ git status  # 显示当前分支的版本历史 $ git log  # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat  # 搜索提交历史，根据关键词 $ git log -S [keyword]  # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s  # 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 $ git log [tag] HEAD --grep feature  # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file]  # 显示指定文件相关的每一次diff $ git log -p [file]  # 显示过去5次提交 $ git log -5 --pretty --oneline  # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn  # 显示指定文件是什么人在什么时间修改过 $ git blame [file]  # 显示暂存区和工作区的差异 $ git diff  # 显示暂存区和上一个commit的差异 $ git diff --cached [file]  # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD  # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch]  # 显示今天你写了多少行代码 $ git diff --shortstat \u0026#34;@{0 day ago}\u0026#34;  # 显示某次提交的元数据和内容变化 $ git show [commit]  # 显示某次提交发生变化的文件 $ git show --name-only [commit]  # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename]  # 显示当前分支的最近几次提交 $ git reflog  八、远程同步 #   # 下载远程仓库的所有变动 $ git fetch [remote]  # 显示所有远程仓库 $ git remote -v  # 显示某个远程仓库的信息 $ git remote show [remote]  # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url]  # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch]  # 上传本地指定分支到远程仓库 $ git push [remote] [branch]  # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force  # 推送所有分支到远程仓库 $ git push [remote] --all  九、撤销 #   # 恢复暂存区的指定文件到工作区 $ git checkout [file]  # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file]  # 恢复暂存区的所有文件到工作区 $ git checkout .  # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file]  # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard  # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit]  # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit]  # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit]  # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit]  # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop  十、其他 #   # 生成一个可供发布的压缩包 $ git archive  Git 使用规范流程 #   http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\n第一步：新建分支 #  首先，每次开发新功能，都应该新建一个单独的分支\n # 获取主干最新代码 $ git checkout master $ git pull  # 新建一个开发分支myfeature $ git checkout -b myfeature  第二步：提交分支commit #  分支修改后，就可以提交commit了。\n $ git add --all $ git status $ git commit --verbose  git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。\ngit status 命令，用来查看发生变动的文件。\ngit commit 命令的verbose参数，会列出 diff 的结果。\n第三步：撰写提交信息 #  提交commit时，必须给出完整扼要的提交信息，下面是一个范本。\n Present-tense summary under 50 characters  * More information about commit (under 72 characters). * More information about commit (under 72 characters).  http://project.management-system.com/ticket/123  第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。\n第四步：与主干同步 #  分支的开发过程中，要经常与主干保持同步。\n $ git fetch origin $ git rebase origin/master  第五步：合并commit #  分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。\n那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。\n $ git rebase -i origin/master  git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。\n下面采用 Tute Costa的例子，来解释怎么合并commit。\n pick 07c5abd Introduce OpenPGP and teach basic usage pick de9b1eb Fix PostChecker::Post#urls pick 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  # Rebase 8db7e8b..fa20af3 onto 8db7e8b # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out  上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。\n4个commit的下面是一大堆注释，列出可以使用的命令。\n  pick：正常选中 reword：选中，并且修改提交信息； edit：选中，rebase时会暂停，允许你修改这个commit（参考 这里） squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令   上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。\n pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls s 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。\n # This is a combination of 3 commits. # The first commit\u0026#39;s message is: Introduce OpenPGP and teach basic usage  # This is the 2nd commit message: Fix PostChecker::Post#urls  # This is the 3rd commit message: Hey kids, stop all the highlighting  如果将第三行的squash命令改成fixup命令。\n pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls f 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。\n # This is a combination of 3 commits. # The first commit\u0026#39;s message is: Introduce OpenPGP and teach basic usage  # This is the 2nd commit message: Fix PostChecker::Post#urls  # This is the 3rd commit message: # Hey kids, stop all the highlighting   Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。\n $ git reset HEAD~5 $ git add . $ git commit -am \u0026#34;Here\u0026#39;s the bug fix that closes #28\u0026#34; $ git push --force  squash和fixup命令，还可以当作命令行参数使用，自动合并commit。\n $ git commit --fixup $ git rebase -i --autosquash  这个用法请参考 这篇文章，这里就不解释了。\n第六步：推送到远程仓库 #  合并commit后，就可以推送当前分支到远程仓库了。\n $ git push --force origin myfeature  git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（参见 这里）。\n第七步：发出Pull Request #  提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。\n个人总结 #  1、修改的代码每次提交commit后，这个commit就像组装好的零件，在之后可以进行任意拼装或拆分\n2、大胆创建、修改分支，随意commit，不用关心冲突问题，所有的修改全部上传自己独有的临时分支，commit原则：一个功能、一个模块、一个子缺陷上传，不用在乎commit数量的多少，主要是为了之后回滚方便\n3、还有很多强大的高级功能需要慢慢探索，最好是遇到需求再去搜索能否用git实现\n"},{"id":11,"href":"/docs/Qt%E6%80%BB%E7%BB%93/snippet/","title":"snippet","section":"Qt总结","content":"延时异步加载 #  用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。\n//异步执行load函数\rQMetaObject::invokeMethod(this, \u0026#34;load\u0026#34;, Qt::QueuedConnection);\r//延时10毫秒执行load函数\rQTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 #  //拿到控件元对象 const QMetaObject *metaObject = widget-\u0026gt;metaObject();  //所有属性的数量 int propertyCount = metaObject-\u0026gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u0026gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u0026lt; propertyCount; ++i) {  QMetaProperty metaProperty = metaObject-\u0026gt;property(i);  const char *name = metaProperty.name();  const char *type = metaProperty.typeName();  QVariant value = widget-\u0026gt;property(name);  qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; }  //所有方法的数量 int methodCount = metaObject-\u0026gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u0026gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u0026lt; methodCount; ++i) {  QMetaMethod metaMethod = metaObject-\u0026gt;method(i);  const char *name = metaMethod.name();  const char *type = metaMethod.typeName();  qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type; } inherits判断是否属于某种类 #  QTimer *timer = new QTimer; // QTimer inherits QObject\rtimer-\u0026gt;inherits(\u0026#34;QTimer\u0026#34;); // returns true\rtimer-\u0026gt;inherits(\u0026#34;QObject\u0026#34;); // returns true\rtimer-\u0026gt;inherits(\u0026#34;QAbstractButton\u0026#34;); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-\u0026gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-\u0026gt;property(\u0026ldquo;name\u0026rdquo;)取出对应的弱属性的值。\nsqlite数据库 #   如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。  QSqlDatabase db = QSqlDatabase::addDatabase(\u0026#34;QSQLITE\u0026#34;);\rdb.setDatabaseName(\u0026#34;:memory:\u0026#34;); 清空数据表并重置自增ID\ntruncate table table_name 废弃或者过时函数 #  从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0\n编译环境和运行环境 #  x86/x64都编译环境和运行环境是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。\n   名称 说明     x86 32/64位系统上编译在32/64位系统上运行   x86_amd64 32/64位系统上编译在64位系统上运行   x86_arm 32/64位系统上编译在arm系统上运行   amd64 64位系统上编译在64位系统上运行   amd64_x86 64位系统上编译在32/64位系统上运行   amd64_arm 64位系统上编译在arm系统上运行    窗口模态显示 #  很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。\nQDialog dialog;\rdialog.setWindowModality(Qt::WindowModal); 无边框窗体输入焦点 #  在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。\n//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点 setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);  //需要在show以后主动激活窗体 w-\u0026gt;show(); w-\u0026gt;activateWindow(); QMetaObject::invokeMethod #  巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, \u0026ldquo;fun\u0026rdquo;, Qt::QueuedConnection); 这种方式来就可以。\n invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。 invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！ 测试下来发现只能执行signals或者slots标识的方法。 默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。 必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。 如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字  //头文件声明信号和槽函数 signals:  void sig_test(int type,double value); private slots:  void slot_test(int type, double value); private:  Q_INVOKABLE void fun_test(int type, double value);  //构造函数关联信号槽 connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));  //单击按钮触发信号和槽,这里是同时举例信号槽都可以 void MainWindow::on_pushButton_clicked() {  QMetaObject::invokeMethod(this, \u0026#34;sig_test\u0026#34;, Q_ARG(int, 66), Q_ARG(double, 66.66));  QMetaObject::invokeMethod(this, \u0026#34;slot_test\u0026#34;, Q_ARG(int, 88), Q_ARG(double, 88.88));  QMetaObject::invokeMethod(this, \u0026#34;fun_test\u0026#34;, Q_ARG(int, 99), Q_ARG(double, 99.99)); }  //会打印 66 66.66、88 88.88 void MainWindow::slot_test(int type, double value) {  qDebug() \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; }  //会打印 99.99 void MainWindow::fun_test(int type, double value) {  qDebug() \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; } Qt的定时器精度 #  Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer);\n Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。 Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。 Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。 精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。  QRegExpValidator 正则表达 #   QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。   限制输入只能输入IP地址。 限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。  //正在表达式限制输入 QString str = \u0026#34;\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b\u0026#34;; ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QRegExpValidator(QRegExp(str))); //用于占位 ui-\u0026gt;lineEdit-\u0026gt;setInputMask(\u0026#34;000.000.000.000\u0026#34;);  #if 0//下面代码设置浮点数范围限制失败 ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QDoubleValidator(20, 50, 1)); #else //下面代码设置浮点数范围限制成功 QDoubleValidator *validator = new QDoubleValidator(20, 50, 1); validator-\u0026gt;setNotation(QDoubleValidator::StandardNotation); ui-\u0026gt;lineEdit-\u0026gt;setValidator(validator); #endif //下面代码设置整数范围限制成功 ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QIntValidator(10, 120));  //其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋 //需要来个万能的牛逼的 QRegExpValidator  //限制浮点数输入范围为[-180,180] QRegExp regexp(\u0026#34;^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$\u0026#34;); //限制浮点数输入范围为[-90,90]并限定为小数位后4位 QRegExp regexp(\u0026#34;^-?(90|[1-8]?\\\\d(\\\\.\\\\d{1,4})?)$\u0026#34;); QRegExpValidator *validator = new QRegExpValidator(regexp, this); ui-\u0026gt;lineEdit-\u0026gt;setValidator(validator); Qt重载qDebug输出自定义的信息 #  struct FunctionInfo {  QString function;  QString name;  QString groupEnabled;  QString action;  QString group;   friend QDebug operator \u0026lt;\u0026lt; (QDebug debug, const FunctionInfo \u0026amp;functionInfo) {  QString info = QString(\u0026#34;功能: %1 名称: %2 启用: %3 方法: %4 分组: %5\u0026#34;)  .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)  .arg(functionInfo.action).arg(functionInfo.group);  debug \u0026lt;\u0026lt; info;  return debug;  } }; findChild使用 #  Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。\n//打印子类类名集合 void printObjectChild(const QObject *obj, int spaceCount) {  qDebug() \u0026lt;\u0026lt; QString(\u0026#34;%1%2 : %3\u0026#34;)  .arg(\u0026#34;\u0026#34;, spaceCount)  .arg(obj-\u0026gt;metaObject()-\u0026gt;className())  .arg(obj-\u0026gt;objectName());   QObjectList childs = obj-\u0026gt;children();  foreach (QObject *child, childs) {  printObjectChild(child, spaceCount + 2);  } }  //拿到对话框进行设置和美化 QFileDialog *fileDialog = new QFileDialog(this); fileDialog-\u0026gt;setOption(QFileDialog::DontUseNativeDialog, true); QLabel *lookinLabel = fileDialog-\u0026gt;findChild\u0026lt;QLabel*\u0026gt;(\u0026#34;lookInLabel\u0026#34;); lookinLabel-\u0026gt;setText(QString::fromLocal8Bit(\u0026#34;文件目录：\u0026#34;)); lookinLabel-\u0026gt;setStyleSheet(\u0026#34;color:red;\u0026#34;);  //设置日期框默认值为空 QLineEdit *edit = ui-\u0026gt;dateEdit-\u0026gt;findChild\u0026lt;QLineEdit *\u0026gt;(\u0026#34;qt_spinbox_lineedit\u0026#34;); if (!edit-\u0026gt;text().isEmpty()) {  edit-\u0026gt;clear(); } 巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。\n//查找指定类名objectName的控件 QList\u0026lt;QWidget *\u0026gt; widgets = fatherWidget.findChildren\u0026lt;QWidget *\u0026gt;(\u0026#34;widgetname\u0026#34;); //查找所有QPushButton QList\u0026lt;QPushButton *\u0026gt; allPButtons = fatherWidget.findChildren\u0026lt;QPushButton *\u0026gt;(); //查找一级子控件,不然会一直遍历所有子控件 QList\u0026lt;QPushButton *\u0026gt; childButtons = fatherWidget.findChildren\u0026lt;QPushButton *\u0026gt;(QString(), Qt::FindDirectChildrenOnly); 动态加载资源文件 #  当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。\n//Qt中使用二进制资源文件方法如下 //将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc //在应用程序中注册资源，一般在main函数启动后就注册 QResource::registerResource(qApp-\u0026gt;applicationDirPath() + \u0026#34;/main.rcc\u0026#34;); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big\nblockSignals阻塞信号 #  //方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。 disconnect(ui-\u0026gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); for (int i = 0; i \u0026lt;= 100; i++) {  ui-\u0026gt;cbox-\u0026gt;addItem(QString::number(i)); } connect(ui-\u0026gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));  //方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。 //如果需要指定某个信号进行断开那就只能用 disconnect 来处理。 ui-\u0026gt;cbox-\u0026gt;blockSignals(true); for (int i = 0; i \u0026lt;= 100; i++) {  ui-\u0026gt;cbox-\u0026gt;addItem(QString::number(i)); } ui-\u0026gt;cbox-\u0026gt;blockSignals(false); QCustomPlot使用 #  //对调XY轴，在最前面设置 QCPAxis *yAxis = customPlot-\u0026gt;yAxis; QCPAxis *xAxis = customPlot-\u0026gt;xAxis; customPlot-\u0026gt;xAxis = yAxis; customPlot-\u0026gt;yAxis = xAxis;  //移除图例 customPlot-\u0026gt;legend-\u0026gt;removeItem(1);  //合并两个曲线画布形成封闭区域 customPlot-\u0026gt;graph(0)-\u0026gt;setChannelFillGraph(customPlot-\u0026gt;graph(1));  //关闭抗锯齿以及设置拖动的时候不启用抗锯齿 customPlot-\u0026gt;graph()-\u0026gt;setAntialiased(false); customPlot-\u0026gt;setNoAntialiasingOnDrag(true);  //多种设置数据的方法 customPlot-\u0026gt;graph(0)-\u0026gt;setData(); customPlot-\u0026gt;graph(0)-\u0026gt;data()-\u0026gt;set();  //设置不同的线条样式、数据样式 customPlot-\u0026gt;graph()-\u0026gt;setLineStyle(QCPGraph::lsLine); customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle::ssDot); customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(shapes.at(i), 10));  //还可以设置为图片或者自定义形状 customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(QPixmap(\u0026#34;./sun.png\u0026#34;))); QPainterPath customScatterPath; for (int i = 0; i \u0026lt; 3; ++i) {  customScatterPath.cubicTo(qCos(2 * M_PI * i / 3.0) * 9, qSin(2 * M_PI * i / 3.0) * 9, qCos(2 * M_PI * (i + 0.9) / 3.0) * 9, qSin(2 * M_PI * (i + 0.9) / 3.0) * 9, 0, 0); } customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, 0), QColor(40, 70, 255, 50), 10));  //更换坐标轴的箭头样式 customPlot-\u0026gt;xAxis-\u0026gt;setUpperEnding(QCPLineEnding::esSpikeArrow); customPlot-\u0026gt;yAxis-\u0026gt;setUpperEnding(QCPLineEnding::esSpikeArrow);  //设置背景图片 customPlot-\u0026gt;axisRect()-\u0026gt;setBackground(QPixmap(\u0026#34;./solarpanels.jpg\u0026#34;)); //画布也可以设置背景图片 customPlot-\u0026gt;graph(0)-\u0026gt;setBrush(QBrush(QPixmap(\u0026#34;./balboa.jpg\u0026#34;))); //整体可以设置填充颜色或者图片 customPlot-\u0026gt;setBackground(QBrush(gradient)); //设置零点线条颜色 customPlot-\u0026gt;xAxis-\u0026gt;grid()-\u0026gt;setZeroLinePen(Qt::NoPen); //控制是否鼠标滚轮缩放拖动等交互形式 customPlot-\u0026gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);  //柱状分组图 QCPBarsGroup *group = new QCPBarsGroup(customPlot); QList\u0026lt;QCPBars*\u0026gt; bars; bars \u0026lt;\u0026lt; fossil \u0026lt;\u0026lt; nuclear \u0026lt;\u0026lt; regen; foreach (QCPBars *bar, bars) {  //设置柱状图的宽度大小  bar-\u0026gt;setWidth(bar-\u0026gt;width() / bars.size());  group-\u0026gt;append(bar); } //设置分组之间的间隔 group-\u0026gt;setSpacing(2); 网络请求超时时间 #  在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。\n//局部的事件循环,不卡主界面 QEventLoop eventLoop;  //设置超时 5.15开始自带了超时时间函数 默认30秒 #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,15,0)) manager-\u0026gt;setTransferTimeout(timeout); #else QTimer timer; connect(\u0026amp;timer, SIGNAL(timeout()), \u0026amp;eventLoop, SLOT(quit())); timer.setSingleShot(true); timer.start(timeout); #endif  QNetworkReply *reply = manager-\u0026gt;get(QNetworkRequest(QUrl(url))); connect(reply, SIGNAL(finished()), \u0026amp;eventLoop, SLOT(quit())); eventLoop.exec();  if (reply-\u0026gt;bytesAvailable() \u0026gt; 0 \u0026amp;\u0026amp; reply-\u0026gt;error() == QNetworkReply::NoError) {  //读取所有数据保存成文件  QByteArray data = reply-\u0026gt;readAll();  QFile file(dirName + fileName);  if (file.open(QFile::WriteOnly | QFile::Truncate)) {  file.write(data);  file.close();  } } Qt获取当前所用的Qt版本、编译器、位数等信息。 #  //详细的Qt版本+编译器+位数 QString compilerString = \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;; {  compilerString = QLatin1String(\u0026#34;GCC \u0026#34;) + QLatin1String(__VERSION__); }  //拓展知识 查看 QSysInfo 类下面有很多好东西 // qVersion() = QT_VERSION_STR QString version = QString(\u0026#34;%1 %2 %3\u0026#34;).arg(qVersion()).arg(compilerString).arg(QString::number(QSysInfo::WordSize)); Lamda形式信号槽 #  MainWindow::MainWindow(QWidget *parent)  : QMainWindow(parent)  , ui(new Ui::MainWindow) {  ui-\u0026gt;setupUi(this);  //早期写法,通用Qt所有版本,只支持定义了slots关键字的函数  //connect(ui-\u0026gt;pushButton, SIGNAL(clicked()), this, SLOT(test_fun()));  connect(ui-\u0026gt;pushButton, SIGNAL(clicked()), this, SLOT(test_slot()));   //新写法,支持Qt5及后期所有版本,支持所有函数,无需定义slots关键字也行  //采用这种写法，如果编译的时候信号或槽不存在是无法编译通过的，相当于编译时检查，不容易出错；  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, this, \u0026amp;MainWindow::test_fun);  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, this, \u0026amp;MainWindow::test_slot);   //按钮单击不带参数  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, [] {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34;;  });   //按钮单击带参数  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, [] (bool isCheck) {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34; \u0026lt;\u0026lt; isCheck;  });   //自定义信号带参数  connect(this, \u0026amp;MainWindow::sig_test, [] (int i, int j) {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; j;  });   emit sig_test(5, 8); } Qt延时方法 #  void QUIHelperCore::sleep(int msec) {  if (msec \u0026lt;= 0) {  return;  }  #if 1  //非阻塞方式延时,现在很多人推荐的方法  QEventLoop loop;  QTimer::singleShot(msec, \u0026amp;loop, SLOT(quit()));  loop.exec(); #else #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  //阻塞方式延时,如果在主线程会卡住主界面  QThread::msleep(msec); #else  //非阻塞方式延时,不会卡住主界面,据说可能有问题  QTime endTime = QTime::currentTime().addMSecs(msec);  while (QTime::currentTime() \u0026lt; endTime) {  QCoreApplication::processEvents(QEventLoop::AllEvents, 100);  } #endif #endif } 获取当前屏幕索引以及尺寸 #  //获取当前屏幕索引 int QUIHelper::getScreenIndex() {  //需要对多个屏幕进行处理  int screenIndex = 0; #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  int screenCount = qApp-\u0026gt;screens().count(); #else  int screenCount = qApp-\u0026gt;desktop()-\u0026gt;screenCount(); #endif   if (screenCount \u0026gt; 1) {  //找到当前鼠标所在屏幕  QPoint pos = QCursor::pos();  for (int i = 0; i \u0026lt; screenCount; ++i) { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  if (qApp-\u0026gt;screens().at(i)-\u0026gt;geometry().contains(pos)) { #else  if (qApp-\u0026gt;desktop()-\u0026gt;screenGeometry(i).contains(pos)) { #endif  screenIndex = i;  break;  }  }  }  return screenIndex; }  //获取当前屏幕尺寸区域 QRect QUIHelper::getScreenRect(bool available) {  QRect rect;  int screenIndex = QUIHelper::getScreenIndex();  if (available) { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  rect = qApp-\u0026gt;screens().at(screenIndex)-\u0026gt;availableGeometry(); #else  rect = qApp-\u0026gt;desktop()-\u0026gt;availableGeometry(screenIndex); #endif  } else { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  rect = qApp-\u0026gt;screens().at(screenIndex)-\u0026gt;geometry(); #else  rect = qApp-\u0026gt;desktop()-\u0026gt;screenGeometry(screenIndex); #endif  }  return rect; } 文本进行分散对齐显示 #  有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。\nQString text = \u0026#34;测试分散对齐内容\u0026#34;; //计算当前文本在当前字体下占用的宽度 QFont font = ui-\u0026gt;label-\u0026gt;font(); int textWidth = ui-\u0026gt;label-\u0026gt;fontMetrics().width(text); //显示文本的区域宽度=标签的宽度-两边的边距 int width = ui-\u0026gt;label-\u0026gt;width() - 12; //需要-1相当于中间有几个间隔 int count = text.count() - 1; //计算每个间距多少 qreal space = qreal(width - textWidth) / count; //设置固定间距 font.setLetterSpacing(QFont::AbsoluteSpacing, space); ui-\u0026gt;label-\u0026gt;setFont(font); ui-\u0026gt;label-\u0026gt;setText(text); override关键字 #  #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(6,0,0))  void enterEvent(QEnterEvent *); #else  void enterEvent(QEvent *); #endif  //后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。 //这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。  //下面是父类函数 virtual void enterEvent(QEvent *event); //子类建议加上override void enterEvent(QEvent *event) override; 升级到Qt6 #    源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。\n  QFontMetricsF 中的 fm.width() 换成 fm.horizontalAdvance() ，从5.11开始用新函数。\n  QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。\n  #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,0,0)) #include \u0026#34;qscreen.h\u0026#34;#define deskGeometry qApp-\u0026gt;primaryScreen()-\u0026gt;geometry() #define deskGeometry2 qApp-\u0026gt;primaryScreen()-\u0026gt;availableGeometry() #else #include \u0026#34;qdesktopwidget.h\u0026#34;#define deskGeometry qApp-\u0026gt;desktop()-\u0026gt;geometry() #define deskGeometry2 qApp-\u0026gt;desktop()-\u0026gt;availableGeometry() #endif "},{"id":12,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/","title":"工程实践","section":"Introduction","content":"Introduction #  记录各种感兴趣的尝试\n  FalconMode模式  版本说明 # FalconMode模式 日期 版本 修改内容 2021/11/21 V0.1 创建 FalconMode模式 # Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel Falcon mode: U-Boot SPL -\u0026gt; Kernel https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7 Once you are booted up into the Linux Kernel there should be NO difference. 测试启动时间 # 模式 文件系统 tftp下载时间 内核到telnet时间 正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒 正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒 Falcon模式 Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK   BBB板使用NFS挂载文件系统  版本说明 # BBB板使用NFS挂载文件系统 日期 版本 修改内容 2022/03/03 V0.1 创建 将TI SDK中提供的文件系统目录NFS导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.   "},{"id":13,"href":"/docs/Linux-World/Ubuntu/%E7%9B%AE%E5%BD%95%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE/","title":"目录共享配置","section":"Ubuntu","content":"Samba配置 #  samba配置后，仍然无法访问 #   https://blog.csdn.net/Panda_YinLP/article/details/104687438\n访问window共享目录 #  sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 #   https://linuxhint.com/install_tftp_server_ubuntu/\n https://download.samba.org/pub/samba/\nNFS挂载 #   https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04\n将文件系统目录导出 #  解压文件系统\ncd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/targetNFS 测试NFS目录是否成功\n3B-pi@raspberrypi:~ $ sudo mkdir /mnt/tisdk-default-image-am335x-evm ;sudo mount -t nfs 192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm /mnt/tisdk-default-image-am335x-evm -o nolock Automatically Mounting NFS File Systems with /etc/fstab #   https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-18-04\nOn the Host #  On the host server, install the nfs-kernel-server package, which will allow you to share your directories. Since this is the first operation that you’re performing with apt in this session, refresh your local package index before the installation:\nsudo apt update sudo apt install nfs-kernel-server Once these packages are installed, switch to the client server.\nOn the Client #  On the client server, we need to install a package called nfs-common, which provides NFS functionality without including any server components. Again, refresh the local package index prior to installation to ensure that you have up-to-date information:\nsudo apt update sudo apt install nfs-common sudo systemctl restart nfs-kernel-server sudo mount -t nfs 192.168.31.87:/home/debian /mnt/bbb/ -o nolock sudo mount -t nfs 192.168.31.115:/home/pi/Public /mnt/rpi4/ -o nolock sudo mkdir /mnt/ubuntu1604;sudo mount -t nfs 192.168.31.85:/home/qq/Public/ /mnt/ubuntu1604 -o nolock 修改/etc/fstab #  # \u0026lt;file system\u0026gt; \u0026lt;dir\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt;\t\u0026lt;pass\u0026gt; 10.10.0.10:/backups /var/backups nfs defaults 0 0 "},{"id":14,"href":"/docs/Linux-World/Ubuntu/%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E5%92%8C%E8%AF%81%E4%B9%A6/","title":"系统代理和证书","section":"Ubuntu","content":"系统代理 #  vi ~/.profile  export http_proxy=\u0026#39;http://myproxy.example.com:1080/\u0026#39; export https_proxy=\u0026#39;https://myproxy.example.com:1080/\u0026#39; export ftp_proxy=\u0026#39;http://myproxy.example.com:1080/\u0026#39; export ALL_PROXY=\u0026#39;socks://myproxy.example.com:1080/\u0026#39; export all_proxy=\u0026#39;socks://myproxy.example.com:1080/\u0026#39; export no_proxy=\u0026#39;example.com\u0026#39; $ sudo apt-get install socat $ wget http://git.yoctoproject.org/cgit/cgit.cgi/poky/plain/scripts/oe-git-proxy $ cp oe-git-proxy ~/bin $ chmod +x ~/bin/oe-git-proxy  export GIT_PROXY_COMMAND=\u0026#34;oe-git-proxy\u0026#34; export NO_PROXY=$no_proxy vi ~/.wgetrc  https_proxy = http://socks.example.com:1080 http_proxy = http://socks.example.com:1080 ftp_proxy = http://socks.example.com:1080 no_proxy = example.com:1080;127.0.0.1 use_proxy = on  https://wiki.yoctoproject.org/wiki/Working_Behind_a_Network_Proxy\n透明代理 #   https://blog.a1253247.info/2020/01/shadowsocks.html\n代理转换 #  /etc/polipo/config\n/etc/polipo/config  systemctl status polipo  www.codevoila.com/post/16/convert-socks-proxy-to-http-proxy-using-polipo\n测试网速 #  # Server tankywoo@gentoo-local::~/ » iperf -s ------------------------------------------------------------ Server listening on TCP port 5001 TCP window size: 85.3 KByte (default) ------------------------------------------------------------ [ 4] local 127.0.0.1 port 5001 connected with 127.0.0.1 port 56071 [ ID] Interval Transfer Bandwidth [ 4] 0.0-10.0 sec 27.0 GBytes 23.2 Gbits/sec  # Client tankywoo@gentoo-local::~/ » iperf -c localhost ------------------------------------------------------------ Client connecting to localhost, TCP port 5001 TCP window size: 647 KByte (default) ------------------------------------------------------------ [ 3] local 127.0.0.1 port 56071 connected with 127.0.0.1 port 5001 [ ID] Interval Transfer Bandwidth [ 3] 0.0-10.0 sec 27.0 GBytes 23.2 Gbits/sec 由于没有公钥，无法验证下列签名： #  apt updtate 时提示错误 NO_PUBKEY 648ACFD622F3D138 NO_PUBKEY 0E98404D386FA1D9\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0E98404D386FA1D9 server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none #  touch /etc/apt/apt.conf.d/99verify-peer.conf \u0026amp;\u0026amp; echo \u0026gt;\u0026gt;/etc/apt/apt.conf.d/99verify-peer.conf \u0026#34;Acquire { https::Verify-Peer false }\u0026#34; "},{"id":15,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/","title":"Effective Cpp","section":"读书笔记","content":"  1.让自己习惯C\u0026#43;\u0026#43;  将构造函数声明为explicit，可阻止被用来执行隐式类型转换，仍可被用来进行显示类型转换 class C{ public: explicit C(int x); } Accustoming Yourself to C++ # 1.View C++ as a federation of languages # C Object-Oriented C++ Template C++ STL 2.Perfer consts,enums,and inlines to#defines # 一旦宏被定义，在其后的编译过程中一直有效，除非在某处被#undef const double AspectRatio = 1.653; const char* const authorName = \u0026#34;Scott Meyers\u0026#34;; const std::string authorName(\u0026#34;Scott Meyers\u0026#34;); 对于单纯常量，最好以const对象或者enums替换#defines class GamePlayer{ private: static const int NumTurns = 5;//新一点的编译器才支持声明时定义 int scores[NumTurns]; } class GamePlayer{ private: enum{ NumTurns = 5}; int scores[NumTurns]; } 对于形似函数的宏（macros），最好改用inline函数替换#defines   2.构造、析构、赋值运算  Constructors,Destructors,and Assignment Operators # 5.Know what functions C++ silently writes and calls # 编译器可以暗自为class创建default构造函数 、copy构造函数、copy assignment操作符，以及析构函数 区分copy构造和copy赋值 class Widget{ public: Widget();//default构造 Widget(const Widget\u0026amp; rhs);//copy构造 Widget\u0026amp; operator=(const Widget\u0026amp; rhs);//copy assignment操作符 }; Widget w1;//default构造 Widget w2(w1);//copy构造 w1 = w2;//copy assignment操作符 Widget w3 = w2;//copy构造 通过是否真正产生新的对象来区分copy构造和拷贝赋值 6.Explicitly disallow the use of compiler-generated functions you do not want # 所有编译器产出的函数都是public，为驳回编译器自动提供的机能，可将相应的成员函数声明为Private并且不予实现 #define Q_DISABLE_COPY(Class) \\ Class(const Class \u0026amp;) = delete;\\ Class \u0026amp;operator=(const Class \u0026amp;) = delete; class Uncopyable { protected://允许derived对象构造和析构 Uncopyable(){} ~Uncopyable(){} private: Uncopyable(const Uncopyable\u0026amp;); Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); } //继承Uncopyable可以阻止HomeForSale对象被拷贝 class HomeForSale:private Uncopyable { .   3.资源管理  Resource Management # 13.Use objects tomanage resources # 获得资源后立刻放进管理对象，RAII(Resource Acquisition Is Initialization资源获取时机便是初始化时机) 管理对象运用析构函数确保资源被释放 auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作，vector和string几乎总是可以取代动态分配而得的数组，可以使用boost::scoped_array和boost::shared_array类 14.Think carefully about copying behavior in resource-managing classes # 如果复制动作对RAII class 并不合理，考虑禁止复制 复制RAII对象必须一并复制它所管理的资源，常见的RAII class copying行为是：抑制copying，施行引用计数法 15.Provide access to raw resources in resource-managing classes # APIs往往要求访问原始资源，所以每个RAII class应该提供一个取得其所管理之资源的办法 通常通过调用abort结束程序，来阻止异常从析构函数传播出去 class Font{ public: explicit Font(FontHandle fh):f(fh) {} ~Font() { releaseFont(f); } operator FontHandle() const;//隐式转换函数 { return f; } private: FontHandle f; } 16.   4.设计与声明  Designs and Declarations # 18.Make interfaces easy to use correctly and hard to use incorrectly # 好的接口容易被正确使用 ，不容易被误用 阻止误用的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任 19.Treat class design as type design # Class的设计就是type的设计 标准string和STL窗口都不被设计作为base classed使用，因为它们的析构函数都不带virtual 20.Prefer pass-by-reference-to-const to pass-by-value # 对于内置类型，以及STL的迭代器和函数对象，使用pass-by-value更合适 C++编译器底层中的references往往是以指针方式实现的，意味着真正传递的是指针 21.Don\u0026rsquo;t try to return a reference when you must return an object # 当必须返回新对象时，就让那个函数返回新对象，如下   5.实现  Implementations # 26.Postpone variable definitions as long as possible # std::string encryptPassword(const std::string\u0026amp; password) { std::string encrypted;//默认构造 encrypted = passwd;//赋值操作 encrypt(encrypted); return encrypted; } 更推荐下面的做法，更高效 std::string encryptPassword(const std::string\u0026amp; password) { std::string encrypted(passwd);//copy构造 encrypt(encrypted); return encrypted; } //1次构造，1次析构，n次赋值 Widget w; for(int i = 0;i \u0026lt; n; ++i) { w = ... } 更推荐上面的做法，更高效 //n次构造，n次析构 for(int i = 0;i \u0026lt; n; ++i) { Widget w; w = .   "},{"id":16,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/3.%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","title":"3.资源管理","section":"Effective Cpp","content":"Resource Management #  13.Use objects tomanage resources #   获得资源后立刻放进管理对象，RAII(Resource Acquisition Is Initialization资源获取时机便是初始化时机) 管理对象运用析构函数确保资源被释放 auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作，vector和string几乎总是可以取代动态分配而得的数组，可以使用boost::scoped_array和boost::shared_array类  14.Think carefully about copying behavior in resource-managing classes #    如果复制动作对RAII class 并不合理，考虑禁止复制\n  复制RAII对象必须一并复制它所管理的资源，常见的RAII class copying行为是：抑制copying，施行引用计数法\n  15.Provide access to raw resources in resource-managing classes #    APIs往往要求访问原始资源，所以每个RAII class应该提供一个取得其所管理之资源的办法\n  通常通过调用abort结束程序，来阻止异常从析构函数传播出去\n  class Font{ public:  explicit Font(FontHandle fh):f(fh)  {}  ~Font()  {  releaseFont(f);  }  operator FontHandle() const;//隐式转换函数  {  return f;  } private:  FontHandle f; } 16.Use the same form in corresponding uses of new and delete #    new表达式中使用[]，必须相应的delete表达式中了使用[]\n  不要对数组形式做typeddef动作\n  typedef std::string AddressLines[4];//不建议 std::string* pal = new AddressLines; delete pal;//未定义的行为 17.Store newed objects in smart pointers in standalone statements #  在单独语句内以智能指针存储newd所得对象\nint priority(); void processWidget(std::shared_ptr\u0026lt;Widget\u0026gt; pw,int priority); //调用方式1,不推荐 processWidget(std::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget),priority()); //调用方式2 std::shared_ptr\u0026lt;Widget\u0026gt; pw(new Widget);//在单独语句内以智能指针存储newd所得对象 processWidget(pw,priority()); "},{"id":17,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/BBB%E6%9D%BF%E4%BD%BF%E7%94%A8NFS%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"BBB板使用NFS挂载文件系统","section":"工程实践","content":"版本说明 #   BBB板使用NFS挂载文件系统    日期 版本 修改内容     2022/03/03 V0.1 创建      将TI SDK中提供的文件系统目录NFS导出 #  解压文件系统\ncd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/targetNFS 测试NFS目录是否成功\n3B-pi@raspberrypi:~ $ sudo mkdir /mnt/tisdk-default-image-am335x-evm ; 3B-pi@raspberrypi:~ $ sudo mount -t nfs 192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm /mnt/tisdk-default-image-am335x-evm -o nolock NFS方式启动BBB #  上电后，按下SPACE键，进入uboot提示界面\n分析uboot的nfsboot环境变量 #  nfs_options=,vers=3 nfsrootfstype=ext4 rootwait fixrtc root_dir=/home/userid/targetNFS #主机文件系统目录 server_ip=192.168.1.100\t#tftp服务器地址，即主机地址 bootfile=zImage\t#通过tftp从服务器下载的内核文件名 fdtfile=undefined\t#通过tftp从服务器下载的设备树文件名  nfsargs=setenv bootargs console=${console} ${optargs} ${cape_disable} ${cape_enable} ${cape_uboot} root=/dev/nfs rw rootfstype=${nfsrootfstype} nfsroot=${nfsroot} ip=${ip} ${cmdline} nfsboot=echo Booting from ${server_ip} ...; setenv nfsroot ${server_ip}:${root_dir}${nfs_options}; setenv ip ${client_ip}:${server_ip}:${gw_ip}:${netmask}:${hostname}:${device}:${autoconf}; setenv autoload no; setenv serverip ${server_ip}; setenv ipaddr ${client_ip}; tftp ${loadaddr} ${tftp_dir}${bootfile}; tftp ${fdtaddr} ${tftp_dir}dtbs/${fdtfile}; run nfsargs; bootz ${loadaddr} - ${fdtaddr} 准备内核镜像文件 #  通过bootfile环境变量指定了内核镜像文件名为zImage，而TI SDK中提供的内核镜像名为zImage-am335x-evm.bin，这里干脆拷贝一份\ncp tftpboot/zImage-am335x-evm.bin tftpboot/zImage 设置uboot环境变量 #  **特别注意：**由于默认的nfsboot环境变量，tftp下载设备树时，会从tftp服务目录之下的dtbs目录下载设备树，例如服务器的tftp目录为/home/qq/tftpboot，它会从/home/qq/tftpboot/dtbs/目录下，下载am335x-boneblack.dtb文件\ncd tftpboot mkdir dtbs cp am335x-boneblack.dtb dtbs/ setenv client_ip 192.168.31.87 setenv ipaddr 192.168.31.87 setenv gw_ip 192.168.31.1 setenv server_ip 192.168.31.85 setenv fdtfile am335x-boneblack.dtb setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm_manual_hplip setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm_debug_hplip_cups 启动NFS文件系统 #  ==\u0026gt; run nfsboot qtcreator配置交叉编译工具 #  安装qtcreator #  sudo apt install qtcreator 设置编译工具 #   ![qt-build_run-Qt Versions-1](/images/BBB板使用NFS挂载文件系统/qt-build_run-Qt Versions-1.png)\n   遇到问题 #  不能解析qt工程，运行时报错如下 #  /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(39): system(execute) requires one or two arguments. Project ERROR: Cannot run compiler \u0026#39;arm-none-linux-gnueabihf-g++ --sysroot=/usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/armv7at2hf-neon-linux-gnueabi\u0026#39;. Output: =================== =================== Maybe you forgot to setup the environment? /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(85): Variable QMAKE_CXX.COMPILER_MACROS is not defined. /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(210): system(execute) requires one or two arguments. Project ERROR: Cannot run compiler \u0026#39;arm-none-linux-gnueabihf-g++ --sysroot=/usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/armv7at2hf-neon-linux-gnueabi\u0026#39;. Output: =================== =================== Maybe you forgot to setup the environment? Error while parsing file /home/qq/qt_project/test_tisdk/test_tisdk.pro. Giving up. 解决办法\n https://doc-snapshots.qt.io/qtcreator-4.0/creator-build-settings.html#batch-editing\n将执行source之后的PATH变量保存到qtcreator\u0026ndash;\u0026gt;Options\u0026ndash;\u0026gt;build\u0026amp;run \u0026ndash;\u0026gt;kits \u0026ndash;\u0026gt;Environment中\n![build\u0026amp;run kits Environment-1](/images/BBB板使用NFS挂载文件系统/build\u0026amp;run kits Environment-1.png)\n运行时错误 #  Failed to create wl_display (No such file or directory) qt.qpa.plugin: Could not load the Qt platform plugin \u0026#34;wayland\u0026#34; in \u0026#34;\u0026#34; even though it was found. This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  sh: line 1: 2516 Aborted (core dumped) DISPLAY=\u0026#39;:0.0\u0026#39; /home/debian/test_tisdk Application finished with exit code 134. 解决办法\n使用vnc方式运行，添加运行时参数-platform vnc\n wayland测试 #   https://forum.qt.io/topic/60865/qt5-wayland-gui-application/3\nmkdir -p /tmp/$USER-weston chmod 0700 /tmp/$USER-weston export XDG_RUNTIME_DIR=/tmp/$USER-weston weston --tty=1 --backend=fbdev-backend.so \u0026amp;  Then I successfully ran my QT5 gui application with the wayland platform specifier:  ./myQt5App -platform wayland  https://stackoverflow.com/questions/49851562/qt-wayland-failed-to-create-display-no-such-file-or-directory\nI finally fixed this by deploying the libs needed by wayland-egl plugin:\nthe lib \u0026ldquo;libQt5WaylandClient.so.5\u0026rdquo; should be included in the deployed package. which used by the plugin.\nroot@am335x-evm:~# weston Date: 2021-05-24 UTC [08:59:53.616] weston 8.0.0  https://wayland.freedesktop.org  Bug reports to: https://gitlab.freedesktop.org/wayland/weston/issues/  Build: 8.0.0 [08:59:53.619] Command line: weston [08:59:53.619] OS: Linux, 5.4.106-g023faefa70, #1 PREEMPT Mon May 24 09:04:10 UTC 2021, armv7l [08:59:53.620] warning: XDG_RUNTIME_DIR \u0026#34;/tmp/root-weston\u0026#34; is not configured correctly. Unix access mode must be 0700 (current mode is 755), and must be owned by the user (current owner is UID 0). Refer to your distribution on how to get it, or http://www.freedesktop.org/wiki/Specifications/basedir-spec on how to implement it. [08:59:53.623] Using config file \u0026#39;/etc//weston.ini\u0026#39; [08:59:53.628] Output repaint window is 7 ms maximum. [08:59:53.631] Loading module \u0026#39;/usr/lib/libweston-8/x11-backend.so\u0026#39; [08:59:53.632] Failed to load module: /usr/lib/libweston-8/x11-backend.so: cannot open shared object file: No such file or directory [08:59:53.632] fatal: failed to create compositor backend root@am335x-evm:~# eglinfo -sh: eglinfo: command not found root@am335x-evm:~# modinfo pvrsrvkm filename: /lib/modules/5.4.106-g023faefa70/extra/pvrsrvkm.ko license: Dual MIT/GPL author: Imagination Technologies Ltd. \u0026lt;gpl-support@imgtec.com\u0026gt; license: Dual MIT/GPL author: Imagination Technologies Ltd. \u0026lt;gpl-support@imgtec.com\u0026gt; srcversion: 533BB7E5866E52F63B9ACCB alias: of:N*T*Cti,omap4-sgx540-120C* alias: of:N*T*Cti,omap4-sgx540-120 alias: of:N*T*Cti,omap3-sgx530-121C* alias: of:N*T*Cti,omap3-sgx530-121 alias: of:N*T*Cti,am3352-sgx530C* alias: of:N*T*Cti,am3352-sgx530 alias: of:N*T*Cti,am4376-sgx530C* alias: of:N*T*Cti,am4376-sgx530 alias: of:N*T*Cti,dra7-sgx544C* alias: of:N*T*Cti,dra7-sgx544 alias: of:N*T*Cti,am654-sgx544C* alias: of:N*T*Cti,am654-sgx544 depends: name: pvrsrvkm vermagic: 5.4.106-g023faefa70 preempt mod_unload modversions ARMv7 p2v8 parm: gPVRDebugLevel:Sets the level of debug output (default 0x7) (uint) root@am335x-evm:~# lsmod Module Size Used by xfrm_user 32768 2 xfrm_algo 16384 1 xfrm_user sha512_generic 20480 0 sha512_arm 24576 0 sha256_generic 16384 0 libsha256 20480 1 sha256_generic sha1_generic 16384 0 sha1_arm_neon 20480 0 sha1_arm 16384 1 sha1_arm_neon md5 16384 0 ecb 16384 0 aes_arm 16384 0 aes_generic 40960 1 aes_arm aes_arm_bs 24576 0 crypto_simd 16384 1 aes_arm_bs cryptd 24576 1 crypto_simd des_generic 16384 0 libdes 28672 1 des_generic cbc 16384 0 pru_rproc 24576 0 icss_iep 20480 0 irq_pruss_intc 16384 1 pru_rproc prueth_ecap 16384 0 musb_dsps 20480 0 musb_hdrc 106496 1 musb_dsps udc_core 28672 1 musb_hdrc phy_am335x 16384 2 usbcore 225280 1 musb_hdrc phy_generic 16384 1 phy_am335x usb_common 16384 5 phy_am335x,udc_core,musb_hdrc,musb_dsps,usbcore phy_am335x_control 16384 1 phy_am335x pruss 16384 1 pru_rproc pvrsrvkm 405504 0 pm33xx 16384 0 omap_aes_driver 24576 0 crypto_engine 16384 1 omap_aes_driver omap_crypto 16384 1 omap_aes_driver libaes 16384 4 omap_aes_driver,aes_arm_bs,aes_arm,aes_generic ti_emif_sram 16384 1 pm33xx omap_sham 32768 0 wkup_m3_ipc 16384 1 pm33xx at24 20480 0 rtc_omap 20480 4 pm33xx omap_wdt 16384 0 wkup_m3_rproc 16384 1 musb_am335x 16384 0 sch_fq_codel 20480 1 uio_module_drv 16384 0 uio 20480 1 uio_module_drv cryptodev 53248 1 libicu-dev is already the newest version (57.1-4).\rlibicu-dev set to manually installed. 运行程序\n./application -platform wayland 或者 export QT_QPA_PLATFORM=wayland ./application  https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1164/handouts/qt-creator-troubleshooting.html\n测试各种模式，除了vnc模式和offscreen，其它都运行失败\nroot@am335x-evm:/home/debian# ./test_tisdk -platform vnc QVncServer created on port 5900 ^C root@am335x-evm:/home/debian# ^C root@am335x-evm:/home/debian# ./test_tisdk -platform xcb qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;xcb\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform linuxfb Unable to figure out framebuffer device. Specify it manually. linuxfb: Failed to initialize screen qt.qpa.input: xkbcommon not available, not performing key mapping no screens available, assuming 24-bit color Cannot create window: no screens available Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform eglfs MESA-LOADER: failed to open kms_swrast (search paths /usr/lib/dri) failed to load driver: kms_swrast MESA-LOADER: failed to open swrast (search paths /usr/lib/dri) failed to load swrast driver Could not create GBM device (No such device) Could not open DRM device Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform minimalegl Opened display 0x311a0  Could not initialize egl display  EGL error Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform waylang-egl qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;waylang-egl\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform waylang qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;waylang\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform offscreen This plugin does not support propagateSizeHints() uboot启动分析 #  命令说明 #  =\u0026gt; gpio -h gpio - query and control gpio pins  Usage: gpio \u0026lt;input|set|clear|toggle\u0026gt; \u0026lt;pin\u0026gt;  - input/set/clear/toggle the specified pin gpio status [-a] [\u0026lt;bank\u0026gt; | \u0026lt;pin\u0026gt;] - show [all/claimed] GPIOs test -n 字符串\t字符串的长度不为零则为真 test -e 文件名\t如果文件存在则为真 以下为uboot环境变量中boot的值 #  从打印日志可以看出，boot值为启动时执行的第一个命令\nboot=${devtype} dev ${mmcdev} if ${devtype} rescan; then  gpio set 54  setenv bootpart ${mmcdev}:1  if test -e ${devtype} ${bootpart} /etc/fstab; then setenv mmcpart 1; fi  echo Checking for: /uEnv.txt ...  if test -e ${devtype} ${bootpart} /uEnv.txt; then  if run loadbootenv; then  gpio set 55  echo Loaded environment from /uEnv.txt  run importbootenv  fi  echo Checking if uenvcmd is set ...  if test -n ${uenvcmd}; then  gpio set 56  echo Running uenvcmd ...  run uenvcmd  fi  echo Checking if client_ip is set ...  if test -n ${client_ip}; then  if test -n ${dtb}; then  setenv fdtfile ${dtb}  echo using ${fdtfile} ...  fi  gpio set 56  if test -n ${uname_r}; then  echo Running nfsboot_uname_r ...  run nfsboot_uname_r  fi  echo Running nfsboot ...  run nfsboot  fi  fi  echo Checking for: /${script} ...  if test -e ${devtype} ${bootpart} /${script}; then  gpio set 55  setenv scriptfile ${script}  run loadbootscript  echo Loaded script from ${scriptfile}  gpio set 56  run bootscript  fi  echo Checking for: /boot/${script} ...  if test -e ${devtype} ${bootpart} /boot/${script}; then  gpio set 55  setenv scriptfile /boot/${script}  run loadbootscript  echo Loaded script from ${scriptfile}  gpio set 56  run bootscript  fi  echo Checking for: /boot/uEnv.txt ...  for i in 1 2 3 4 5 6 7; do  setenv mmcpart ${i}  setenv bootpart ${mmcdev}:${mmcpart}  if test -e ${devtype} ${bootpart} /boot/uEnv.txt; then  gpio set 55  load ${devtype} ${bootpart} ${loadaddr} /boot/uEnv.txt  env import -t ${loadaddr} ${filesize}  echo Loaded environment from /boot/uEnv.txt  if test -n ${dtb}; then  echo debug: [dtb=${dtb}] ...  setenv fdtfile ${dtb}  echo Using: dtb=${fdtfile} ...  fi  echo Checking if uname_r is set in /boot/uEnv.txt...  if test -n ${uname_r}; then  gpio set 56  setenv oldroot /dev/mmcblk${mmcdev}p${mmcpart}  echo Running uname_boot ...  run uname_boot  fi  fi  done fi 设置默认NFS启动 #  从上面脚本可以得知，想要每次直接进行NFS挂载，需要在根目录下，存在uEnv.tx文件，且uEnv.txt中包含client_ip变量，如下即可，之后每次都会先检查eMMC中的根目录的uEnv.txt，判断是否需要NFS启动了\n#uname_r=4.19.94-ti-r42 client_ip=192.168.31.87 gw_ip=192.168.31.1 server_ip=192.168.31.85 dtb=am335x-boneblack.dtb root_dir=/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm 下面为uboot日志\ngpio: pin 56 (gpio 56) value is 0 gpio: pin 55 (gpio 55) value is 0 gpio: pin 54 (gpio 54) value is 0 gpio: pin 53 (gpio 53) value is 1 Card did not respond to voltage select! Card did not respond to voltage select! switch to partitions #0, OK mmc1(part 0) is current device Scanning mmc 1:1... gpio: pin 56 (gpio 56) value is 0 gpio: pin 55 (gpio 55) value is 0 gpio: pin 54 (gpio 54) value is 0 gpio: pin 53 (gpio 53) value is 1 switch to partitions #0, OK mmc1(part 0) is current device gpio: pin 54 (gpio 54) value is 1 Checking for: /uEnv.txt ... Checking for: /boot.scr ... Checking for: /boot/boot.scr ... Checking for: /boot/uEnv.txt ... gpio: pin 55 (gpio 55) value is 1 "},{"id":18,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/","title":"git高级使用","section":"Git","content":"版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      个人使用总结 #  Merge节点 #  Git有两种合并：一种是\u0026quot;直进式合并\u0026quot;（fast forward），不生成单独的合并节点；另一种是\u0026quot;非直进式合并\u0026quot;（none fast-forword），会生成单独节点。\n前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用--no-ff参数）。只要发生合并，就要有一个单独的合并节点。\n push策略 #  不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n$ git config --global push.default matching # 或者 $ git config --global push.default simple 解决merge 和 rebase 合并冲突 #  #merge 和 rebase 对于 ours 和 theirs 的定义是完全相反的。在 merge 时，ours 指代的是当前分支，theirs 代表需要被合并的分支。而在 rebase 过程中，ours 指向了修改参考分支，theirs 却是当前分支 git checkout --ours src/MyFile.cs. git checkout --theirs src/MyFile.cs  git checkout HEAD -- src/MyFile.cs git checkout my_branch -- src/MyFile.cs git checkout 6a363d8 -- src/MyFile.cs  revert 、rebase 、cherry-pick后面都可以跟 \u0026ndash;continue \u0026ndash;skip \u0026ndash;abort\n cherry-pick使用 #  cherry-pick (somebody/something) to choose the best people or things from a group and leave those that are not so good\n#62ecb3为分支上的commit git cherry-pick 62ecb3  #合并多个commit git cherry-pick A B C D E F  #会把从从版本A（不包含）到B（包含）即（A，B]的版本pull到当前分支 git cherry-pick A..B git cherry-pick A..B C..D E..F  git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort 打标记： #  #默认给当前分支的HEAD打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34;  #给指定分支的HEAD打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34; dev_new_feature  #给指定的commit_id打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34; a2701a9  #上传标记 git push origin tag_name,例如： git push origin v1.0.1  #上传所有标记 git push origin --tags 删除文件 #  配合.gitignore文件\n#删除 untracked files  git clean -f  #连 untracked 的目录也一起删掉  git clean -fd  #连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）  git clean -xfd  #在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删  git clean -nxfd  git clean -nf  git clean -nfd 《pro git》总结 #  #查看已经暂存起来的变化 git diff --cached  #重新提交，合并到上一次提交 git commit –amend  #如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项 git push origin --tags  #若要查看各个分支最后一个提交对象的信息，运行 git branch -v  #查看哪些分支已被并入当前分支 git branch –merged  #查看尚未合并的工作 git branch --no-merged  #查看master到contrib之间的所有差异提交 git diff master...contrib  #在 git log 后加 -p 选项将展示每次提交的内容差异。  #查看简报 git shortlog --no-merges master --not v1.0.1  #如果你想查找所有从refA 或refB 包含的但是不被refC 包含的提交 git log refA refB ^refC  #提交时将差异分块添加 git add -p 或者git add –patch  #储藏（Stashing） git stash git stash list git stash apply stash@{2} git stash apply --index git stash pop git stash clear  #查看历史提交记录，被删除后不在分支上的commit也能在这里找到 git reflog  #垃圾回收 git fsck --full SVN迁移到Git #   https://blog.axosoft.com/migrating-git-svn/\n https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git\n安装工具\nsudo apt-get install git-svn Git其它用途 #  格式化代码 #   https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\n使用了git提供的hook pre-commit\n#!/bin/bash array=`git diff-index --name-only HEAD`  for name in ${array} do  extension=${name##*.}  if [[ ${extension} == \u0026#34;h\u0026#34; || ${extension} == \u0026#34;cpp\u0026#34; || ${extension} == \u0026#34;c\u0026#34; ]]  then # echo \u0026#34;###astyle###\u0026#34;$name  if [ -f ${name} ]; then  #去掉window下的^M  # fromdos ${name}  #去掉文件头中的BOM标记  sed -i \u0026#39;1s/^\\xEF\\xBB\\xBF//\u0026#39; ${name}  #格式化代码  astyle --style=ansi -s4 -S -N -L -m0 -M40 -f -U -k1 -W1 -j -xL -n ${name}  fi  git add ${name}  fi done 创建提交hook软链接文件 chmod +x pre-commit.sh cd .git/hooks/ ln -s ../../pre-commit.sh pre-commit\n通过git-web提供的hook发送邮件 #  原理：\n1、当有push event时就触发web hook，发送事件信息到指定的服务端\n2、服务端接收到事件，解析事件，构造html页\n3、使用smtp将html以邮件发送\n root@7f438265e3c9:/home/root# cat web_hook_server.py  #-*- coding:utf-8 -*- import BaseHTTPServer import SocketServer import CGIHTTPServer import logging import json import urllib import urlparse from urlparse import unquote import send_notify  class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):  \u0026#39;\u0026#39;\u0026#39;处理请求并返回页面\u0026#39;\u0026#39;\u0026#39;  def do_POST(self):  logging.debug(\u0026#39;POST %s\u0026#39; % (self.path))  print( \u0026#34;incomming http: \u0026#34;, self.path )   content_length = int(self.headers[\u0026#39;Content-Length\u0026#39;]) # \u0026lt;--- Gets the size of data  post_data = self.rfile.read(content_length) # \u0026lt;--- Gets the data itself  #将URL编码方式的字符转换为普通字符串  js_str = urllib.unquote(post_data[8:])  send_notify.sendNotify(js_str)  self.send_response(200)  if __name__ == \u0026#39;__main__\u0026#39;:  serverAddress = (\u0026#39;\u0026#39;, 5410)  SocketServer.TCPServer.allow_reuse_address = True  server = SocketServer.TCPServer(serverAddress, RequestHandler)  server.serve_forever() 解决xls文件在git比较差异 #   https://stackoverflow.com/questions/17083502/how-to-perform-better-document-version-control-on-excel-files-and-sql-schema-fil\n https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#Binary-Files\n https://gitlab.inria.fr/sgilles/homepage/-/wikis/enable-diffing-of-excel-files-with-git\n通过指定不同格式的文件读取工具，将工具的输出进行对比\n# -*- coding: utf-8 -*-  #!/usr/bin/env python  import sys from mmap import mmap,ACCESS_READ from xlrd import open_workbook # http://www.python-excel.org/ # 使得 sys.getdefaultencoding() 的值为 \u0026#39;utf-8\u0026#39;  reload(sys) # reload 才能调用 setdefaultencoding 方法  sys.setdefaultencoding(\u0026#39;utf-8\u0026#39;) # 设置 \u0026#39;utf-8\u0026#39;   file_name=sys.argv[1]  wb = open_workbook(file_name)  s = wb.sheets()[0]  r_count = s.nrows c_count = s.ncols  for row in range(r_count):  for col in range(c_count):  print (\u0026#34;row[%4d],col[%4d],value[%s]\u0026#34; % (row,col,s.cell(row, col).value))  continue  sys.stdout.write(\u0026#39;\\n\u0026#39;) 制作补丁包 #  将发布的二进制包用git管理之后，可以用git命令导出，两个版本之前的删除、新增和修改文件列表\ngit diff\n--name-status Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean.  --diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]] Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.  Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled. 获取删除文件列表\ngit diff --diff-filter=D --name-only 05e0ccf fd48e04 opt/ 获取新增和修改文件列表，并拷贝到输出目录output_dir\ngit diff old_commit new_commit --diff-filter=AM --name-only |xargs -t -i{} cp --parents -d {} output_dir cp选项说明\n--parents use full source file name under DIRECTORY #copies the file a/b/c to existing_dir/a/b/c, creating any missing intermediate directories. #即，当被复制的源文件路径包含子目录名，--parent 选项会在目标目录下自动创建不存在的子目录。目标目录本身必须已经存在。 cp --parents a/b/c existing_dir  -d same as --no-dereference --preserve=links #当拷贝软链接时，如果不添加-d选项，则会拷贝软链接对应的文件，加了-d选项后，则直接拷贝这个软链接 mantis plugin集成（未实现） #  作用：\n开发人员执行commit时，当日志信息中包含Fix #xxxx等信息时，mantis中对应的缺陷会自动修改状态为已修正，已解决，并将日志信息添加到mantis中。减少了开发人员工作量，方便缺陷与代码的跟踪\n https://github.com/mantisbt-plugins/source-integration/blob/master/SourceGitlab/README.md\n https://noswap.com/blog/integrating-git-svn-with-mantisbt\n   使用Git管理WIKI（未实现） #  gollum \u0026ndash; A git-based Wikihttps://github.com/gollum/gollum\ngitlab集成了gollum工具\n作用：记录项目迭代中的所有文档，集中管理\nCI和CD（未实现） #  CI 持续集成（Continuous Integration）\nCD 持续交付（Continuous Delivery）\nCD 持续部署（Continuous Deployment）\n https://www.redhat.com/zh/topics/devops/what-is-ci-cd\n 对于iMAC项目的应用场景：\n实现代码提交后，执行编译、打包、FTP上传发布\ngit生成patch #  3B-pi@raspberrypi:~/Public/Qin-master/patch $ git lg * 92770dd - (HEAD -\u0026gt; master, origin/master) style:change handle_Default(int keyId) to handle_Default(int unicode, int keyId) =\u0026gt; QinIMTables.h (9 hours ago) \u0026lt;author2\u0026gt; * c8a0e5a - style:格式化代码 (10 hours ago) \u0026lt;author1\u0026gt; * f281c86 - fix:完善五笔和仓颉的翻页功能 (10 hours ago) \u0026lt;author2\u0026gt; * 5e8aecf - style:删除无用文件 (10 hours ago) \u0026lt;author2\u0026gt; * b807285 - feat: 增加仓颉和五笔输入法 (10 hours ago) \u0026lt;author2\u0026gt; * 09d81b2 - style:将TableIM(无虾米)从IMBase中分离出来 (10 hours ago) \u0026lt;author2\u0026gt; * 05657a6 - fix:shift三种状态的转换 (10 hours ago) \u0026lt;author2\u0026gt; * 1ddf8ed - feat:谷歌拼音输入法实现用户自定义造词逻辑 (11 hours ago) \u0026lt;author1\u0026gt; * a94fece - feat:谷歌拼音完成选择候选词上屏 (14 hours ago) \u0026lt;author1\u0026gt; * ff34572 - feat:谷歌拼音增加候选词翻页 (14 hours ago) \u0026lt;author1\u0026gt; * 1fdcf02 - fix:修改UI文件中指定的字母按键键值 (32 hours ago) \u0026lt;author1\u0026gt; * 3c86422 - fix:完善谷歌拼音输入法 (32 hours ago) \u0026lt;author1\u0026gt; * d710041 - feat:候选增加左右按钮完成翻页功能 (7 days ago) \u0026lt;author2\u0026gt; * cadc079 - feat:增加长按连续输入，长按连续删除。设置setAutoRepeat(true)属性 (7 days ago) \u0026lt;author2\u0026gt; * b633021 - fix:符号|和\\，=和+切换显示有问题 符号\u0026amp;不能显示 (7 days ago) \u0026lt;author2\u0026gt; * 1940107 - feat:添加谷歌拼音核心代码 (8 days ago) \u0026lt;author1\u0026gt; * 9ae1441 - chore:整理开源依赖库目录，添加谷歌拼音输入法 (8 days ago) \u0026lt;author1\u0026gt; * d17947c - feat:增加数字符号切换按钮 (3 weeks ago) \u0026lt;author1\u0026gt; * 646a407 - fix:解决英文输入下，按空格无效 (3 weeks ago) \u0026lt;author1\u0026gt; * b588a3b - feat:左右shift按钮状态关联，准备添加左右翻页按钮 (3 weeks ago) \u0026lt;author1\u0026gt; * 9644ac2 - feat:在虚拟键盘布局中增加虚拟键盘关闭按钮 (4 weeks ago) \u0026lt;author1\u0026gt; * 3b97463 - (dev_init) init (4 weeks ago) \u0026lt;author1\u0026gt;  #生成区间范围的补丁 git format-patch 3b97463..92770dd  #结果如下 3B-pi@raspberrypi:~/Public/Qin-master/patch $ ls -lth total 20M -rw-r--r-- 1 pi pi 1.3K Feb 18 00:08 0021-style-change-handle_Default-int-keyId-to-handle_Defa.patch -rw-r--r-- 1 pi pi 163K Feb 18 00:08 0020-style.patch -rw-r--r-- 1 pi pi 32K Feb 18 00:08 0019-fix.patch -rw-r--r-- 1 pi pi 5.1M Feb 18 00:08 0018-style.patch -rw-r--r-- 1 pi pi 13M Feb 18 00:08 0017-feat.patch -rw-r--r-- 1 pi pi 11K Feb 18 00:08 0016-style-TableIM-IMBase.patch -rw-r--r-- 1 pi pi 7.6K Feb 18 00:08 0015-fix-shift.patch -rw-r--r-- 1 pi pi 9.2K Feb 18 00:08 0014-feat.patch -rw-r--r-- 1 pi pi 2.7K Feb 18 00:08 0013-feat.patch -rw-r--r-- 1 pi pi 14K Feb 18 00:08 0012-feat.patch -rw-r--r-- 1 pi pi 20K Feb 18 00:08 0011-fix-UI.patch -rw-r--r-- 1 pi pi 7.7K Feb 18 00:08 0010-fix.patch -rw-r--r-- 1 pi pi 14K Feb 18 00:08 0008-feat-setAutoRepeat-true.patch -rw-r--r-- 1 pi pi 5.6K Feb 18 00:08 0009-feat.patch -rw-r--r-- 1 pi pi 4.0K Feb 18 00:08 0007-fix.patch -rw-r--r-- 1 pi pi 11K Feb 18 00:08 0006-feat.patch -rw-r--r-- 1 pi pi 1.4M Feb 18 00:08 0005-chore.patch -rw-r--r-- 1 pi pi 16K Feb 18 00:08 0004-feat.patch -rw-r--r-- 1 pi pi 4.5K Feb 18 00:08 0003-fix.patch -rw-r--r-- 1 pi pi 8.0K Feb 18 00:08 0002-feat-shift.patch -rw-r--r-- 1 pi pi 7.0K Feb 18 00:08 0001-feat.patch  #应用补丁 git am ~/Public/Qin-master/patch/*.patch git批量修改author #  参考 https://www.git-tower.com/learn/git/faq/change-author-name-email\n  Run the following script from terminal after changing the variable values\n#!/bin/sh  git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;your-old-email@example.com\u0026#34; CORRECT_NAME=\u0026#34;Your Correct Name\u0026#34; CORRECT_EMAIL=\u0026#34;your-correct-email@example.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags   Push the corrected history to GitHub:\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39;   OR if you like to push selected references of the branches then use\ngit push --force --tags origin \u0026#39;refs/heads/develop\u0026#39; git验证机制更新 #   https://www.bswen.com/2021/09/others-how-to-solve-github-issue1.html\n"},{"id":19,"href":"/docs/Qt%E6%80%BB%E7%BB%93/QSS%E6%A0%B7%E5%BC%8F/","title":"QSS样式","section":"Qt总结","content":"QSS样式 #  直接调用控件的 setstylesheet, 结果是每个控件 style 返回的对象都是不同的(地址不同足以证明是不同的对象), 而只给 QApplication 对象 setStyleSheet, 每个控件的 style 函数返回的对象都是相同的. 基于以上原因, 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有 一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是.\n默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\u0026quot;*{outline:0px;}\u0026quot;);\noutline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控 件, 也不一定是矩形\noutline: none; width, height 两个属性, 设置的均是盒子的内容的宽高, 而我们在 c++ 代码中的窗口的 width 与 height 指的是整个盒子的宽度与高度,\n指示器设置样式 #   可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置，  *::down-arrow{}\r*::menu-indicator{}\r*::up-arrow:disabled{}\r*::up-arrow:off{} QPushButton左对齐文字 #    QPushButton左对齐文字，需要设置样式表\nQPushButton{text-align:left;}   三种设置文本的方法 #  QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。\n//常规办法 ui-\u0026gt;label-\u0026gt;setText(\u0026#34;hello\u0026#34;); //取巧办法 ui-\u0026gt;label-\u0026gt;setProperty(\u0026#34;text\u0026#34;, \u0026#34;hello\u0026#34;); //属性大法 ui-\u0026gt;label-\u0026gt;setStyleSheet(\u0026#34;qproperty-text:hello;\u0026#34;); 样式表不起作用 #   Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。   方法一：设置属性 this-\u0026gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。  void Widget::paintEvent(QPaintEvent *)\r{\rQStyleOption option;\roption.initFrom(this);\rQPainter painter(this);\rstyle()-\u0026gt;drawPrimitive(QStyle::PE_Widget, \u0026amp;option, \u0026amp;painter, this);\r} 直接传入样式表文件路径 #  设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 \u0026lsquo;file:///\u0026rsquo; 开头，是的话则自动读取样式表文件进行设置，无需手动读取。\n//以前都是下面的方法 QFile file(\u0026#34;:/qss/psblack.css\u0026#34;); if (file.open(QFile::ReadOnly)) {  QString qss = QLatin1String(file.readAll());  qApp-\u0026gt;setStyleSheet(qss);  file.close(); }  //其实一行代码就行 qApp-\u0026gt;setStyleSheet(\u0026#34;file:///:/qss/psblack.css\u0026#34;); //特别说明，只支持qApp-\u0026gt;setStyleSheet 不支持其他比如widget-\u0026gt;setStyleSheet QCheckBox #  对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行。\nQCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator{ width:13px; height:13px; }  QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked{ image:url(:/qss/flatwhite/checkbox_unchecked.png); }  QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled{ image:url(:/qss/flatwhite/checkbox_unchecked_disable.png); }  QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked{ image:url(:/qss/flatwhite/checkbox_checked.png); }  QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled{ image:url(:/qss/flatwhite/checkbox_checked_disable.png); }  QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate{ image:url(:/qss/flatwhite/checkbox_parcial.png); }  QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled{ image:url(:/qss/flatwhite/checkbox_parcial_disable.png); } QTabBar #  QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮。\n//对tabWidget设置无切换按钮\rui-\u0026gt;tabWidget-\u0026gt;setUsesScrollButtons(false);\r//对tabBar设置无切换按钮\rui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setUsesScrollButtons(false);\r//对整个系统的选项卡设置无切换按钮\rQTabBar{qproperty-usesScrollButtons:false;}\r//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔\rQTabBar{qproperty-expanding:false;}\r//设置选项卡关闭按钮可见\rQTabBar{qproperty-tabsClosable:true;}\r//还有其他属性参见QTabBar头文件有惊喜\r//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置 设置字体 #  设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。\n//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget  //下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont QFont font; font.setPixelSize(20); this-\u0026gt;setFont(font); this-\u0026gt;setStyleSheet(\u0026#34;{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;QWidget{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;Widget{font:26px;}\u0026#34;);  //下面才是通过样式表设置整个控件+子控件的字体 this-\u0026gt;setStyleSheet(\u0026#34;font:26px;\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;*{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;QWidget\u0026gt;*{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;Widget\u0026gt;*{font:26px;}\u0026#34;);  //下面设置全局字体 qApp-\u0026gt;setFont(font); *{font: normal 20px “微软雅黑”;}  QPushButton{ color: blue; }  namespace ns {  class MyPushButton : public QPushButton {  // ...  } } // ... qApp-\u0026gt;setStyleSheet(\u0026#34;ns--MyPushButton { background: yellow; }\u0026#34;);  .QPushButton{ color: blue; }  QAbstractSpinBox{ min-height: 30px; max-height: 30px; border-width: 1px; rder-style: solid; order-color: gray; padding: 0px; }  #button_1{  color: red; }  QPushButton#settings_popup_fileDialog_button{  min-height: 31px;  min-width: 70px;  border: 1px solid black;  color: #F0F0F0;  min-height: 10px;  border-radius:3px;  background: qlineargradient(spread:pad, x1:0, y1:0, x2:0, y2:1, stop:0 #454648, stop:1 #7A7A7A); }  BaseDialog QPushButton{  min-width: 120px;  min-height: 40px;  max-width: 120px;  max-height: 40px;  font-size: 20px;  padding: 0px; }  .QGroupBox \u0026gt; .QCheckBox{  color: blue; }  [objectName~=\u0026#34;button\u0026#34;]{  color: red; }  .QLineEdit, .QComboBox{  border: 1px solid gray;  background-color:white; } qss优先级 #  给控件直接设置的样式 \u0026gt; 给 QApplication 设置的样式\n如果是间接选中,那么最终的样式就是离目标最近的那个\n后面的样式会覆盖掉前面的样 式\nId \u0026gt; 类 \u0026gt; 类型 \u0026gt; 通配符 \u0026gt; 继承 \u0026gt; 默认\n"},{"id":20,"href":"/docs/Linux-World/Ubuntu/%E5%85%B6%E5%AE%83/","title":"其它","section":"Ubuntu","content":"ubuntu扩容 #   https://blog.csdn.net/qq_34160841/article/details/113058756\nlinux命令 #   https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html\n安装armhf ubuntu #   https://wiki.ubuntu.com/ARM/RaspberryPi\n"},{"id":21,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/","title":"工作总结","section":"Introduction","content":"Introduction #  记录工作中遇到的难点及解决方法\n  乱码  因此以下几行等价（以 UTF-8 编码保存 C++ 源文件）： const char s1[] = \u0026#34; 最喜欢 C++ 了！ \u0026#34;; const char s2[] = \u0026#34;\\xe6\\x9c\\x80\\xe5\\x96\\x9c\\xe6\\xac\\xa2\\x43\\x2b\u0026#34; \u0026#34;\\x2b\\xe4\\xba\\x86\\xef\\xbc\\x81\u0026#34;; const char s3[] = { 0xe6, 0x9c, 0x80, 0xe5, 0x96, 0x9c, 0xe6, 0xac, 0xa2, 0x43, 0x2b, 0x2b, 0xe4, 0xba, 0x86, 0xef, 0xbc, 0x81, 0x00 }; 在兼顾了计算性能和存储性能之后， Qt 小组决定 将 UTF-16 作为 QString 的编码格式 源代码中出现的中文字符串常量，在被 Qt 使用之前， 都经历了一次由「多字节编码」转换为 UTF-16 的过程 QString 可以在必要的时候由 const char* 隐 式 或 显 式 转 换 而 成 。 这 个 过 程 中 使 用 的 编 码 ， 就 是 QTextCodec::codecForCStrings   数据库  附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764 attach [database] filename as database_name;\rdetach [database] database_name; Squeezing Performance from SQLite: Insertions # https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2 CREATE INDEX tag_titles ON tags (title);\rEXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = \u0026#34;Kotlin\u0026#34;;   日志模块实现思路  版本说明 # 日志模块实现 日期 版本 修改内容 2022/03/01 V0.1 创建 实现目标 # 整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦 整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时 能做到内存中始终能导出最近的日志到U盘中 程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0) 参考实现 # Qt5官方日志QLoggingCategory测试 # QLoggingCategory represents a certain logging category - identified by a string - at runtime. A category can be configured to enable or disable logging of messages per message type.   "},{"id":22,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/","title":"Advanced Qt Programming","section":"读书笔记","content":"  Table Model  Qt\u0026rsquo;s model/view architecture # Qt\u0026rsquo;s model hierarchy # 关联Table Model中的数据到QComboBox，并过滤重复数据 # void MainWindow::createComboBoxModel(QComboBox *comboBox, int column) { delete comboBox-\u0026gt;model(); UniqueProxyModel *uniqueProxyModel = new UniqueProxyModel(column,this); uniqueProxyModel-\u0026gt;setSourceModel(model); uniqueProxyModel-\u0026gt;sort(column, Qt::AscendingOrder); comboBox-\u0026gt;setModel(uniqueProxyModel); comboBox-\u0026gt;setModelColumn(column); } 清除QTableView中的选择 # QItemSelectionModel *selectionModel = tableView-\u0026gt;selectionModel(); selectionModel-\u0026gt;clearSelection(); QItemSelection和QItemSelectionModel进行任意行组合选择 # QItemSelection selection; int firstSelectedRow = -1; for (int row = 0; row \u0026lt; proxyModel-\u0026gt;rowCount(); ++row) { QModelIndex index = proxyModel-\u0026gt;index(row, Zipcode); QItemSelection rowSelection(index, index); selection.   Tree Model    "},{"id":23,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/4.%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/","title":"4.设计与声明","section":"Effective Cpp","content":"Designs and Declarations #  18.Make interfaces easy to use correctly and hard to use incorrectly #    好的接口容易被正确使用 ，不容易被误用\n  阻止误用的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任\n  19.Treat class design as type design #    Class的设计就是type的设计\n  标准string和STL窗口都不被设计作为base classed使用，因为它们的析构函数都不带virtual\n  20.Prefer pass-by-reference-to-const to pass-by-value #    对于内置类型，以及STL的迭代器和函数对象，使用pass-by-value更合适\n  C++编译器底层中的references往往是以指针方式实现的，意味着真正传递的是指针\n  21.Don\u0026rsquo;t try to return a reference when you must return an object #  当必须返回新对象时，就让那个函数返回新对象，如下\ninline const Rational operator* (const Ratinal\u0026amp; lhs,const Rational\u0026amp; rhs) {  return Rational(lhs.n * rhs.n,lhs.d * rhs.h);//编译器会优化掉构造和析构的开销 } 不要返回pointer 或reference指向一个local stack 对象，也不要返回reference指向一个heap-allocated对象，也不要返回pointer或reference指向一个local static 对象，因为有可能 同时需要多个这样的对象\n//不推荐 inline const Rational operator* (const Ratinal\u0026amp; lhs,const Rational\u0026amp; rhs) {  static Rational result;  result = ...;  return result; } 22.Declare data members private #  切记将成员变量声明为private,利用封装性\n23.Prefer non-member non-friend functions to member functions #  宁可拿non-member non-friend函数替换member函数\nclass WebBrowser{ public: \tvoid clearCache();  void clearHistory();  void remove Cookies(); };  class WebBrowser{ public: \tvoid clearEverything()  {  clearCache();  clearHistory();  remove Cookies();  } private: \tvoid clearCache();  void clearHistory();  void remove Cookies(); };  //更推荐的做法 void clearBrovser(WebBrowser\u0026amp; wb) {  wb.clearCache();  wb.clearHistory();  wb.remove Cookies(); } 24.Declare non-membe functions when type conversions should apply to all parameters #  如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member\nclass Rational{ public:  Rational(int numerator = 0,int denominator = 1);//允许隐式类型转换  int numerator() const;  int denominator() const; public: \tconst Rational operation*(const Rational\u0026amp; rhs) const; };  Rational oneEighth(1,8); Rational oneHalf(1,2); Rational result = oneHalf * oneEighth; result = result * oneEighth; result = oneHalf * 2;//OK 隐式类型转换 result = 2 * oneHalf;//==\u0026gt;2.operator*(oneHalf) 错误 class Rational{ \t... };  const Rational operator*(const Rational\u0026amp; lhs,const Rational\u0026amp; rhs) {  return Rational(lhs.numerator() * rhs.numerator(),  lhs.denominator() * rhs.denominator()); } Rational oneFourth(1,4); Rational result; result = oneFourth * 2;//OK 隐式类型转换 result = 2 * oneFourth;//OK 隐式类型转换 25.Consider support for a non-throwing swap #  std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常\n namespace WidgetStuff{  template\u0026lt;typename T\u0026gt;  class Widget{  ...  void swap(Widget\u0026amp; other)  {  using std::swap;  swap(pImpl,other.pImpl);  }  };  ...  template\u0026lt;typename T\u0026gt;  void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a,Widget\u0026lt;T\u0026gt;\u0026amp; b)  {  a.swap(b);  } } template\u0026lt;typename T\u0026gt; void doSomething(T\u0026amp; obj1,T\u0026amp; obj2) {  using std::swap();  swap(obj1,obj2);//为T类型对象调用最佳swap版本 } "},{"id":24,"href":"/docs/Qt%E6%80%BB%E7%BB%93/","title":"Qt总结","section":"Introduction","content":"Qt总结\n  常见类使用  常见类使用 # QTableWidget # 关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。 //每次调用 clearContents 都会自动清理之前的item ui-\u0026gt;tableWidget-\u0026gt;clearContents(); for (int i = 0; i \u0026lt; count; ++i) { ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 0, new QTableWidgetItem(\u0026#34;aaa\u0026#34;)); ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 1, new QTableWidgetItem(\u0026#34;bbb\u0026#34;)); ui-\u0026gt;tableWidget-\u0026gt;setCellWidget(i, 2, new QPushButton(\u0026#34;ccc\u0026#34;)); } QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充， //方法1：字符串空格填充 ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;测 试\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;人员管理\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;系统设置\u0026#34;); //方法2：识别尺寸改变事件自动设置最小宽度 void MainWindow::resizeEvent(QResizeEvent *e) { int count = ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;count(); int width = this-\u0026gt;width() - 30; QString qss = QString(\u0026#34;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(width / count); this-\u0026gt;setStyleSheet(qss); } //方法3：设置全局样式，不同选项卡个数的设置不同的宽度 QStringList list; list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;2\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).   snippet  延时异步加载 # 用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 //异步执行load函数\rQMetaObject::invokeMethod(this, \u0026#34;load\u0026#34;, Qt::QueuedConnection);\r//延时10毫秒执行load函数\rQTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 # //拿到控件元对象 const QMetaObject *metaObject = widget-\u0026gt;metaObject(); //所有属性的数量 int propertyCount = metaObject-\u0026gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u0026gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u0026lt; propertyCount; ++i) { QMetaProperty metaProperty = metaObject-\u0026gt;property(i); const char *name = metaProperty.name(); const char *type = metaProperty.typeName(); QVariant value = widget-\u0026gt;property(name); qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; } //所有方法的数量 int methodCount = metaObject-\u0026gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u0026gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u0026lt; methodCount; ++i) { QMetaMethod metaMethod = metaObject-\u0026gt;method(i); const char *name = metaMethod.   QSS样式  QSS样式 # 直接调用控件的 setstylesheet, 结果是每个控件 style 返回的对象都是不同的(地址不同足以证明是不同的对象), 而只给 QApplication 对象 setStyleSheet, 每个控件的 style 函数返回的对象都是相同的. 基于以上原因, 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有 一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是. 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\u0026quot;*{outline:0px;}\u0026quot;); outline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控 件, 也不一定是矩形 outline: none; width, height 两个属性, 设置的均是盒子的内容的宽高, 而我们在 c++ 代码中的窗口的 width 与 height 指的是整个盒子的宽度与高度, 指示器设置样式 # 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， *::down-arrow{}\r*::menu-indicator{}\r*::up-arrow:disabled{}\r*::up-arrow:off{} QPushButton左对齐文字 # QPushButton左对齐文字，需要设置样式表 QPushButton{text-align:left;} 三种设置文本的方法 # QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 //常规办法 ui-\u0026gt;label-\u0026gt;setText(\u0026#34;hello\u0026#34;); //取巧办法 ui-\u0026gt;label-\u0026gt;setProperty(\u0026#34;text\u0026#34;, \u0026#34;hello\u0026#34;); //属性大法 ui-\u0026gt;label-\u0026gt;setStyleSheet(\u0026#34;qproperty-text:hello;\u0026#34;); 样式表不起作用 # Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-\u0026gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 void Widget::paintEvent(QPaintEvent *)\r{\rQStyleOption option;\roption.   整理 Qt Snippet  延时异步加载 # 用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 //异步执行load函数\rQMetaObject::invokeMethod(this, \u0026#34;load\u0026#34;, Qt::QueuedConnection);\r//延时10毫秒执行load函数\rQTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 # //拿到控件元对象 const QMetaObject *metaObject = widget-\u0026gt;metaObject(); //所有属性的数量 int propertyCount = metaObject-\u0026gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u0026gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u0026lt; propertyCount; ++i) { QMetaProperty metaProperty = metaObject-\u0026gt;property(i); const char *name = metaProperty.name(); const char *type = metaProperty.typeName(); QVariant value = widget-\u0026gt;property(name); qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; } //所有方法的数量 int methodCount = metaObject-\u0026gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u0026gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u0026lt; methodCount; ++i) { QMetaMethod metaMethod = metaObject-\u0026gt;method(i); const char *name = metaMethod.   "},{"id":25,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/5.%E5%AE%9E%E7%8E%B0/","title":"5.实现","section":"Effective Cpp","content":"Implementations #  26.Postpone variable definitions as long as possible #  std::string encryptPassword(const std::string\u0026amp; password) {  std::string encrypted;//默认构造 \tencrypted = passwd;//赋值操作  encrypt(encrypted);  return encrypted; } 更推荐下面的做法，更高效\nstd::string encryptPassword(const std::string\u0026amp; password) {  std::string encrypted(passwd);//copy构造  encrypt(encrypted);  return encrypted; } //1次构造，1次析构，n次赋值 Widget w; for(int i = 0;i \u0026lt; n; ++i) {  w = ... } 更推荐上面的做法，更高效\n//n次构造，n次析构 for(int i = 0;i \u0026lt; n; ++i) {  Widget w;  w = ... } 27.Minimize casting #  优良的C++代码很少使用转型\n宁可使用C++-style转型，不要使用旧式转型，前者很容易辨识出来\nconst_cast\u0026lt;T\u0026gt;( expression ) //将const转换为非const dynamic_cast\u0026lt;T\u0026gt;( expression )//安全向下转型，用来决定某对象是否归属继承体系中的某个类型 reinterpret_cast\u0026lt;T\u0026gt;( expression )//低级转型，例如将int*转型为int static_cast\u0026lt;T\u0026gt;( expression )//强迫隐式转换 例如将non-const对象转换为const对象，将int转换为double，将pointer-to-base转换为pointer-to-derived，将void*转换为typed指针 优点：\n1、很容易在代码中被辨识出来 ，找出类型在哪个地点被破坏\n2、转换动作的目标愈窄化，编译器愈能诊断出错误\n在一个4层深的单继承体系内的某个对象身上执行dynamic_cast，每一次dynamic_cast会耗用多达4次的strcmp调用，用以比较class名称\n28.Avoid retuning \u0026ldquo;handles\u0026rdquo; to object internals #   对于内置类型，以及STL的迭代器和函数对象，使用pass-by-value更合适 C++编译器底层中的references往往是以指针方式实现的，意味着真正传递的是指针 避免返回handles（包括references、指针、迭代器）指向对象内部  29.Strive for exception-safe code #    copy-and-swap 是对对象状态做出“全有或全无”改变的一个很好办法\n  “强烈保证”往往能够以copy-and-swap 实现出来，但是“强烈保证”并非所有函数 都可实现或具备现实意义\n  30.Understand the ins and outs of inlining #    inline函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之，这样做可能增加你的目标码(object code)大小\n  inline造成的代码膨胀亦会导致额外的换页行为(paging)，降低指令高速缓存装置的击中率(instruction cache hit rate)，以及伴随这些而来的效率损失\n  如果inline函数的本体很小，编译器针对“函数本体”所产出的目标码可能 比针对“函数调用”所产生的目标码更小\n  inline在大多数C++程序中是编译期行为\n  inline只是一个申请，编译器可加以忽略，大部分编译器拒绝将太过复杂(例如带有循环或递归)的函数inlining\n  所有对virtual函数 的调用，也都会使inlining落空，因为virtual意味着“等待，直到运行期才确定调用哪个函数”，而inline意味”执行前，先将调用动作替换为被调用函数的本体“。如果编译器不知道调用哪个函数 ，你就很难责备它们拒绝将函数本体inlining\n  大多数编译器提供一个诊断级别：如果它们无法将你要求的函数inline化，会给你一个警告信息\n  许多建置环境仅仅只能”在调试版本程序中禁止发生inlining“，毕竟你不能在一个并不存在的函数内设立断点\n  一开始先不要将任何函数声明为inline，最后再找出有效增进程序整体效率的20%代码，然后将它inline或竭尽所能地将它瘦身\n  将大多数inlining限制在小型、被频繁调用的函数身上\n  31.Minimize compilation dependencies between files #    编译器必须在编译期间知道对象的大小\n  Handle classes 和 interface classes解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性（compilation dependencies）\n  支持”编译依存性最小化“的一般构想是：相依于声明式，不要相依于定义式\n  程序库的头文件应该以”完全且仅有声明式“的形式存在\n  "},{"id":26,"href":"/docs/Linux-World/","title":"Linux World","section":"Introduction","content":"记录Linux系统中常常遇到的问题对应的解决方法\n  工具  Linux必备工具 Git Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   Raspberry  常用 apt源 # 修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）： 清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib 修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 使用代理 apt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt # https://github.com/tranter/raspberry-pi-qt-builds/releases cd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake https://blog.csdn.net/tianfour/article/details/76068656 youtube-dl # channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.   Ubuntu  目录共享配置 Samba配置 # samba配置后，仍然无法访问 # https://blog.csdn.net/Panda_YinLP/article/details/104687438 访问window共享目录 # sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 # https://linuxhint.com/install_tftp_server_ubuntu/ https://download.samba.org/pub/samba/ NFS挂载 # https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04 将文件系统目录导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07. 系统代理和证书 系统代理 # vi ~/.   "},{"id":27,"href":"/posts/zerotier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"ZeroTier内网穿透","section":"Blog","content":"ZeroTier内网穿透 #  安装方式1：脚本自动安装 #  sudo curl -s https://install.zerotier.com|sudo bash 在ubuntu下成功安装，在树莓派上可能失败\n安装方式2：源码安装 #  wget https://github.com/zerotier/ZeroTierOne/archive/refs/tags/1.8.4.tar.gz tar zxvf 1.8.4.tar.gz cd ZeroTierOne-1.8.4/ make -j make install 注册账号 #  申请ID,参考https://blog.csdn.net/kai3123919064/article/details/109662499\n运行 #  1、在每个设备端上运行服务端zerotier-one，并将每一个设备添加到相同的NetworkID组，这样同一下 NetworkID组下的所有成员就能相互穿透了\n先安装zerotier-one服务并运行，这样以后开机自动启动此服务\n#在源码目录下可以看到此文件 ~/Public/ZeroTierOne-1.8.4 $ cat debian/zerotier-one.service [Unit] Description=ZeroTier One After=network-online.target Wants=network-online.target  [Service] ExecStart=/usr/sbin/zerotier-one Restart=always KillMode=process  [Install] WantedBy=multi-user.target 注意检查上面的/usr/sbin/zerotier-one路径是否存在\n#将此文件 拷贝到/lib/systemd/system/目录下 $ cp debian/zerotier-one.service /lib/systemd/system/ #启动服务 $ systemctl start zerotier-one.service #查看服务状态 $ systemctl status zerotier-one.service ● zerotier-one.service - ZeroTier One  Loaded: loaded (/lib/systemd/system/zerotier-one.service; enabled; vendor preset: enabled)  Active: active (running) since Thu 2022-03-17 22:22:47 CST; 3 days ago  Main PID: 487 (zerotier-one)  Tasks: 5 (limit: 2059)  CGroup: /system.slice/zerotier-one.service  └─487 /usr/sbin/zerotier-one 2、在每个设备都添加到自己的局域网，每台设备都执行以下命令后，这样在相同your_network_id下的每个设备之间就组成局域网了，太简单了，但是还需要在下一步中的网页端上进行确认\nsudo zerotier-cli join your_network_id 3、在网页端中https://my.zerotier.com/network/your_network_id，启动刚刚添加的设备\n 4、在设备端可以看到，新增了一个网络接口和相应的路由表，并且IP地址显示为上图网页管理界面中的IP\n  5、此时网页管理界面中显示的两个成员就能相互访问了\nssh root@192.168.192.212 perfect!!!\n"},{"id":28,"href":"/posts/Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/","title":"搭建HUGO博客","section":"Blog","content":"搭建HUGO博客 #  安装hugo #  进入 release页面下载，选择下载 hugo_extended_0.97.0_Linux-64bit.deb带extended后缀的安装包\nsudo dpkg -i hugo_extended_0.97.0_Linux-64bit.deb 创建hugo工程 #  mkdir ~/Public/Book cd ~/Public/Book hugo new site ./ 下载主题 #  git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book cp -R themes/hugo-book/exampleSite/content . 运行Web服务 #  ubuntu:~/Public/Book$ hugo server --minify --theme hugo-book --bind=\u0026#34;0.0.0.0\u0026#34; -p 8888 Start building sites … hugo v0.97.0-c07f3626e7c8160943591f4d209977efa02c3dca+extended linux/amd64 BuildDate=2022-04-14T08:45:07Z VendorInfo=gohugoio WARN 2022/04/16 01:47:16 Expand shortcode is deprecated. Use \u0026#39;details\u0026#39; instead. WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/variables\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/functions\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/content/front-matter\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/overview/configuration/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/templates/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/doc/shortcodes/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39;   | EN | RU | ZH -------------------+----+----+-----  Pages | 57 | 7 | 7  Paginator pages | 0 | 0 | 0  Non-page files | 0 | 0 | 0  Static files | 78 | 78 | 78  Processed images | 0 | 0 | 0  Aliases | 12 | 2 | 2  Sitemaps | 2 | 1 | 1  Cleaned | 0 | 0 | 0  Built in 92 ms Watching for changes in ~/Public/Book/{archetypes,content,data,layouts,static,themes} Watching for config changes in ~/Public/Book/config.toml, ~/Public/Book/config/_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:8888/ (bind address 0.0.0.0) Press Ctrl+C to stop Hugo主题宽屏设置 #  修改文件themes/hugo-book/assets/_defaults.scss\n$container-max-width: 80rem !default; 修改为\n$container-max-width: 200rem !default; "},{"id":29,"href":"/docs/Linux-World/Raspberry/","title":"Raspberry","section":"Linux World","content":"  常用  apt源 # 修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）： 清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib 修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 使用代理 apt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt # https://github.com/tranter/raspberry-pi-qt-builds/releases cd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake https://blog.csdn.net/tianfour/article/details/76068656 youtube-dl # channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.   "},{"id":30,"href":"/docs/Linux-World/Ubuntu/","title":"Ubuntu","section":"Linux World","content":"  目录共享配置  Samba配置 # samba配置后，仍然无法访问 # https://blog.csdn.net/Panda_YinLP/article/details/104687438 访问window共享目录 # sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 # https://linuxhint.com/install_tftp_server_ubuntu/ https://download.samba.org/pub/samba/ NFS挂载 # https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04 将文件系统目录导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.   系统代理和证书  系统代理 # vi ~/.profile export http_proxy=\u0026#39;http://myproxy.example.com:1080/\u0026#39; export https_proxy=\u0026#39;https://myproxy.example.com:1080/\u0026#39; export ftp_proxy=\u0026#39;http://myproxy.example.com:1080/\u0026#39; export ALL_PROXY=\u0026#39;socks://myproxy.example.com:1080/\u0026#39; export all_proxy=\u0026#39;socks://myproxy.example.com:1080/\u0026#39; export no_proxy=\u0026#39;example.com\u0026#39; $ sudo apt-get install socat $ wget http://git.yoctoproject.org/cgit/cgit.cgi/poky/plain/scripts/oe-git-proxy $ cp oe-git-proxy ~/bin $ chmod +x ~/bin/oe-git-proxy export GIT_PROXY_COMMAND=\u0026#34;oe-git-proxy\u0026#34; export NO_PROXY=$no_proxy vi ~/.wgetrc https_proxy = http://socks.example.com:1080 http_proxy = http://socks.example.com:1080 ftp_proxy = http://socks.example.com:1080 no_proxy = example.com:1080;127.0.0.1 use_proxy = on https://wiki.yoctoproject.org/wiki/Working_Behind_a_Network_Proxy 透明代理 # https://blog.a1253247.info/2020/01/shadowsocks.html 代理转换 # /etc/polipo/config /etc/polipo/config systemctl status polipo www.   其它  ubuntu扩容 # https://blog.csdn.net/qq_34160841/article/details/113058756 linux命令 # https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html 安装armhf ubuntu # https://wiki.ubuntu.com/ARM/RaspberryPi   "},{"id":31,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/","title":"Git","section":"工具","content":"  Git常用配置  Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   git基本使用  版本说明 # git基本使用 日期 版本 修改内容 2021/02/19 V0.3 创建 Git对比SVN # 1.小步提交，互不干扰 # 并行开发过程中各开发人员可以随时多次commit代码且互不影响，最后在merage到主分支，并且能记录所有成员的所有commint记录。SVN只能大量的一次性提交到中心库。 2.打断开发：在开发新功能过程中，突然需要你去修复一个Bug # 使用Git，你可以直接stash/commit当前改动，然后switch到主分支去修复Bug，之后在pop/switch回你原来的分支继续开发。 3.Git分支切换-指针移动，SVN分支切换-Copy项目 # Git支持本地无限Branches，当我们个体在本地创建多个branches用于不同目的的时候（修改，新增，探索），分支轻量化，秒创分支，创建分支满足客户定制化需求 4.Git Tag-指针标示，SVN Tag-Copy项目 # Git管理的项目要比SVN小得多。Git初次拉取代码的速度也远小于SVN。 5.两级提交 # 本地创建分支开发，本地提交，需要合并时再提交到远程 6.日志查看 # Git本地包含了完整的日志，闪电的速度查看（并且无需网络)。SVN需要从服务拉取。 7.安全 # Git是分布式版本控制系统，每个用户都相当于一份备份， 管理员无需为数据备份而担心。SVN作为集中式版本控制系统，存在单点故障的风险。备份版本库的任务非常繁重。 linus在google的演讲感悟 链接：https://www.zhihu.com/question/19601997/answer/95363587 自洽的、最少依赖的个人工作得到支持。1000多人的Linux开发团队是分布在世界各地的，使用git也就不必依赖中心服务器、不必需要很少的网络。就在自己的电脑上就有完整的仓库，可以做任何版本管理，除了分享代码。SVN显然是不合适的，因为单点故障大家甚至无法提交，更加无法开分支，这是无法忍受的。 剔除害群之马很简单。如果Linus经过观察，发现有些程序员特别容易出漏子，那么封杀的办法就是不必拉取即可。实际上Linus就是这样干过。如果是SVN，就变成了撤销惹麻烦的开发者的账号或者限定他的访问范围，并且从仓库中移除麻烦的代码提交。就是说，封杀的方法在git而言，是不做某事即可，SVN是做一系列事情才可以。一正一反，大家可以体会一下。Linus喜欢前者，并且得心应手。这样的工作流程就避开了很多“政治”问题，让他的集成代码过程变得主动。 可以使用信任网络。Linux太大了，不可能完全看完补丁代码的方式来识别信任，这个Linus曾经干过，最后的结果当然是放弃。如果发现有些程序员特别优秀，他只要选择拉取他们的实现。这些程序员也只是拉取他们信任的程序员的实现。这样的信任网络是可以层次化的，因此对应于1000多人的开发者来说，这样做确实可以通过分层的信任网络达成大规模的团队协作。如果是SVN，我不知道如何做可以更好 轻量的分支开销鼓励大量被使用。对于这样的团队，为了敏捷的迭代，如果有想法就分支（这样的开发隔离想法是很有价值的），那么在svn上分支是海量的并且全局的大家互相影响，因此是要命的。而对于Git总数当然是海量，但是每个人的分支都在自己的仓库内，不会影响到他人。且分支无需连接服务器，因此是飞速的。 Git工作流 # http://www.   git高级使用  版本说明 # git基本使用 日期 版本 修改内容 2021/02/19 V0.3 创建 个人使用总结 # Merge节点 # Git有两种合并：一种是\u0026quot;直进式合并\u0026quot;（fast forward），不生成单独的合并节点；另一种是\u0026quot;非直进式合并\u0026quot;（none fast-forword），会生成单独节点。 前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用--no-ff参数）。只要发生合并，就要有一个单独的合并节点。 push策略 # 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config --global push.default matching # 或者 $ git config --global push.default simple 解决merge 和 rebase 合并冲突 # #merge 和 rebase 对于 ours 和 theirs 的定义是完全相反的。在 merge 时，ours 指代的是当前分支，theirs 代表需要被合并的分支。而在 rebase 过程中，ours 指向了修改参考分支，theirs 却是当前分支 git checkout --ours src/MyFile.   "},{"id":32,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/","title":"Vim","section":"工具","content":"  配置  vim退出时不清除屏幕内容 # 1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示： 2、然后执行source /etc/profile即可 vim设置colorSchema # mkdir -p ~/.vim/colors https://github.com/tomasr/molokai 设置蓝色 # eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34; alias ls=\u0026#39;ls --color=auto\u0026#39; #alias dir=\u0026#39;dir --color=auto\u0026#39; #alias vdir=\u0026#39;vdir --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.   "},{"id":33,"href":"/docs/Linux-World/Raspberry/%E5%B8%B8%E7%94%A8/","title":"常用","section":"Raspberry","content":"apt源 #  修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）：\n清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi\n阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib\n修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源：\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui\n使用代理\napt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt #   https://github.com/tranter/raspberry-pi-qt-builds/releases\ncd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake  https://blog.csdn.net/tianfour/article/details/76068656\nyoutube-dl #  channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.youtube.com/watch?v=Tu-vU4zFre0\u0026amp;list=PLoZQ0sz6CBHGG1qoq-tISRs9tKCLwCyM\rhttps://www.youtube.com/user/numberblocks/playlists\rhttps://www.youtube.com/watch?v=2mQ0JtlddLI\u0026amp;list=PL9swKX1PviEor1JJ9oiJwidaT-q69tYW2\ryoutube-dl --yes-playlist -f best -ciw -o \u0026#34;${outdir}/%(uploader)s/playlists/%(playlist)s/videos/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; -v $channel_url\r-c, --continue Force resume of partially downloaded files. By default, youtube-dl will resume downloads if possible.\r-i, --ignore-errors Continue on download errors, for example to skip unavailable videos in a playlist\r-w, --no-overwrites Do not overwrite files #!/bin/bash url=\u0026#34;https://www.youtube.com/playlist?list=\u0026#34;$1 channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34; proxy=\u0026#34;--proxy socks5://localhost:1081\u0026#34; #args=\u0026#34;--no-check-certificate --restrict-filenames --no-warnings --ignore-errors\u0026#34; args=\u0026#34;--no-check-certificate --no-warnings --ignore-errors --continue --no-overwrites \u0026#34; get_info=\u0026#34; --get-id --get-filename --get-title\u0026#34; get_sub=\u0026#34;--write-auto-sub --skip-download\u0026#34;  list_dir=$2 name=${list_dir##*/} echo name list_path=$2\u0026#34;/$name.txt\u0026#34; if [ ! -d $list_dir ]; then  mkdir $list_dir fi echo $list_dir echo $list_path cd $list_dir youtube-dl $url $args $proxy -o \u0026#34;%(uploader)s/playlists/%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; #youtube-dl $url $args $proxy -o \u0026#34;${outdir}/%(uploader)s/playlists/%(playlist)s/videos/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; #youtube-dl $url $args $proxy -o \u0026#34;%(playlist_index)s-%(title)s.%(ext)s\u0026#34; 开启wifi #  pi@raspberrypi:~ $ sudo rfkill list all 0: phy0: Wireless LAN \tSoft blocked: no \tHard blocked: no 1: hci0: Bluetooth \tSoft blocked: yes \tHard blocked: no pi@raspberrypi:~ $ sudo rfkill unblock 0 升级固件 #  #安装CA证书 sudo apt-get install ca-certificates  #同步时间 sudo apt-get install ntpdate sudo ntpdate -u ntp.ubuntu.com   mkdir /root/.rpi-firmware cd /root/.rpi-firmware curl -L https://github.com/Hexxeh/rpi-firmware/archive/master.tar.gz -o master.tar.gz tar -xvzf master.tar.gz rm master.tar.gz  # 执行本地更新 UPDATE_SELF=0 SKIP_DOWNLOAD=1 rpi-update  # 重启 reboot How to get back to safety #  If you have done an rpi-update and things are not working as you wish, if your Raspberry Pi is still bootable you can return to the stable release using:\nsudo apt-get update\rsudo apt install --reinstall libraspberrypi0 libraspberrypi-{bin,dev,doc} raspberrypi-bootloader raspberrypi-kernel  https://www.raspberrypi.org/documentation/\n https://wiki.debian.org/DontBreakDebian#Don.27t_make_a_FrankenDebian\n安装armhf ubuntu #   https://wiki.ubuntu.com/ARM/RaspberryPi\nraspberry 启动流程 #   https://www.lions-wing.net/maker/raspberry-1/boot.html\n传感器 #  MPU6050 #   https://openest.io/en/2020/01/21/mpu6050-accelerometer-on-raspberry-pi/\n https://tutorials-raspberrypi.com/measuring-rotation-and-acceleration-raspberry-pi/\n https://howtomechatronics.com/tutorials/arduino/arduino-and-mpu6050-accelerometer-and-gyroscope-tutorial/\nhttps://www.stupid-projects.com/controlling-a-3d-object-in-unity3d-with-teensy-and-mpu-6050/ #  https://bitbucket.org/dimtass/teensy-hid-with-unity3d/src/master/ #   https://github.com/jrowberg/i2cdevlib/blob/master/RaspberryPi_bcm2835/MPU6050/examples/IMU_zero.cpp\n http://brettbeauregard.com/blog/2011/04/improving-the-beginner%e2%80%99s-pid-sample-time/\n#       字母名称 国际音标     俯仰角θ（pitch） Θ theta /\u0026lsquo;θi:tə/   偏航角ψ（yaw） Ψ psi /psaɪ/   滚转角Φ（roll） φ phi /faɪ/     ESP8266 #   https://blog.csdn.net/chentuo2000/article/details/105296166/?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1\u0026spm=1001.2101.3001.4242\n"},{"id":34,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/%E9%85%8D%E7%BD%AE/","title":"配置","section":"Vim","content":"vim退出时不清除屏幕内容 #  1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示：\n 2、然后执行source /etc/profile即可\nvim设置colorSchema #  mkdir -p ~/.vim/colors  https://github.com/tomasr/molokai\n设置蓝色 #  eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS  rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then  test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34;  alias ls=\u0026#39;ls --color=auto\u0026#39;  #alias dir=\u0026#39;dir --color=auto\u0026#39;  #alias vdir=\u0026#39;vdir --color=auto\u0026#39;   alias grep=\u0026#39;grep --color=auto\u0026#39;  alias fgrep=\u0026#39;fgrep --color=auto\u0026#39;  alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi  LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:* .lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31 :*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm =01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mn g=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=0 1;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:* .mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\u0026#39;; export LS_COLORS "},{"id":35,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/","title":"常用 Linux命令","section":"工具","content":"find ./ -type d -name \u0026#34;Backup\u0026#34; -exec rm -rf {} \\;  sed -i \u0026#34;s/\u0026lt;cups\\/cups.h\u0026gt;/\\\u0026#34;cups\\/cups.h\\\u0026#34;/g\u0026#34; `grep \u0026#34;cups/cups.h\u0026#34; -rl .`  find . -type f -size +100M -print0 | xargs -0 du -h | sort -nr  cat *.txt | sort | uniq \u0026gt; test  #导出svn版本差异 for i in $(svn diff --summarize -r 248:276 svn://192.168.10.200/rootfs/ | awk \u0026#39;{ print $2 }\u0026#39;); do p=$(echo $i | sed -e \u0026#39;s{svn://192.168.10.200/rootfs/{{\u0026#39;); mkdir -p $(dirname $p); svn export $i $p; done  #获取awk ./a.out |awk \u0026#39;BEGIN{FS=\u0026#34;[()]\u0026#34;} NR==5{print $2}\u0026#39;  FS指定分隔符  NR指定读取第几行输出  #查找文件权限  find -type d -not -perm 775 -o -type f -not -perm 664    sed -n \u0026#39;/192.xxx/\u0026#39;p xxxx |awk \u0026#39;BEGIN{FS=\u0026#34;[ ]\u0026#34;} {print $5 }\u0026#39; |sort |uniq |wc -l "},{"id":36,"href":"/docs/Qt%E6%80%BB%E7%BB%93/%E6%95%B4%E7%90%86Qt-snippet/","title":"整理 Qt Snippet","section":"Qt总结","content":"延时异步加载 #  用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。\n//异步执行load函数\rQMetaObject::invokeMethod(this, \u0026#34;load\u0026#34;, Qt::QueuedConnection);\r//延时10毫秒执行load函数\rQTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 #  //拿到控件元对象 const QMetaObject *metaObject = widget-\u0026gt;metaObject();  //所有属性的数量 int propertyCount = metaObject-\u0026gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-\u0026gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i \u0026lt; propertyCount; ++i) {  QMetaProperty metaProperty = metaObject-\u0026gt;property(i);  const char *name = metaProperty.name();  const char *type = metaProperty.typeName();  QVariant value = widget-\u0026gt;property(name);  qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; }  //所有方法的数量 int methodCount = metaObject-\u0026gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-\u0026gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i \u0026lt; methodCount; ++i) {  QMetaMethod metaMethod = metaObject-\u0026gt;method(i);  const char *name = metaMethod.name();  const char *type = metaMethod.typeName();  qDebug() \u0026lt;\u0026lt; name \u0026lt;\u0026lt; type; } inherits判断是否属于某种类 #  QTimer *timer = new QTimer; // QTimer inherits QObject\rtimer-\u0026gt;inherits(\u0026#34;QTimer\u0026#34;); // returns true\rtimer-\u0026gt;inherits(\u0026#34;QObject\u0026#34;); // returns true\rtimer-\u0026gt;inherits(\u0026#34;QAbstractButton\u0026#34;); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-\u0026gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-\u0026gt;property(\u0026ldquo;name\u0026rdquo;)取出对应的弱属性的值。\nsqlite数据库 #   如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。  QSqlDatabase db = QSqlDatabase::addDatabase(\u0026#34;QSQLITE\u0026#34;);\rdb.setDatabaseName(\u0026#34;:memory:\u0026#34;); 清空数据表并重置自增ID\ntruncate table table_name 废弃或者过时函数 #  从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0\n编译环境和运行环境 #  x86/x64都编译环境和运行环境是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。\n   名称 说明     x86 32/64位系统上编译在32/64位系统上运行   x86_amd64 32/64位系统上编译在64位系统上运行   x86_arm 32/64位系统上编译在arm系统上运行   amd64 64位系统上编译在64位系统上运行   amd64_x86 64位系统上编译在32/64位系统上运行   amd64_arm 64位系统上编译在arm系统上运行    窗口模态显示 #  很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。\nQDialog dialog;\rdialog.setWindowModality(Qt::WindowModal); 无边框窗体输入焦点 #  在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。\n//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点 setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);  //需要在show以后主动激活窗体 w-\u0026gt;show(); w-\u0026gt;activateWindow(); QMetaObject::invokeMethod #  巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, \u0026ldquo;fun\u0026rdquo;, Qt::QueuedConnection); 这种方式来就可以。\n invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。 invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！ 测试下来发现只能执行signals或者slots标识的方法。 默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。 必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。 如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字  //头文件声明信号和槽函数 signals:  void sig_test(int type,double value); private slots:  void slot_test(int type, double value); private:  Q_INVOKABLE void fun_test(int type, double value);  //构造函数关联信号槽 connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));  //单击按钮触发信号和槽,这里是同时举例信号槽都可以 void MainWindow::on_pushButton_clicked() {  QMetaObject::invokeMethod(this, \u0026#34;sig_test\u0026#34;, Q_ARG(int, 66), Q_ARG(double, 66.66));  QMetaObject::invokeMethod(this, \u0026#34;slot_test\u0026#34;, Q_ARG(int, 88), Q_ARG(double, 88.88));  QMetaObject::invokeMethod(this, \u0026#34;fun_test\u0026#34;, Q_ARG(int, 99), Q_ARG(double, 99.99)); }  //会打印 66 66.66、88 88.88 void MainWindow::slot_test(int type, double value) {  qDebug() \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; }  //会打印 99.99 void MainWindow::fun_test(int type, double value) {  qDebug() \u0026lt;\u0026lt; type \u0026lt;\u0026lt; value; } Qt的定时器精度 #  Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer);\n Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。 Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。 Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。 精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。  QRegExpValidator 正则表达 #   QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。   限制输入只能输入IP地址。 限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。  //正在表达式限制输入 QString str = \u0026#34;\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b\u0026#34;; ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QRegExpValidator(QRegExp(str))); //用于占位 ui-\u0026gt;lineEdit-\u0026gt;setInputMask(\u0026#34;000.000.000.000\u0026#34;);  #if 0//下面代码设置浮点数范围限制失败 ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QDoubleValidator(20, 50, 1)); #else //下面代码设置浮点数范围限制成功 QDoubleValidator *validator = new QDoubleValidator(20, 50, 1); validator-\u0026gt;setNotation(QDoubleValidator::StandardNotation); ui-\u0026gt;lineEdit-\u0026gt;setValidator(validator); #endif //下面代码设置整数范围限制成功 ui-\u0026gt;lineEdit-\u0026gt;setValidator(new QIntValidator(10, 120));  //其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋 //需要来个万能的牛逼的 QRegExpValidator  //限制浮点数输入范围为[-180,180] QRegExp regexp(\u0026#34;^-?(180|1?[0-7]?\\\\d(\\\\.\\\\d+)?)$\u0026#34;); //限制浮点数输入范围为[-90,90]并限定为小数位后4位 QRegExp regexp(\u0026#34;^-?(90|[1-8]?\\\\d(\\\\.\\\\d{1,4})?)$\u0026#34;); QRegExpValidator *validator = new QRegExpValidator(regexp, this); ui-\u0026gt;lineEdit-\u0026gt;setValidator(validator); Qt重载qDebug输出自定义的信息 #  struct FunctionInfo {  QString function;  QString name;  QString groupEnabled;  QString action;  QString group;   friend QDebug operator \u0026lt;\u0026lt; (QDebug debug, const FunctionInfo \u0026amp;functionInfo) {  QString info = QString(\u0026#34;功能: %1 名称: %2 启用: %3 方法: %4 分组: %5\u0026#34;)  .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)  .arg(functionInfo.action).arg(functionInfo.group);  debug \u0026lt;\u0026lt; info;  return debug;  } }; findChild使用 #  Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。\n//打印子类类名集合 void printObjectChild(const QObject *obj, int spaceCount) {  qDebug() \u0026lt;\u0026lt; QString(\u0026#34;%1%2 : %3\u0026#34;)  .arg(\u0026#34;\u0026#34;, spaceCount)  .arg(obj-\u0026gt;metaObject()-\u0026gt;className())  .arg(obj-\u0026gt;objectName());   QObjectList childs = obj-\u0026gt;children();  foreach (QObject *child, childs) {  printObjectChild(child, spaceCount + 2);  } }  //拿到对话框进行设置和美化 QFileDialog *fileDialog = new QFileDialog(this); fileDialog-\u0026gt;setOption(QFileDialog::DontUseNativeDialog, true); QLabel *lookinLabel = fileDialog-\u0026gt;findChild\u0026lt;QLabel*\u0026gt;(\u0026#34;lookInLabel\u0026#34;); lookinLabel-\u0026gt;setText(QString::fromLocal8Bit(\u0026#34;文件目录：\u0026#34;)); lookinLabel-\u0026gt;setStyleSheet(\u0026#34;color:red;\u0026#34;);  //设置日期框默认值为空 QLineEdit *edit = ui-\u0026gt;dateEdit-\u0026gt;findChild\u0026lt;QLineEdit *\u0026gt;(\u0026#34;qt_spinbox_lineedit\u0026#34;); if (!edit-\u0026gt;text().isEmpty()) {  edit-\u0026gt;clear(); } 巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。\n//查找指定类名objectName的控件 QList\u0026lt;QWidget *\u0026gt; widgets = fatherWidget.findChildren\u0026lt;QWidget *\u0026gt;(\u0026#34;widgetname\u0026#34;); //查找所有QPushButton QList\u0026lt;QPushButton *\u0026gt; allPButtons = fatherWidget.findChildren\u0026lt;QPushButton *\u0026gt;(); //查找一级子控件,不然会一直遍历所有子控件 QList\u0026lt;QPushButton *\u0026gt; childButtons = fatherWidget.findChildren\u0026lt;QPushButton *\u0026gt;(QString(), Qt::FindDirectChildrenOnly); 动态加载资源文件 #  当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。\n//Qt中使用二进制资源文件方法如下 //将qrc编译为二进制文件rcc，在控制台执行下列命令 rcc -binary main.qrc -o main.rcc //在应用程序中注册资源，一般在main函数启动后就注册 QResource::registerResource(qApp-\u0026gt;applicationDirPath() + \u0026#34;/main.rcc\u0026#34;); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big\nblockSignals阻塞信号 #  //方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。 disconnect(ui-\u0026gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int))); for (int i = 0; i \u0026lt;= 100; i++) {  ui-\u0026gt;cbox-\u0026gt;addItem(QString::number(i)); } connect(ui-\u0026gt;cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));  //方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。 //如果需要指定某个信号进行断开那就只能用 disconnect 来处理。 ui-\u0026gt;cbox-\u0026gt;blockSignals(true); for (int i = 0; i \u0026lt;= 100; i++) {  ui-\u0026gt;cbox-\u0026gt;addItem(QString::number(i)); } ui-\u0026gt;cbox-\u0026gt;blockSignals(false); QCustomPlot使用 #  //对调XY轴，在最前面设置 QCPAxis *yAxis = customPlot-\u0026gt;yAxis; QCPAxis *xAxis = customPlot-\u0026gt;xAxis; customPlot-\u0026gt;xAxis = yAxis; customPlot-\u0026gt;yAxis = xAxis;  //移除图例 customPlot-\u0026gt;legend-\u0026gt;removeItem(1);  //合并两个曲线画布形成封闭区域 customPlot-\u0026gt;graph(0)-\u0026gt;setChannelFillGraph(customPlot-\u0026gt;graph(1));  //关闭抗锯齿以及设置拖动的时候不启用抗锯齿 customPlot-\u0026gt;graph()-\u0026gt;setAntialiased(false); customPlot-\u0026gt;setNoAntialiasingOnDrag(true);  //多种设置数据的方法 customPlot-\u0026gt;graph(0)-\u0026gt;setData(); customPlot-\u0026gt;graph(0)-\u0026gt;data()-\u0026gt;set();  //设置不同的线条样式、数据样式 customPlot-\u0026gt;graph()-\u0026gt;setLineStyle(QCPGraph::lsLine); customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle::ssDot); customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(shapes.at(i), 10));  //还可以设置为图片或者自定义形状 customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(QPixmap(\u0026#34;./sun.png\u0026#34;))); QPainterPath customScatterPath; for (int i = 0; i \u0026lt; 3; ++i) {  customScatterPath.cubicTo(qCos(2 * M_PI * i / 3.0) * 9, qSin(2 * M_PI * i / 3.0) * 9, qCos(2 * M_PI * (i + 0.9) / 3.0) * 9, qSin(2 * M_PI * (i + 0.9) / 3.0) * 9, 0, 0); } customPlot-\u0026gt;graph()-\u0026gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, 0), QColor(40, 70, 255, 50), 10));  //更换坐标轴的箭头样式 customPlot-\u0026gt;xAxis-\u0026gt;setUpperEnding(QCPLineEnding::esSpikeArrow); customPlot-\u0026gt;yAxis-\u0026gt;setUpperEnding(QCPLineEnding::esSpikeArrow);  //设置背景图片 customPlot-\u0026gt;axisRect()-\u0026gt;setBackground(QPixmap(\u0026#34;./solarpanels.jpg\u0026#34;)); //画布也可以设置背景图片 customPlot-\u0026gt;graph(0)-\u0026gt;setBrush(QBrush(QPixmap(\u0026#34;./balboa.jpg\u0026#34;))); //整体可以设置填充颜色或者图片 customPlot-\u0026gt;setBackground(QBrush(gradient)); //设置零点线条颜色 customPlot-\u0026gt;xAxis-\u0026gt;grid()-\u0026gt;setZeroLinePen(Qt::NoPen); //控制是否鼠标滚轮缩放拖动等交互形式 customPlot-\u0026gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);  //柱状分组图 QCPBarsGroup *group = new QCPBarsGroup(customPlot); QList\u0026lt;QCPBars*\u0026gt; bars; bars \u0026lt;\u0026lt; fossil \u0026lt;\u0026lt; nuclear \u0026lt;\u0026lt; regen; foreach (QCPBars *bar, bars) {  //设置柱状图的宽度大小  bar-\u0026gt;setWidth(bar-\u0026gt;width() / bars.size());  group-\u0026gt;append(bar); } //设置分组之间的间隔 group-\u0026gt;setSpacing(2); 网络请求超时时间 #  在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。\n//局部的事件循环,不卡主界面 QEventLoop eventLoop;  //设置超时 5.15开始自带了超时时间函数 默认30秒 #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,15,0)) manager-\u0026gt;setTransferTimeout(timeout); #else QTimer timer; connect(\u0026amp;timer, SIGNAL(timeout()), \u0026amp;eventLoop, SLOT(quit())); timer.setSingleShot(true); timer.start(timeout); #endif  QNetworkReply *reply = manager-\u0026gt;get(QNetworkRequest(QUrl(url))); connect(reply, SIGNAL(finished()), \u0026amp;eventLoop, SLOT(quit())); eventLoop.exec();  if (reply-\u0026gt;bytesAvailable() \u0026gt; 0 \u0026amp;\u0026amp; reply-\u0026gt;error() == QNetworkReply::NoError) {  //读取所有数据保存成文件  QByteArray data = reply-\u0026gt;readAll();  QFile file(dirName + fileName);  if (file.open(QFile::WriteOnly | QFile::Truncate)) {  file.write(data);  file.close();  } } Qt获取当前所用的Qt版本、编译器、位数等信息。 #  //详细的Qt版本+编译器+位数 QString compilerString = \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;; {  compilerString = QLatin1String(\u0026#34;GCC \u0026#34;) + QLatin1String(__VERSION__); }  //拓展知识 查看 QSysInfo 类下面有很多好东西 // qVersion() = QT_VERSION_STR QString version = QString(\u0026#34;%1 %2 %3\u0026#34;).arg(qVersion()).arg(compilerString).arg(QString::number(QSysInfo::WordSize)); Lamda形式信号槽 #  MainWindow::MainWindow(QWidget *parent)  : QMainWindow(parent)  , ui(new Ui::MainWindow) {  ui-\u0026gt;setupUi(this);  //早期写法,通用Qt所有版本,只支持定义了slots关键字的函数  //connect(ui-\u0026gt;pushButton, SIGNAL(clicked()), this, SLOT(test_fun()));  connect(ui-\u0026gt;pushButton, SIGNAL(clicked()), this, SLOT(test_slot()));   //新写法,支持Qt5及后期所有版本,支持所有函数,无需定义slots关键字也行  //采用这种写法，如果编译的时候信号或槽不存在是无法编译通过的，相当于编译时检查，不容易出错；  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, this, \u0026amp;MainWindow::test_fun);  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, this, \u0026amp;MainWindow::test_slot);   //按钮单击不带参数  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, [] {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34;;  });   //按钮单击带参数  connect(ui-\u0026gt;pushButton, \u0026amp;QPushButton::clicked, [] (bool isCheck) {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34; \u0026lt;\u0026lt; isCheck;  });   //自定义信号带参数  connect(this, \u0026amp;MainWindow::sig_test, [] (int i, int j) {  qDebug() \u0026lt;\u0026lt; \u0026#34;hello lambda\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; j;  });   emit sig_test(5, 8); } Qt延时方法 #  void QUIHelperCore::sleep(int msec) {  if (msec \u0026lt;= 0) {  return;  }  #if 1  //非阻塞方式延时,现在很多人推荐的方法  QEventLoop loop;  QTimer::singleShot(msec, \u0026amp;loop, SLOT(quit()));  loop.exec(); #else #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  //阻塞方式延时,如果在主线程会卡住主界面  QThread::msleep(msec); #else  //非阻塞方式延时,不会卡住主界面,据说可能有问题  QTime endTime = QTime::currentTime().addMSecs(msec);  while (QTime::currentTime() \u0026lt; endTime) {  QCoreApplication::processEvents(QEventLoop::AllEvents, 100);  } #endif #endif } 获取当前屏幕索引以及尺寸 #  //获取当前屏幕索引 int QUIHelper::getScreenIndex() {  //需要对多个屏幕进行处理  int screenIndex = 0; #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  int screenCount = qApp-\u0026gt;screens().count(); #else  int screenCount = qApp-\u0026gt;desktop()-\u0026gt;screenCount(); #endif   if (screenCount \u0026gt; 1) {  //找到当前鼠标所在屏幕  QPoint pos = QCursor::pos();  for (int i = 0; i \u0026lt; screenCount; ++i) { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  if (qApp-\u0026gt;screens().at(i)-\u0026gt;geometry().contains(pos)) { #else  if (qApp-\u0026gt;desktop()-\u0026gt;screenGeometry(i).contains(pos)) { #endif  screenIndex = i;  break;  }  }  }  return screenIndex; }  //获取当前屏幕尺寸区域 QRect QUIHelper::getScreenRect(bool available) {  QRect rect;  int screenIndex = QUIHelper::getScreenIndex();  if (available) { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  rect = qApp-\u0026gt;screens().at(screenIndex)-\u0026gt;availableGeometry(); #else  rect = qApp-\u0026gt;desktop()-\u0026gt;availableGeometry(screenIndex); #endif  } else { #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(5,0,0))  rect = qApp-\u0026gt;screens().at(screenIndex)-\u0026gt;geometry(); #else  rect = qApp-\u0026gt;desktop()-\u0026gt;screenGeometry(screenIndex); #endif  }  return rect; } 文本进行分散对齐显示 #  有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。\nQString text = \u0026#34;测试分散对齐内容\u0026#34;; //计算当前文本在当前字体下占用的宽度 QFont font = ui-\u0026gt;label-\u0026gt;font(); int textWidth = ui-\u0026gt;label-\u0026gt;fontMetrics().width(text); //显示文本的区域宽度=标签的宽度-两边的边距 int width = ui-\u0026gt;label-\u0026gt;width() - 12; //需要-1相当于中间有几个间隔 int count = text.count() - 1; //计算每个间距多少 qreal space = qreal(width - textWidth) / count; //设置固定间距 font.setLetterSpacing(QFont::AbsoluteSpacing, space); ui-\u0026gt;label-\u0026gt;setFont(font); ui-\u0026gt;label-\u0026gt;setText(text); override关键字 #  #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(6,0,0))  void enterEvent(QEnterEvent *); #else  void enterEvent(QEvent *); #endif  //后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。 //这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。  //下面是父类函数 virtual void enterEvent(QEvent *event); //子类建议加上override void enterEvent(QEvent *event) override; 常见类使用 #  QTableWidget #  关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。\n//每次调用 clearContents 都会自动清理之前的item ui-\u0026gt;tableWidget-\u0026gt;clearContents(); for (int i = 0; i \u0026lt; count; ++i) {  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 0, new QTableWidgetItem(\u0026#34;aaa\u0026#34;));  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 1, new QTableWidgetItem(\u0026#34;bbb\u0026#34;));  ui-\u0026gt;tableWidget-\u0026gt;setCellWidget(i, 2, new QPushButton(\u0026#34;ccc\u0026#34;)); } QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充，\n//方法1：字符串空格填充 ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;测 试\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;人员管理\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;系统设置\u0026#34;);  //方法2：识别尺寸改变事件自动设置最小宽度 void MainWindow::resizeEvent(QResizeEvent *e) {  int count = ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;count();  int width = this-\u0026gt;width() - 30;  QString qss = QString(\u0026#34;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(width / count);  this-\u0026gt;setStyleSheet(qss); }  //方法3：设置全局样式，不同选项卡个数的设置不同的宽度 QStringList list; list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;2\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(100); list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;3\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(70); qApp-\u0026gt;setStyleSheet(list.join(\u0026#34;\u0026#34;)); //设置了tabCount弱属性自动去找对应的宽度设置 ui-\u0026gt;tabWidget-\u0026gt;setProperty(\u0026#34;tabCount\u0026#34;, 2); ui-\u0026gt;tabWidget-\u0026gt;setProperty(\u0026#34;tabCount\u0026#34;, 3);  //方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置 //Qt4的tabBar()是propected的，所以建议还是通过样式表设置 ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setDocumentMode(true); ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setExpanding(true); //样式表一步到位不用每个都单独设置 QString(\u0026#34;QTabBar{qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;}\u0026#34;); //在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。 //5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。 QTableView #  关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列。\nvoid frmSimple::initForm() {  //实例化数据模型  model = new QStandardItemModel(this);   //设置行数列数  row = 100;  column = 10;  //设置列名列宽  for (int i = 0; i \u0026lt; column; ++i) {  columnNames \u0026lt;\u0026lt; QString(\u0026#34;列%1\u0026#34;).arg(i + 1);  columnWidths \u0026lt;\u0026lt; 60;  } }  void frmSimple::on_btnLoad1_clicked() {  //先设置数据模型,否则 setColumnWidth 不起作用  ui-\u0026gt;tableView-\u0026gt;setModel(model);   //设置列数及列标题和列宽  model-\u0026gt;setColumnCount(column);  //简便方法设置列标题集合  model-\u0026gt;setHorizontalHeaderLabels(columnNames);  for (int i = 0; i \u0026lt; column; ++i) {  ui-\u0026gt;tableView-\u0026gt;setColumnWidth(i, columnWidths.at(i));  }   //循环添加行数据  QDateTime now = QDateTime::currentDateTime();  model-\u0026gt;setRowCount(row);  for (int i = 0; i \u0026lt; row; ++i) {  for (int j = 0; j \u0026lt; column; ++j) {  QStandardItem *item = new QStandardItem;  //最后一列显示时间区别开来  if (j == column - 1) {  item-\u0026gt;setText(now.addSecs(i).toString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;));  } else {  item-\u0026gt;setText(QString(\u0026#34;%1_%2\u0026#34;).arg(i + 1).arg(j + 1));  }  model-\u0026gt;setItem(i, j, item);  }  } }  void frmSimple::on_btnLoad2_clicked() {  //设置列标题和列数及列宽  ui-\u0026gt;tableWidget-\u0026gt;setColumnCount(column);  //简便方法设置列标题集合  ui-\u0026gt;tableWidget-\u0026gt;setHorizontalHeaderLabels(columnNames);  for (int i = 0; i \u0026lt; column; ++i) {  ui-\u0026gt;tableWidget-\u0026gt;setColumnWidth(i, columnWidths.at(i));  }   //添加数据  QDateTime now = QDateTime::currentDateTime();  ui-\u0026gt;tableWidget-\u0026gt;setRowCount(row);  for (int i = 0; i \u0026lt; row; ++i) {  for (int j = 0; j \u0026lt; column; ++j) {  QTableWidgetItem *item = new QTableWidgetItem;  //最后一列显示时间区别开来  if (j == column - 1) {  item-\u0026gt;setText(now.addSecs(i).toString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;));  } else {  item-\u0026gt;setText(QString(\u0026#34;%1_%2\u0026#34;).arg(i + 1).arg(j + 1));  }  ui-\u0026gt;tableWidget-\u0026gt;setItem(i, j, item);  }  } } Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。\nvoid QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit) {  //奇数偶数行颜色交替  tableView-\u0026gt;setAlternatingRowColors(false);  //垂直表头是否可见  tableView-\u0026gt;verticalHeader()-\u0026gt;setVisible(headVisible);  //选中一行表头是否加粗  tableView-\u0026gt;horizontalHeader()-\u0026gt;setHighlightSections(false);  //最后一行拉伸填充  tableView-\u0026gt;horizontalHeader()-\u0026gt;setStretchLastSection(true);  //行标题最小宽度尺寸  tableView-\u0026gt;horizontalHeader()-\u0026gt;setMinimumSectionSize(0);  //行标题最大高度  tableView-\u0026gt;horizontalHeader()-\u0026gt;setMaximumHeight(rowHeight);  //默认行高  tableView-\u0026gt;verticalHeader()-\u0026gt;setDefaultSectionSize(rowHeight);  //选中时一行整体选中  tableView-\u0026gt;setSelectionBehavior(QAbstractItemView::SelectRows);  //只允许选择单个  tableView-\u0026gt;setSelectionMode(QAbstractItemView::SingleSelection);   //表头不可单击 #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,0,0))  tableView-\u0026gt;horizontalHeader()-\u0026gt;setSectionsClickable(false); #else  tableView-\u0026gt;horizontalHeader()-\u0026gt;setClickable(false); #endif   //鼠标按下即进入编辑模式  if (edit) {  tableView-\u0026gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);  } else {  tableView-\u0026gt;setEditTriggers(QAbstractItemView::NoEditTriggers);  } } QSqlTableModel #  QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯。\n//实例化数据库表模型 QSqlTableModel *model = new QSqlTableModel(this); //指定表名 model-\u0026gt;setTable(\u0026#34;table\u0026#34;); //设置列排序 model-\u0026gt;setSort(0, Qt::AscendingOrder); //设置提交模式 model-\u0026gt;setEditStrategy(QSqlTableModel::OnManualSubmit); //立即查询一次 model-\u0026gt;select(); //将数据库表模型设置到表格上 ui-\u0026gt;tableView-\u0026gt;setModel(model);  //测试发现过滤条件中除了可以带where语句还可以带排序及limit等 model-\u0026gt;setFilter(\u0026#34;1=1 order by id desc limit 100\u0026#34;);  //如果在过滤条件中设置了排序语句则不可以再使用setSort方法 //下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。 model-\u0026gt;setSort(0, Qt::AscendingOrder); model-\u0026gt;setFilter(\u0026#34;1=1 order by id desc limit 100\u0026#34;);  //通过setFilter设置单纯的where语句可以不用加1=1 model-\u0026gt;setFilter(\u0026#34;name=\u0026#39;张三\u0026#39;\u0026#34;); //如果还有其他语句比如排序或者limit等则需要最前面加上1=1 //下面表示按照id升序排序，查询结果显示第5-15条记录。 model-\u0026gt;setFilter(\u0026#34;1=1 order by id asc limit 5,10\u0026#34;);  //多个条件用and连接 //建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。 model-\u0026gt;setFilter(\u0026#34;1=1 and name=\u0026#39;张三\u0026#39; and result\u0026gt;=70;\u0026#34;);  //下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。 model-\u0026gt;setFilter(\u0026#34;1=1 and name=\u0026#39;张三\u0026#39; order by id desc limit 10,100;\u0026#34;);  //在第3行开始添加一条记录 model-\u0026gt;insertRow(2); //立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。 model-\u0026gt;setData(model-\u0026gt;index(2, 0), 100); model-\u0026gt;setData(model-\u0026gt;index(2, 1), \u0026#34;张三\u0026#34;); //提交更新 model-\u0026gt;submitAll();  //删除第4行 model-\u0026gt;removeRow(3); model-\u0026gt;submitAll();  //总之有增删改操作后都需要调用model-\u0026gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。  //撤销更改 model-\u0026gt;revertAll(); QList、QMap、QHash #  Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。\n//qwindowdefs.h typedef QList\u0026lt;QWidget *\u0026gt; QWidgetList; typedef QList\u0026lt;QWindow *\u0026gt; QWindowList; typedef QHash\u0026lt;WId, QWidget *\u0026gt; QWidgetMapper; typedef QSet\u0026lt;QWidget *\u0026gt; QWidgetSet;  //qmetatype.h typedef QList\u0026lt;QVariant\u0026gt; QVariantList; typedef QMap\u0026lt;QString, QVariant\u0026gt; QVariantMap; typedef QHash\u0026lt;QString, QVariant\u0026gt; QVariantHash; typedef QList\u0026lt;QByteArray\u0026gt; QByteArrayList; QLocale #  QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换。\n//格式化输出受到本地操作系统语言的影响  //英文操作系统 //这样获取到的是Mon到Sun，英文星期的3个字母的缩写。 QDateTime::currentDateTime().toString(\u0026#34;ddd\u0026#34;); //这样获取到的是Monday到Sunday，英文星期完整单词。 QDateTime::currentDateTime().toString(\u0026#34;dddd\u0026#34;);  //中文操作系统 //这样获取到的是周一到周日。 QDateTime::currentDateTime().toString(\u0026#34;ddd\u0026#34;); //这样获取到的是星期一到星期日。 QDateTime::currentDateTime().toString(\u0026#34;dddd\u0026#34;);  //主动指定语言转换 //如果没有指定本地语言则默认采用系统的语言环境。 QLocale locale; //QLocale locale = QLocale::Chinese; //QLocale locale = QLocale::English; //QLocale locale = QLocale::Japanese;C  //下面永远输出中文的周一到周日 locale.toString(QDateTime::currentDateTime(), \u0026#34;ddd\u0026#34;); //下面永远输出中文的星期一到星期日 locale.toString(QDateTime::currentDateTime(), \u0026#34;dddd\u0026#34;); QApplication #  Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。\n//如果是控制台程序则下面的QApplication换成QCoreApplication //如果是quick/qml程序则下面的QApplication换成QGuiApplication int main(int argc, char *argv[]) {  //可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard  qputenv(\u0026#34;QT_IM_MODULE\u0026#34;, QByteArray(\u0026#34;qtvirtualkeyboard\u0026#34;));   //设置不应用操作系统设置比如字体  QApplication::setDesktopSettingsAware(false);  #if (QT_VERSION \u0026gt;= QT_VERSION_CHECK(6,0,0))  //设置高分屏缩放舍入策略  QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor); #endif #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,6,0))  //设置启用高分屏缩放支持  //要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下  QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);  //设置启用高分屏图片支持  QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps); #endif #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,4,0))  //设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL  //在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速  //如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2  //QApplication::setAttribute(Qt::AA_UseOpenGLES);  //设置opengl共享上下文  QApplication::setAttribute(Qt::AA_ShareOpenGLContexts); #endif   QApplication a(argc, argv);  QWidget w;  w.show();  return a.exec(); } QRandomGenerator #  Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。\n//早期处理办法 先初始化随机数种子然后取随机数 qsrand(QTime::currentTime().msec()); //取 0-10 之间的随机数 qrand() % 10; //取 0-1 之间的浮点数 qrand() / double(RAND_MAX);  //新版处理办法 支持5.10以后的所有版本包括qt6 QRandomGenerator::global()-\u0026gt;bounded(10); //生成一个0和10之间的整数 QRandomGenerator::global()-\u0026gt;bounded(10.123); //生成一个0和10.123之间的浮点数 QRandomGenerator::global()-\u0026gt;bounded(10, 15); //生成一个10和15之间的整数  //兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数 srand(QTime::currentTime().msec()); rand() % 10; rand() / double(RAND_MAX);  //通用公式 a是起始值,n是整数的范围 int value = a + rand() % n; //(min, max)的随机数 int value = min + 1 + (rand() % (max - min - 1)); //(min, max]的随机数 int value = min + 1 + (rand() % (max - min + 0)); //[min, max)的随机数 int value = min + 0 + (rand() % (max - min + 0)); //[min, max]的随机数 int value = min + 0 + (rand() % (max - min + 1));  //如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。 //取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。 //切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大 srand((long long)currentThreadId()); qrand((long long)currentThreadId()); QString #  QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串\nQString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。\nQString s1, s2;\rs1 = \u0026#34;666.5567124\u0026#34;;\rs2.setNum(888.5632123, \u0026#39;f\u0026#39;, 7);\rqDebug() \u0026lt;\u0026lt; qSetRealNumberPrecision(10) \u0026lt;\u0026lt; s1.toDouble() \u0026lt;\u0026lt; s2.toDouble(); QSS样式 #  直接调用控件的 setstylesheet, 结果是每个控件 style 返回的对象都是不同的(地址不同足以证明是不同的对象), 而只给 QApplication 对象 setStyleSheet, 每个控件的 style 函数返回的对象都是相同的. 基于以上原因, 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有 一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是.\n默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\u0026quot;*{outline:0px;}\u0026quot;);\noutline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控 件, 也不一定是矩形\noutline: none; width, height 两个属性, 设置的均是盒子的内容的宽高, 而我们在 c++ 代码中的窗口的 width 与 height 指的是整个盒子的宽度与高度,\n指示器设置样式 #   可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置，  *::down-arrow{}\r*::menu-indicator{}\r*::up-arrow:disabled{}\r*::up-arrow:off{} QPushButton左对齐文字 #    QPushButton左对齐文字，需要设置样式表\nQPushButton{text-align:left;}   三种设置文本的方法 #  QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。\n//常规办法 ui-\u0026gt;label-\u0026gt;setText(\u0026#34;hello\u0026#34;); //取巧办法 ui-\u0026gt;label-\u0026gt;setProperty(\u0026#34;text\u0026#34;, \u0026#34;hello\u0026#34;); //属性大法 ui-\u0026gt;label-\u0026gt;setStyleSheet(\u0026#34;qproperty-text:hello;\u0026#34;); 样式表不起作用 #   Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。   方法一：设置属性 this-\u0026gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。  void Widget::paintEvent(QPaintEvent *)\r{\rQStyleOption option;\roption.initFrom(this);\rQPainter painter(this);\rstyle()-\u0026gt;drawPrimitive(QStyle::PE_Widget, \u0026amp;option, \u0026amp;painter, this);\r} 直接传入样式表文件路径 #  设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 \u0026lsquo;file:///\u0026rsquo; 开头，是的话则自动读取样式表文件进行设置，无需手动读取。\n//以前都是下面的方法 QFile file(\u0026#34;:/qss/psblack.css\u0026#34;); if (file.open(QFile::ReadOnly)) {  QString qss = QLatin1String(file.readAll());  qApp-\u0026gt;setStyleSheet(qss);  file.close(); }  //其实一行代码就行 qApp-\u0026gt;setStyleSheet(\u0026#34;file:///:/qss/psblack.css\u0026#34;); //特别说明，只支持qApp-\u0026gt;setStyleSheet 不支持其他比如widget-\u0026gt;setStyleSheet QCheckBox #  对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行。\nQCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator{ width:13px; height:13px; }  QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked{ image:url(:/qss/flatwhite/checkbox_unchecked.png); }  QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled{ image:url(:/qss/flatwhite/checkbox_unchecked_disable.png); }  QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked{ image:url(:/qss/flatwhite/checkbox_checked.png); }  QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled{ image:url(:/qss/flatwhite/checkbox_checked_disable.png); }  QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate{ image:url(:/qss/flatwhite/checkbox_parcial.png); }  QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled{ image:url(:/qss/flatwhite/checkbox_parcial_disable.png); } QTabBar #  QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮。\n//对tabWidget设置无切换按钮\rui-\u0026gt;tabWidget-\u0026gt;setUsesScrollButtons(false);\r//对tabBar设置无切换按钮\rui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;setUsesScrollButtons(false);\r//对整个系统的选项卡设置无切换按钮\rQTabBar{qproperty-usesScrollButtons:false;}\r//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔\rQTabBar{qproperty-expanding:false;}\r//设置选项卡关闭按钮可见\rQTabBar{qproperty-tabsClosable:true;}\r//还有其他属性参见QTabBar头文件有惊喜\r//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置 设置字体 #  设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。\n//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget  //下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont QFont font; font.setPixelSize(20); this-\u0026gt;setFont(font); this-\u0026gt;setStyleSheet(\u0026#34;{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;QWidget{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;Widget{font:26px;}\u0026#34;);  //下面才是通过样式表设置整个控件+子控件的字体 this-\u0026gt;setStyleSheet(\u0026#34;font:26px;\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;*{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;QWidget\u0026gt;*{font:26px;}\u0026#34;); this-\u0026gt;setStyleSheet(\u0026#34;Widget\u0026gt;*{font:26px;}\u0026#34;);  //下面设置全局字体 qApp-\u0026gt;setFont(font); *{font: normal 20px “微软雅黑”;}  QPushButton{ color: blue; }  namespace ns {  class MyPushButton : public QPushButton {  // ...  } } // ... qApp-\u0026gt;setStyleSheet(\u0026#34;ns--MyPushButton { background: yellow; }\u0026#34;);  .QPushButton{ color: blue; }  QAbstractSpinBox{ min-height: 30px; max-height: 30px; border-width: 1px; rder-style: solid; order-color: gray; padding: 0px; }  #button_1{  color: red; }  QPushButton#settings_popup_fileDialog_button{  min-height: 31px;  min-width: 70px;  border: 1px solid black;  color: #F0F0F0;  min-height: 10px;  border-radius:3px;  background: qlineargradient(spread:pad, x1:0, y1:0, x2:0, y2:1, stop:0 #454648, stop:1 #7A7A7A); }  BaseDialog QPushButton{  min-width: 120px;  min-height: 40px;  max-width: 120px;  max-height: 40px;  font-size: 20px;  padding: 0px; }  .QGroupBox \u0026gt; .QCheckBox{  color: blue; }  [objectName~=\u0026#34;button\u0026#34;]{  color: red; }  .QLineEdit, .QComboBox{  border: 1px solid gray;  background-color:white; } qss优先级 #  给控件直接设置的样式 \u0026gt; 给 QApplication 设置的样式\n如果是间接选中,那么最终的样式就是离目标最近的那个\n后面的样式会覆盖掉前面的样 式\nId \u0026gt; 类 \u0026gt; 类型 \u0026gt; 通配符 \u0026gt; 继承 \u0026gt; 默认\n升级到Qt6 #    源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。\n  QFontMetricsF 中的 fm.width() 换成 fm.horizontalAdvance() ，从5.11开始用新函数。\n  QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。\n  #if (QT_VERSION \u0026gt; QT_VERSION_CHECK(5,0,0))\r#include \u0026#34;qscreen.h\u0026#34;\r#define deskGeometry qApp-\u0026gt;primaryScreen()-\u0026gt;geometry()\r#define deskGeometry2 qApp-\u0026gt;primaryScreen()-\u0026gt;availableGeometry()\r#else\r#include \u0026#34;qdesktopwidget.h\u0026#34;\r#define deskGeometry qApp-\u0026gt;desktop()-\u0026gt;geometry()\r#define deskGeometry2 qApp-\u0026gt;desktop()-\u0026gt;availableGeometry()\r#endif "},{"id":37,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E4%B9%B1%E7%A0%81/","title":"乱码","section":"工作总结","content":"因此以下几行等价（以 UTF-8 编码保存 C++ 源文件）：\nconst char s1[] = \u0026#34; 最喜欢 C++ 了！ \u0026#34;; const char s2[] = \u0026#34;\\xe6\\x9c\\x80\\xe5\\x96\\x9c\\xe6\\xac\\xa2\\x43\\x2b\u0026#34; \u0026#34;\\x2b\\xe4\\xba\\x86\\xef\\xbc\\x81\u0026#34;; const char s3[] = { 0xe6, 0x9c, 0x80, 0xe5, 0x96, 0x9c, 0xe6, 0xac, 0xa2, 0x43, 0x2b, 0x2b, 0xe4, 0xba, 0x86, 0xef, 0xbc, 0x81, 0x00 }; 在兼顾了计算性能和存储性能之后， Qt 小组决定 将 UTF-16 作为 QString 的编码格式\n源代码中出现的中文字符串常量，在被 Qt 使用之前， 都经历了一次由「多字节编码」转换为 UTF-16 的过程\nQString 可以在必要的时候由 const char* 隐 式 或 显 式 转 换 而 成 。 这 个 过 程 中 使 用 的 编 码 ， 就 是 QTextCodec::codecForCStrings\nQt 有一个函数， QObject::tr ，也可以将 const char* 转换为 QString 。 这个过程中使用的编码方式由 QTextCodec::codecForTr 指定\nQt 读取文件可以用任何一种编码，只是默认以 codecForLocale 而已\n// 我们的源文件是 UTF-8 格式的，因此建立一个 QString 。 QString s = QString::fromUtf8(\u0026#34; 这是 UTF-8 的字符串 \u0026#34;); // 将 QString 转换为 GBK 格式的 QByteArray 字符数组。 // QByteArray::data() 可以拿到 const char* 。 QByteArray gbk_s = QTextCodec::codecForName(\u0026#34;gbk\u0026#34;)-\u0026gt;fromUnicode(s); // 然后再从 GBK 字符数组转换回 QString 。 QString s2 = QTextCodec::codecForName(\u0026#34;gbk\u0026#34;)-\u0026gt;toUnicode(gbk_s); "},{"id":38,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"数据库","section":"工作总结","content":"附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764\nattach [database] filename as database_name;\rdetach [database] database_name; Squeezing Performance from SQLite: Insertions #   https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2\nCREATE INDEX tag_titles ON tags (title);\rEXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = \u0026#34;Kotlin\u0026#34;; "},{"id":39,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/","title":"日志模块实现思路","section":"工作总结","content":"版本说明 #   日志模块实现    日期 版本 修改内容     2022/03/01 V0.1 创建      实现目标 #    整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦\n  整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时\n  能做到内存中始终能导出最近的日志到U盘中\n  程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0)\n  参考实现 #  Qt5官方日志QLoggingCategory测试 #  QLoggingCategory represents a certain logging category - identified by a string - at runtime. A category can be configured to enable or disable logging of messages per message type.\nSplit up logging messages in hierarchical categories.Category is identified by it\u0026rsquo;s name category.subcategory.subsubcategory[\u0026hellip;] Logging of messages can be enabled or disabled based on the category and message type, at runtime.\n优点：\n1、可以将各个模块日志通过各自的Debug Level进行控制\n2、运行时，动态修改各个模块的Debug Level\nImproving Logging Output #   https://community.kde.org/Guidelines_and_HOWTOs/Debugging/Using_Error_Messages\nQt provides a way of controlling the output of the logging methods via an environment variable. You can tell it to include the application name and PID, as well as the debugging category, and color-code the text. For example, running the following lines in your shell will produce something that looks quite like kDebug\u0026rsquo;s colored output:\nc=`echo -e \u0026#34;\\033\u0026#34;` export QT_MESSAGE_PATTERN=\u0026#34;%{appname}(%{pid})/(%{category}) $c\\[31m%{if-debug}$c\\[34m%{endif}%{function}$c\\[0m: %{message}\u0026#34; unset c See qSetMessagePattern documentation for the full list of placeholders.\n内部实现代码 #   https://stackoverflow.com/questions/55520757/how-to-use-q-logging-category-and-reference-the-category-in-a-templated-function\n#define Q_DECLARE_LOGGING_CATEGORY(name) \\ extern const QLoggingCategory \u0026amp;name();  #define Q_LOGGING_CATEGORY(name, ...) \\ const QLoggingCategory \u0026amp;name() \\ { \\ static const QLoggingCategory category(__VA_ARGS__); \\ return category; \\ }  //使用 #define qCDebug(category, ...) \\ for (bool qt_category_enabled = category().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false) \\ QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC, category().categoryName()).debug(__VA_ARGS__) moduo日志实现参考20210901 #  #define LOG_TRACE if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::TRACE) \\ muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream() #define LOG_DEBUG if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::DEBUG) \\ muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream() #define LOG_INFO if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::INFO) \\ muduo::Logger(__FILE__, __LINE__).stream() #define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream() #define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream() #define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream() #define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream() #define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream() syslog日志实现 #  日志消息级别syslog Level #   0 EMERG（紧急）：会导致主机系统不可用的情况 1 ALERT（警告）：必须马上采取措施解决的问题 2 CRIT（严重）：比较严重的情况 3 ERR（错误）：运行出现错误 4 WARNING（提醒）：可能会影响系统功能的事件 5 NOTICE（注意）：不会影响系统但值得注意 6 INFO（信息）：一般信息 7 DEBUG（调试）：程序或系统调试信息等     syslog journald priority level QtMsgType 说明     LOG_EMERG emerg QtFatalMsg System is unusable   LOG_ALERT alert  Should be corrected immediately   LOG_CRIT crit QtCriticalMsg Critical conditions   LOG_ERR err  Error conditions   LOG_WARNING warning QtWarningMsg May indicate that an error will occur if action is not taken.   LOG_NOTICE notice  Events that are unusual, but not error conditions.   LOG_INFO info QtInfoMsg Normal operational messages that require no action.   LOG_DEBUG debug QtDebugMsg Information useful to developers for debugging the application.    syslog与QDebug配合 #  Qt4封装\n#include \u0026lt;QApplication\u0026gt;#include \u0026lt;syslog.h\u0026gt; void customMessageHandler(QtMsgType type, const char* msg) {  switch(type)  {  case QtDebugMsg:  syslog(LOG_DEBUG, \u0026#34;%s\u0026#34;, msg);  break;  case QtInfoMsg:  syslog(LOG_INFO, \u0026#34;%s\u0026#34;, msg);  break;  case QtWarningMsg:  syslog(LOG_WARNING, \u0026#34;%s\u0026#34;, msg);  break;  case QtCriticalMsg:  syslog(LOG_CRIT, \u0026#34;%s\u0026#34;, msg);  break;  case QtFatalMsg:  syslog(LOG_ERR, \u0026#34;%s\u0026#34;, msg);  abort();//这里退出进程了  break;  default:  syslog(LOG_DEBUG, \u0026#34;%s\u0026#34;, msg);  break;  } }  int main(int argc, char* argv[]) {  QApplication a(argc, argv);  qInstallMsgHandler(customMessageHandler);  return a.exec(); } Qt5封装\n#include \u0026lt;QApplication\u0026gt;#include \u0026lt;syslog.h\u0026gt;static const char LOG_LEVEL_CHAR[8] = {\u0026#39;!\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;D\u0026#39;}; static void customMessageHandler(QtMsgType type, const QMessageLogContext \u0026amp;context, const QString \u0026amp;msg)  {  QByteArray localMsg = msg.toLocal8Bit();  const char *file = context.file ? context.file : \u0026#34;\u0026#34;;  const char *function = context.function ? context.function : \u0026#34;\u0026#34;;  const char *category = context.category ? context.category : \u0026#34;\u0026#34;;  int level = LOG_INFO;  switch (type) {  case QtDebugMsg:  level = LOG_DEBUG;  break;  case QtInfoMsg:  level = LOG_INFO;  break;  case QtWarningMsg:  level = LOG_WARNING;  break;  case QtCriticalMsg:  level = LOG_CRIT;  break;  case QtFatalMsg:  level = LOG_ERR;  break;  default:  break;  }  syslog(level, \u0026#34;[%c](%s,%s:%u, %s): %s \\n\u0026#34;, LOG_LEVEL_CHAR[level],category,file, context.line, function, localMsg.constData());  }  int main(int argc, char *argv[]) {  QApplication a(argc, argv);  qInstallMessageHandler(customMessageHandler);  return a.exec(); } Qt4中的qInstallMsgHandler函数被Qt5的qInstallMessageHandler替代了，增加了QMessageLogContext类，可以输出函数名、行号、文件路径信息\n测试结果如下，可以看出并没有显示函数名、行号等信息\nMay 24 09:43:23 am335x-evm test_log_category[954]: Debug: Log something:qCDebug 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Info: Log something:qCInfo 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Warning: Log something:qCWarning 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Critical: Log something:qCCritical 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Debug: Log something:qDebug 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Info: Log something:qInfo 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Warning: Log something:qWarning 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Critical: Log something:qCritical 74 (:0, , default) 通过以下两种方式修改pro文件后，可以开启函数名、行号等信息显示\n#方式1 CONFIG += debug CONFIG(debug, debug|release) {  DESTDIR = build/debug } CONFIG(release, debug|release) {  DESTDIR = build/release } #方式2 #Note: By default, this information is recorded only in debug builds. #You can overwrite this explicitly by defining QT_MESSAGELOGCONTEXT or QT_NO_MESSAGELOGCONTEXT. DEFINES +=QT_MESSAGELOGCONTEXT May 24 10:14:49 am335x-evm test_log_category[916]: [D](category1,../widget.cpp:28, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCDebug1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](category1,../widget.cpp:29, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCInfo1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](category1,../widget.cpp:30, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCWarning1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](category1,../widget.cpp:31, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCCritical1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [D](category2,../widget.cpp:34, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCDebug2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](category2,../widget.cpp:35, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCInfo2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](category2,../widget.cpp:36, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCWarning2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](category2,../widget.cpp:37, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCCritical2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [D](default,../widget.cpp:39, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qDebug3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](default,../widget.cpp:40, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qInfo3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](default,../widget.cpp:41, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qWarning3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](default,../widget.cpp:42, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCritical3 1 为了区分同一个进程内的不同模块日志，可使用QLoggingCategory类\nLogging kernel oops to MTD #  A kernel error, or oops, is normally logged via the klogd and syslogd daemons to a circular memory buffer or a file.\nFollowing a reboot, the log will be lost in the case of a ring buffer, and even in the case of a file, it may not have been properly written to before the system crashed.\nA more reliable method is to write oops and kernel panics to an MTD partition as a circular log buffer.\nYou can enable it with CONFIG_MTD_OOPS and add console=ttyMTDN to the kernel command line, with N being the MTD device number to write the messages to.\n• /var/log Generally, logging to flash memory is not desirable because of the many small write cycles it generates. A simple solution is to mount /var/log using tmpfs, making all log messages volatile. In the case of syslogd, BusyBox has a version that can log to a circular ring buffer.\njournald #  The journal collects:\n All data logged via libc syslog() The data from the kernel logged with printk() Everything written to STDOUT/STDERR of any system service  root@am335x-evm:~# systemctl status systemd-journald * systemd-journald.service - Journal Service  Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: disabled)  Active: active (running) since Mon 2021-05-24 08:05:14 UTC; 11min ago TriggeredBy: * systemd-journald.socket  * systemd-journald-dev-log.socket  * systemd-journald-audit.socket  Docs: man:systemd-journald.service(8)  man:journald.conf(5)  Main PID: 95 (systemd-journal)  Status: \u0026#34;Processing requests...\u0026#34;  Tasks: 1 (limit: 454)  Memory: 8.9M  CGroup: /system.slice/systemd-journald.service  `-95 /lib/systemd/systemd-journald  May 24 08:05:14 am335x-evm systemd-journald[95]: Journal started May 24 08:05:14 am335x-evm systemd-journald[95]: Runtime Journal (/run/log/journal/d962f275af8b4c3ca16323491f1b0a43) is 8.0M, max 64.0M, 56.0M free. May 24 08:05:15 am335x-evm systemd-journald[95]: Runtime Journal (/run/log/journal/d962f275af8b4c3ca16323491f1b0a43) is 8.0M, max 64.0M, 56.0M free. Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable. systemd-journald.service #  root@am335x-evm:~# cat /lib/systemd/system/systemd-journald.service # SPDX-License-Identifier: LGPL-2.1+ # # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version.  [Unit] Description=Journal Service Documentation=man:systemd-journald.service(8) man:journald.conf(5) DefaultDependencies=no Requires=systemd-journald.socket After=systemd-journald.socket systemd-journald-dev-log.socket systemd-journald-audit.socket syslog.socket Before=sysinit.target  [Service] OOMScoreAdjust=-250 CapabilityBoundingSet=CAP_SYS_ADMIN CAP_DAC_OVERRIDE CAP_SYS_PTRACE CAP_SYSLOG CAP_AUDIT_CONTROL CAP_AUDIT_READ CAP_CHOWN CAP_DAC_READ_SEARCH CAP_FOWNER CAP_SETUID CAP_SETGID CAP_MAC_OVERRIDE DeviceAllow=char-* rw ExecStart=/lib/systemd/systemd-journald FileDescriptorStoreMax=4224 IPAddressDeny=any LockPersonality=yes MemoryDenyWriteExecute=yes NoNewPrivileges=yes Restart=always RestartSec=0 RestrictAddressFamilies=AF_UNIX AF_NETLINK RestrictNamespaces=yes RestrictRealtime=yes RestrictSUIDSGID=yes Sockets=systemd-journald.socket systemd-journald-dev-log.socket systemd-journald-audit.socket StandardOutput=null SystemCallArchitectures=native SystemCallErrorNumber=EPERM SystemCallFilter=@system-service Type=notify WatchdogSec=3min  # If there are many split up journal files we need a lot of fds to access them # all in parallel. LimitNOFILE=524288 默认配置 journald.conf #  # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # # Entries in this file show the compile time defaults. # You can change settings by editing this file. # Defaults can be restored by simply deleting this file. # # See journald.conf(5) for details.  [Journal] #Storage=auto #Compress=yes #Seal=yes #SplitMode=uid #SyncIntervalSec=5m #RateLimitIntervalSec=30s #RateLimitBurst=10000 #SystemMaxUse= #SystemKeepFree= #SystemMaxFileSize= #SystemMaxFiles=100 #RuntimeMaxUse= #RuntimeKeepFree= #RuntimeMaxFileSize= #RuntimeMaxFiles=100 #MaxRetentionSec= #MaxFileSec=1month #ForwardToSyslog=no #ForwardToKMsg=no #ForwardToConsole=no #ForwardToWall=yes #TTYPath=/dev/console #MaxLevelStore=debug #MaxLevelSyslog=debug #MaxLevelKMsg=notice #MaxLevelConsole=info #MaxLevelWall=emerg #LineMax=48K #ReadKMsg=yes Storage=\n/run/log/journal目录存在则保存到内存中，the existence of the directory controls the storage mode\nNote that journald will initially use volatile storage, until a call to journalctl \u0026ndash;flush (or sending SIGUSR1 to journald) will cause it to switch to persistent logging (under the conditions mentioned above). This is done automatically on boot via \u0026ldquo;systemd-journal-flush.service\u0026rdquo;.\nMaxLevelStore=`, `MaxLevelSyslog=`, `MaxLevelKMsg=`, `MaxLevelConsole=`, `MaxLevelWall= Controls the maximum log level of messages that are stored in the journal, forwarded to syslog, kmsg, the console or wall (if that is enabled, see above). As argument, takes one of \u0026ldquo;emerg\u0026rdquo;, \u0026ldquo;alert\u0026rdquo;, \u0026ldquo;crit\u0026rdquo;, \u0026ldquo;err\u0026rdquo;, \u0026ldquo;warning\u0026rdquo;, \u0026ldquo;notice\u0026rdquo;, \u0026ldquo;info\u0026rdquo;, \u0026ldquo;debug\u0026rdquo;, or integer values in the range of 0–7 (corresponding to the same levels). Messages equal or below the log level specified are stored/forwarded, messages above are dropped. Defaults to \u0026ldquo;debug\u0026rdquo; for MaxLevelStore= and MaxLevelSyslog=, to ensure that the all messages are stored in the journal and forwarded to syslog. Defaults to \u0026ldquo;notice\u0026rdquo; for MaxLevelKMsg=, \u0026ldquo;info\u0026rdquo; for MaxLevelConsole=, and \u0026ldquo;emerg\u0026rdquo; for MaxLevelWall=. These settings may be overridden at boot time with the kernel command line options \u0026ldquo;systemd.journald.max_level_store=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_syslog=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_kmsg=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_console=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_wall=\u0026rdquo;.\n通过查看man journald.conf手册，为了满足需要，只需要/etc/systemd/journald.conf 做如下配置\nRuntimeMaxUse=16M #重启日志模块 $ systemctl restart systemd-journald 测试发现，设置为8M时，能导出的日志文件大概在176KB，里面包含1673行日志\n测试发现，占用为72M时，能导出的日志文件大概在3726KB，里面包含29888行日志\n如果只设置RuntimeMaxUse=16M，发现最后占用的空间会超过设定的空间16M，，于是测试同时设置RuntimeKeepFree=100M，仍然会超过预想的16M\n如果同时设置RuntimeMaxUse=16M和RuntimeMaxFiles=2这两个配置项，才能达到预想的16M，最终的配置如下\nRuntimeMaxUse=16M RuntimeMaxFiles=2 测试日志轮转 #  while true; do echo testing 1234567890 | systemd-cat; done 备份日志脚本参考 #  [root@study ~]# vim /backups/backup.sh #!/bin/bash  if [ \u0026#34;${1}\u0026#34; == \u0026#34;log\u0026#34; ]; then  logger -p syslog.info \u0026#34;backup.sh is starting\u0026#34; fi source=\u0026#34;/etc /home /root /var/lib /var/spool/{cron,at,mail}\u0026#34; target=\u0026#34;/backups/backup-system-$（date +%Y-%m-%d）.tar.gz\u0026#34; [ ! -d /backups ] \u0026amp;\u0026amp; mkdir /backups tar -zcvf ${target} ${source} \u0026amp;\u0026amp;gt; /backups/backup.log if [ \u0026#34;${1}\u0026#34; == \u0026#34;log\u0026#34; ]; then  logger -p syslog.info \u0026#34;backup.sh is finished\u0026#34; fi  [root@study ~]# /backups/backup.sh log [root@study ~]# journalctl SYSLOG_FACILITY=5 -n 3 Aug 19 18:09:37 study.centos.vbird dmtsai[29850]: backup.sh is starting Aug 19 18:09:54 study.centos.vbird dmtsai[29855]: backup.sh is finished 测试syslog关联 #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;syslog.h\u0026gt;int main() {  printf(\u0026#34;hello world1\\n\u0026#34;);  syslog(LOG_INFO, \u0026#34;hello world2\\n\u0026#34;);  fprintf(stdout,\u0026#34;this is fprintf stdout test!\\n\u0026#34;);  fprintf(stderr,\u0026#34;this is fprintf stderr test!\\n\u0026#34;);  return 0; } 测试1：直接运行测试程序，可以看出syslog方式输出的日志被记录到journald日志系统中\nMay 24 09:57:30 am335x-evm test_journald[1918]: hello world2 测试2：将测试程序添加到systemd中\nroot@am335x-evm:~# cat /etc/systemd/system/test_journald.service [Unit] Description=test_journald After=network-online.target Wants=network-online.target  [Service] ExecStart=/home/root/test_journald Restart=always KillMode=process 可以看出，如果通过service方式启动，不管是printf,stdout,stderr,还是syslog方式，全部都被记录到journald日志系统中了\nroot@am335x-evm:~# systemctl restart test_journald root@am335x-evm:~# journalctl /home/root/test_journald May 24 14:01:12 am335x-evm test_journald[3799]: hello world2 May 24 14:01:12 am335x-evm test_journald[3799]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3799]: hello world1 May 24 14:01:12 am335x-evm test_journald[3799]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3801]: hello world2 May 24 14:01:12 am335x-evm test_journald[3801]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3801]: hello world1 May 24 14:01:12 am335x-evm test_journald[3801]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3802]: hello world2 May 24 14:01:12 am335x-evm test_journald[3802]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3802]: hello world1 May 24 14:01:12 am335x-evm test_journald[3802]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3803]: hello world2 May 24 14:01:12 am335x-evm test_journald[3803]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3803]: hello world1 May 24 14:01:12 am335x-evm test_journald[3803]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3804]: hello world2 May 24 14:01:12 am335x-evm test_journald[3804]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3804]: hello world1 May 24 14:01:12 am335x-evm test_journald[3804]: this is fprintf stdout test! 常用命令 #  $ journalctl --since=2012-10-15 --until=\u0026#34;2011-10-16 23:59:59\u0026#34; $ journalctl -u httpd --since=00:00 --until=9:30 $ journalctl /usr/sbin/vpnc /usr/sbin/dhclient  #The + is an explicit OR you can use in addition to the implied OR $ journalctl _HOSTNAME=theta _UID=70 + _HOSTNAME=epsilon _COMM=avahi-daemon #显示特定程序的所有消息 $ journalctl /usr/lib/systemd/systemd #查看特定位置的日志 $ journalctl -D /mnt/var/log/journal -xe  #Displaying Logs by Process ID $ journalctl _PID=1221  #只展示内核日志 $ journalctl -k #显示毫秒 $ journalctl -o short-precise  # 显示Priority level $ journalctl -p err..alert  #手动清理日志，会保留最新的日志，从旧的日志开始删除 $ journalctl --vacuum-size=10M $ journalctl --vacuum-time=2weeks  #查看当前使用空间 $ journalctl --disk-usage Archived and active journals take up 8.0M in the file system.   #修改/etc/systemd/journald.conf配置文件后，重启systemd-journald日志服务 $ systemctl restart systemd-journald 应用程序日志重定向 #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;syslog.h\u0026gt;#include \u0026lt;QDebug\u0026gt;int main() {  qDebug()\u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __FUNCTION__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt;\u0026#34;this is QDebug test1\u0026#34;;  printf(\u0026#34;this is printf test ,hello world1\\n\u0026#34;);  syslog(LOG_INFO, \u0026#34;this is syslog test,hello world2\\n\u0026#34;);  fprintf(stdout,\u0026#34;this is fprintf stdout test!\\n\u0026#34;);  fprintf(stderr,\u0026#34;this is fprintf stderr test!\\n\u0026#34;);  qDebug()\u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __FUNCTION__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt;\u0026#34;this is QDebug test2\u0026#34;;  return 0; } 通过管道和systemd-cat程序，将程序中的所有日志重定向到journald中\n./test_journald 2\u0026gt;\u0026amp;1 |systemd-cat May 24 13:02:31.141452 am335x-evm cat[1438]: ../test.cpp main 6 this is QDebug test1 May 24 13:02:31.145114 am335x-evm test_journald[1437]: this is syslog test,hello world2 May 24 13:02:31.147729 am335x-evm cat[1438]: this is fprintf stderr test! May 24 13:02:31.152862 am335x-evm cat[1438]: ../test.cpp main 11 this is QDebug test2 May 24 13:02:31.152862 am335x-evm cat[1438]: this is printf test ,hello world1 May 24 13:02:31.152862 am335x-evm cat[1438]: this is fprintf stdout test! 从输出结果可以看出：\n1、通过systemd-cat导入到journald后，日志中的进程名为cat，而使用syslog后，能正确显示进程名\n2、QDebug和syslog的优先级比printf和fprintf stdout方式要高，并且QDebug和syslog会按照出现的顺序进行输出\n日志集中管理 #  利用rsyslog，将日志发送到远程服务器，可以使前期调试阶段更方便\n总结 #  1、为了将上层应用和内核的日志统一输出，便于定位问题，需要利用systemd中的强大的journald日志管理程序\n2、为了保证日志统一输出到journald中，针对Qt程序和非Qt程序调用统一封装日志接口宏，在日志接口宏中统一调用syslog接口\n3、对于Qt程序，可以利用QLoggingCategory类，可以控制日志按模块输出\n参考链接 #   http://highscalability.com/log-everything-all-time\n http://jinke.me/2018-05-10-muduo-logger/\n https://riccoqu.github.io/2016/03/24/Linux%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8ESyslog%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/\n鸟叔systemd-journald.service 简介 #   https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/160.html\njournald-logging-tutorial #   https://sematext.com/blog/journald-logging-tutorial/\n"},{"id":40,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/Table-Model/","title":"Table Model","section":"Advanced Qt Programming","content":"Qt\u0026rsquo;s model/view architecture #   Qt\u0026rsquo;s model hierarchy #   关联Table Model中的数据到QComboBox，并过滤重复数据 #  void MainWindow::createComboBoxModel(QComboBox *comboBox, int column) { \tdelete comboBox-\u0026gt;model(); \tUniqueProxyModel *uniqueProxyModel = new UniqueProxyModel(column,this); \tuniqueProxyModel-\u0026gt;setSourceModel(model); \tuniqueProxyModel-\u0026gt;sort(column, Qt::AscendingOrder); \tcomboBox-\u0026gt;setModel(uniqueProxyModel); \tcomboBox-\u0026gt;setModelColumn(column); } 清除QTableView中的选择 #  QItemSelectionModel *selectionModel = tableView-\u0026gt;selectionModel(); selectionModel-\u0026gt;clearSelection(); QItemSelection和QItemSelectionModel进行任意行组合选择 #   QItemSelection selection;  int firstSelectedRow = -1;  for (int row = 0; row \u0026lt; proxyModel-\u0026gt;rowCount(); ++row) {  QModelIndex index = proxyModel-\u0026gt;index(row, Zipcode);   QItemSelection rowSelection(index, index);  selection.merge(rowSelection, QItemSelectionModel::Select);  }  QItemSelectionModel *selectionModel = tableView-\u0026gt;selectionModel();  selectionModel-\u0026gt;clearSelection();  selectionModel-\u0026gt;select(selection, QItemSelectionModel::Rows|  QItemSelectionModel::Select); 过滤重复 #  bool MySortFilterProxyModel::filterAcceptsRow(int sourceRow,  const QModelIndex \u0026amp;sourceParent) const {  QModelIndex index = sourceModel()-\u0026gt;index(sourceRow, Column,  sourceParent);  const QString \u0026amp;text = sourceModel()-\u0026gt;data(index).toString();  if (cache.contains(text))  return false;  cache \u0026lt;\u0026lt; text;  return true; }  void QSortFilterProxyModel::setFilterRegExp(const QString \u0026amp;pattern); void QSortFilterProxyModel::setFilterRegExp(const QRegExp \u0026amp;regExp); 排序 #  //make the Qt::UserRole’s data the data used for sorting QStandardItemModel::setSortRole(Qt::UserRole); QTableView::setSortingEnabled(true); 计算ComboBox的size #  If we didn’ provide the extra space, when the user started editing an item that had a spin box or combobox editor,some of the item’s text would probably be obscured\n if (role == Qt::SizeHintRole) {  QStyleOptionComboBox option;  switch (index.column()) {  case PostOffice: option.currentText = item.postOffice;  break;  case County: option.currentText = item.county; break;  case State: option.currentText = item.state; break;  default: Q_ASSERT(false);  }  QFontMetrics fontMetrics(data(index, Qt::FontRole).value\u0026lt;QFont\u0026gt;());  option.fontMetrics = fontMetrics;  QSize size(fontMetrics.width(option.currentText),  fontMetrics.height());  return qApp-\u0026gt;style()-\u0026gt;sizeFromContents(QStyle::CT_ComboBox,\u0026amp;option, size);  } "},{"id":41,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/4th-level/","title":"4th Level","section":"第一章","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.工作\n"},{"id":42,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/6th-level/","title":"6th Level","section":"5th Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":43,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/","title":"5th Level","section":"第一章","content":"5rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":44,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/","title":"第一章","section":"深入理解计算机系统","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":45,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/12th-level/","title":"12th Level","section":"7th Level","content":"11th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":46,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/","title":"7th Level","section":"第二章","content":"10rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":47,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/8th-level/","title":"8th Level","section":"第二章","content":"14th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":48,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"第二章","section":"深入理解计算机系统","content":"9rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":49,"href":"/posts/","title":"Blog","section":"Introduction","content":"  Google编程规范总结  版本说明 # Google编程规范总结 日期 版本 修改内容 20211029 V0.1 创建 目的 # 使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 项目主页: Google Style Guide Google 开源项目风格指南 - 中文版 代码规范 # 头文件 # 前置声明 # 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可 前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。 If a class only appears in the header as a pointer or reference, then a forward declaration is sufficient   浮点数计算误差分析  浮点数计算误差分析   ZeroTier内网穿透  ZeroTier内网穿透   搭建HUGO博客  搭建HUGO博客 # 安装hugo # 进入 release页面下载，选择下载 hugo_extended_0.97.0_Linux-64bit.deb带extended后缀的安装包 sudo dpkg -i hugo_extended_0.97.0_Linux-64bit.deb 创建hugo工程 # mkdir ~/Public/Book cd ~/Public/Book hugo new site ./ 下载主题 # git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book cp -R themes/hugo-book/exampleSite/content . 运行Web服务 # ubuntu:~/Public/Book$ hugo server --minify --theme hugo-book --bind=\u0026#34;0.0.0.0\u0026#34; -p 8888 Start building sites … hugo v0.97.0-c07f3626e7c8160943591f4d209977efa02c3dca+extended linux/amd64 BuildDate=2022-04-14T08:45:07Z VendorInfo=gohugoio WARN 2022/04/16 01:47:16 Expand shortcode is deprecated. Use \u0026#39;details\u0026#39; instead. WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/variables\u0026#39; not found in \u0026#39;posts/goisforlovers.   "},{"id":50,"href":"/docs/","title":"Introduction","section":"Introduction","content":"记录工作和学习\n  读书笔记  记录读书笔记，看过的书隔段时间总会忘记，总结在此，方便检索 深入理解计算机系统 第一章 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   工程实践  Introduction # 记录各种感兴趣的尝试 FalconMode模式 版本说明 # FalconMode模式 日期 版本 修改内容 2021/11/21 V0.1 创建 FalconMode模式 # Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel Falcon mode: U-Boot SPL -\u0026gt; Kernel https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7 Once you are booted up into the Linux Kernel there should be NO difference. 测试启动时间 # 模式 文件系统 tftp下载时间 内核到telnet时间 正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒 正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒 Falcon模式 Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK BBB板使用NFS挂载文件系统 版本说明 # BBB板使用NFS挂载文件系统 日期 版本 修改内容 2022/03/03 V0.   工作总结  Introduction # 记录工作中遇到的难点及解决方法 乱码 因此以下几行等价（以 UTF-8 编码保存 C++ 源文件）： const char s1[] = \u0026#34; 最喜欢 C++ 了！ \u0026#34;; const char s2[] = \u0026#34;\\xe6\\x9c\\x80\\xe5\\x96\\x9c\\xe6\\xac\\xa2\\x43\\x2b\u0026#34; \u0026#34;\\x2b\\xe4\\xba\\x86\\xef\\xbc\\x81\u0026#34;; const char s3[] = { 0xe6, 0x9c, 0x80, 0xe5, 0x96, 0x9c, 0xe6, 0xac, 0xa2, 0x43, 0x2b, 0x2b, 0xe4, 0xba, 0x86, 0xef, 0xbc, 0x81, 0x00 }; 在兼顾了计算性能和存储性能之后， Qt 小组决定 将 UTF-16 作为 QString 的编码格式 源代码中出现的中文字符串常量，在被 Qt 使用之前， 都经历了一次由「多字节编码」转换为 UTF-16 的过程 QString 可以在必要的时候由 const char* 隐 式 或 显 式 转 换 而 成 。 这 个 过 程 中 使 用 的 编 码 ， 就 是 QTextCodec::codecForCStrings 数据库 附加数据库（Attach DB）https://blog.   Qt总结  Qt总结 常见类使用 常见类使用 # QTableWidget # 关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。 //每次调用 clearContents 都会自动清理之前的item ui-\u0026gt;tableWidget-\u0026gt;clearContents(); for (int i = 0; i \u0026lt; count; ++i) { ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 0, new QTableWidgetItem(\u0026#34;aaa\u0026#34;)); ui-\u0026gt;tableWidget-\u0026gt;setItem(i, 1, new QTableWidgetItem(\u0026#34;bbb\u0026#34;)); ui-\u0026gt;tableWidget-\u0026gt;setCellWidget(i, 2, new QPushButton(\u0026#34;ccc\u0026#34;)); } QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充， //方法1：字符串空格填充 ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;测 试\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;人员管理\u0026#34;); ui-\u0026gt;tabWidget-\u0026gt;addTab(httpClient1, \u0026#34;系统设置\u0026#34;); //方法2：识别尺寸改变事件自动设置最小宽度 void MainWindow::resizeEvent(QResizeEvent *e) { int count = ui-\u0026gt;tabWidget-\u0026gt;tabBar()-\u0026gt;count(); int width = this-\u0026gt;width() - 30; QString qss = QString(\u0026#34;QTabBar::tab{min-width:%1px;}\u0026#34;).arg(width / count); this-\u0026gt;setStyleSheet(qss); } //方法3：设置全局样式，不同选项卡个数的设置不同的宽度 QStringList list; list \u0026lt;\u0026lt; QString(\u0026#34;QTabWidget[tabCount=\\\u0026#34;2\\\u0026#34;]\u0026gt;QTabBar::tab{min-width:%1px;}\u0026#34;).   Linux World  记录Linux系统中常常遇到的问题对应的解决方法 工具 Linux必备工具 Git Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   "}]