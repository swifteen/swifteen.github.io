<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Freedom Book</title>
    <link>https://swifteen.github.io/</link>
    <description>Recent content in Introduction on Freedom Book</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://swifteen.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Google编程规范总结</title>
      <link>https://swifteen.github.io/posts/Google%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/posts/Google%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</guid>
      <description>版本说明 #   Google编程规范总结     日期 版本 修改内容     20211029 V0.1 创建    目的 #  使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要.
项目主页:
  Google Style Guide  Google 开源项目风格指南 - 中文版  代码规范 #  头文件 #  前置声明 #    尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可
  前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。
 If a class only appears in the header as a pointer or reference, then a forward declaration is sufficient</description>
    </item>
    
    <item>
      <title>1.让自己习惯C&#43;&#43;</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/1.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/1.%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC&#43;&#43;/</guid>
      <description>将构造函数声明为explicit，可阻止被用来执行隐式类型转换，仍可被用来进行显示类型转换
class C{ public:  explicit C(int x); } Accustoming Yourself to C++ #  1.View C++ as a federation of languages #   C Object-Oriented C++ Template C++ STL  2.Perfer consts,enums,and inlines to#defines #  一旦宏被定义，在其后的编译过程中一直有效，除非在某处被#undef
const double AspectRatio = 1.653; const char* const authorName = &amp;#34;Scott Meyers&amp;#34;; const std::string authorName(&amp;#34;Scott Meyers&amp;#34;); 对于单纯常量，最好以const对象或者enums替换#defines
class GamePlayer{ private: 	static const int NumTurns = 5;//新一点的编译器才支持声明时定义  int scores[NumTurns]; } class GamePlayer{ private: 	enum{ NumTurns = 5};  int scores[NumTurns]; } 对于形似函数的宏（macros），最好改用inline函数替换#defines</description>
    </item>
    
    <item>
      <title>Git常用配置</title>
      <link>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>Github国内加速克隆及下载 #  fastgit.org https://doc.fastgit.org/
gitclone.com https://gitclone.com/
gitee https://gitee.com/mirrors
cnpmjs.org https://github.com.cnpmjs.org/
Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot).
git代理 #  git config --global https.proxy &amp;#39;socks5://192.168.31.181:10808&amp;#39; git config --global http.proxy &amp;#39;socks5://192.168.31.181:10808&amp;#39; 基本配置 #  Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。
 # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e [--global]  # 设置提交代码时的用户信息 $ git config [--global] user.</description>
    </item>
    
    <item>
      <title>常见类使用</title>
      <link>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%BD%BF%E7%94%A8/</guid>
      <description>常见类使用 #  QTableWidget #  关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。
//每次调用 clearContents 都会自动清理之前的item ui-&amp;gt;tableWidget-&amp;gt;clearContents(); for (int i = 0; i &amp;lt; count; ++i) {  ui-&amp;gt;tableWidget-&amp;gt;setItem(i, 0, new QTableWidgetItem(&amp;#34;aaa&amp;#34;));  ui-&amp;gt;tableWidget-&amp;gt;setItem(i, 1, new QTableWidgetItem(&amp;#34;bbb&amp;#34;));  ui-&amp;gt;tableWidget-&amp;gt;setCellWidget(i, 2, new QPushButton(&amp;#34;ccc&amp;#34;)); } QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充，
//方法1：字符串空格填充 ui-&amp;gt;tabWidget-&amp;gt;addTab(httpClient1, &amp;#34;测 试&amp;#34;); ui-&amp;gt;tabWidget-&amp;gt;addTab(httpClient1, &amp;#34;人员管理&amp;#34;); ui-&amp;gt;tabWidget-&amp;gt;addTab(httpClient1, &amp;#34;系统设置&amp;#34;);  //方法2：识别尺寸改变事件自动设置最小宽度 void MainWindow::resizeEvent(QResizeEvent *e) {  int count = ui-&amp;gt;tabWidget-&amp;gt;tabBar()-&amp;gt;count();  int width = this-&amp;gt;width() - 30;  QString qss = QString(&amp;#34;QTabBar::tab{min-width:%1px;}&amp;#34;).arg(width / count);  this-&amp;gt;setStyleSheet(qss); }  //方法3：设置全局样式，不同选项卡个数的设置不同的宽度 QStringList list; list &amp;lt;&amp;lt; QString(&amp;#34;QTabWidget[tabCount=\&amp;#34;2\&amp;#34;]&amp;gt;QTabBar::tab{min-width:%1px;}&amp;#34;).</description>
    </item>
    
    <item>
      <title>浮点数计算误差分析</title>
      <link>https://swifteen.github.io/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90/</guid>
      <description>版本说明 #   内容: 浮点数计算误差分析 时间: 2022/02/28 版本: V 0.1  浮点数计算误差分析 #  通过分析汇编代码，分析浮点数运行产生的误差
测试程序 #  例子 1 #  #include &amp;lt;stdio.h&amp;gt;int main() { 	int a = 33800; 	long long b = 13*sizeof(short)*(a); 	printf(&amp;#34;[%lld]\n&amp;#34;,b); } 例子 2 #  #include &amp;lt;stdio.h&amp;gt;int main() { 	int a = 33800; 	long long b = 13*1000*sizeof(short)* (double)(a/1000.0); 	printf(&amp;#34;[%lld]\n&amp;#34;,b); } 例子1输出878800 例子2输出878799
为何会产生差异呢，只能从汇编代码入手，一点一点分析浮点计算的过程
例子1汇编代码 #  例子1不涉及浮点数，因此汇编代码比较简单，先通过例子1的汇编代码进行了解。</description>
    </item>
    
    <item>
      <title>2.构造、析构、赋值运算</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/2.%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/2.%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</guid>
      <description>Constructors,Destructors,and Assignment Operators #  5.Know what functions C++ silently writes and calls #    编译器可以暗自为class创建default构造函数 、copy构造函数、copy assignment操作符，以及析构函数
区分copy构造和copy赋值
class Widget{ public:  Widget();//default构造  Widget(const Widget&amp;amp; rhs);//copy构造  Widget&amp;amp; operator=(const Widget&amp;amp; rhs);//copy assignment操作符 }; Widget w1;//default构造 Widget w2(w1);//copy构造 w1 = w2;//copy assignment操作符 Widget w3 = w2;//copy构造 通过是否真正产生新的对象来区分copy构造和拷贝赋值   6.Explicitly disallow the use of compiler-generated functions you do not want #    所有编译器产出的函数都是public，为驳回编译器自动提供的机能，可将相应的成员函数声明为Private并且不予实现
#define Q_DISABLE_COPY(Class) \ 	Class(const Class &amp;amp;) = delete;\ 	Class &amp;amp;operator=(const Class &amp;amp;) = delete; class Uncopyable { protected://允许derived对象构造和析构  Uncopyable(){}  ~Uncopyable(){} private:  Uncopyable(const Uncopyable&amp;amp;);  Uncopyable&amp;amp; operator=(const Uncopyable&amp;amp;); } //继承Uncopyable可以阻止HomeForSale对象被拷贝 class HomeForSale:private Uncopyable {  .</description>
    </item>
    
    <item>
      <title>FalconMode模式</title>
      <link>https://swifteen.github.io/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/FalconMode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/FalconMode/</guid>
      <description>版本说明 #   FalconMode模式    日期 版本 修改内容     2021/11/21 V0.1 创建      FalconMode模式 #  Normal mode: U-Boot SPL -&amp;gt; U-Boot -&amp;gt; Kernel
Falcon mode: U-Boot SPL -&amp;gt; Kernel
 https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7
Once you are booted up into the Linux Kernel there should be NO difference.
 测试启动时间 #     模式 文件系统 tftp下载时间 内核到telnet时间     正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒   正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒   Falcon模式       Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK</description>
    </item>
    
    <item>
      <title>git基本使用</title>
      <link>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      Git对比SVN #   1.小步提交，互不干扰 #  并行开发过程中各开发人员可以随时多次commit代码且互不影响，最后在merage到主分支，并且能记录所有成员的所有commint记录。SVN只能大量的一次性提交到中心库。
2.打断开发：在开发新功能过程中，突然需要你去修复一个Bug #  使用Git，你可以直接stash/commit当前改动，然后switch到主分支去修复Bug，之后在pop/switch回你原来的分支继续开发。
3.Git分支切换-指针移动，SVN分支切换-Copy项目 #  Git支持本地无限Branches，当我们个体在本地创建多个branches用于不同目的的时候（修改，新增，探索），分支轻量化，秒创分支，创建分支满足客户定制化需求
4.Git Tag-指针标示，SVN Tag-Copy项目 #  Git管理的项目要比SVN小得多。Git初次拉取代码的速度也远小于SVN。
5.两级提交 #  本地创建分支开发，本地提交，需要合并时再提交到远程
6.日志查看 #  Git本地包含了完整的日志，闪电的速度查看（并且无需网络)。SVN需要从服务拉取。
7.安全 #  Git是分布式版本控制系统，每个用户都相当于一份备份， 管理员无需为数据备份而担心。SVN作为集中式版本控制系统，存在单点故障的风险。备份版本库的任务非常繁重。
linus在google的演讲感悟 链接：https://www.zhihu.com/question/19601997/answer/95363587
 自洽的、最少依赖的个人工作得到支持。1000多人的Linux开发团队是分布在世界各地的，使用git也就不必依赖中心服务器、不必需要很少的网络。就在自己的电脑上就有完整的仓库，可以做任何版本管理，除了分享代码。SVN显然是不合适的，因为单点故障大家甚至无法提交，更加无法开分支，这是无法忍受的。 剔除害群之马很简单。如果Linus经过观察，发现有些程序员特别容易出漏子，那么封杀的办法就是不必拉取即可。实际上Linus就是这样干过。如果是SVN，就变成了撤销惹麻烦的开发者的账号或者限定他的访问范围，并且从仓库中移除麻烦的代码提交。就是说，封杀的方法在git而言，是不做某事即可，SVN是做一系列事情才可以。一正一反，大家可以体会一下。Linus喜欢前者，并且得心应手。这样的工作流程就避开了很多“政治”问题，让他的集成代码过程变得主动。 可以使用信任网络。Linux太大了，不可能完全看完补丁代码的方式来识别信任，这个Linus曾经干过，最后的结果当然是放弃。如果发现有些程序员特别优秀，他只要选择拉取他们的实现。这些程序员也只是拉取他们信任的程序员的实现。这样的信任网络是可以层次化的，因此对应于1000多人的开发者来说，这样做确实可以通过分层的信任网络达成大规模的团队协作。如果是SVN，我不知道如何做可以更好 轻量的分支开销鼓励大量被使用。对于这样的团队，为了敏捷的迭代，如果有想法就分支（这样的开发隔离想法是很有价值的），那么在svn上分支是海量的并且全局的大家互相影响，因此是要命的。而对于Git总数当然是海量，但是每个人的分支都在自己的仓库内，不会影响到他人。且分支无需连接服务器，因此是飞速的。  Git工作流 #   http://www.</description>
    </item>
    
    <item>
      <title>snippet</title>
      <link>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/snippet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/snippet/</guid>
      <description>延时异步加载 #  用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。
//异步执行load函数QMetaObject::invokeMethod(this, &amp;#34;load&amp;#34;, Qt::QueuedConnection);//延时10毫秒执行load函数QTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 #  //拿到控件元对象 const QMetaObject *metaObject = widget-&amp;gt;metaObject();  //所有属性的数量 int propertyCount = metaObject-&amp;gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-&amp;gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i &amp;lt; propertyCount; ++i) {  QMetaProperty metaProperty = metaObject-&amp;gt;property(i);  const char *name = metaProperty.name();  const char *type = metaProperty.typeName();  QVariant value = widget-&amp;gt;property(name);  qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; type &amp;lt;&amp;lt; value; }  //所有方法的数量 int methodCount = metaObject-&amp;gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-&amp;gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i &amp;lt; methodCount; ++i) {  QMetaMethod metaMethod = metaObject-&amp;gt;method(i);  const char *name = metaMethod.</description>
    </item>
    
    <item>
      <title>目录共享配置</title>
      <link>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E7%9B%AE%E5%BD%95%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E7%9B%AE%E5%BD%95%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE/</guid>
      <description>Samba配置 #  samba配置后，仍然无法访问 #   https://blog.csdn.net/Panda_YinLP/article/details/104687438
访问window共享目录 #  sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 #   https://linuxhint.com/install_tftp_server_ubuntu/
 https://download.samba.org/pub/samba/
NFS挂载 #   https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04
将文件系统目录导出 #  解压文件系统
cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.</description>
    </item>
    
    <item>
      <title>系统代理和证书</title>
      <link>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E5%92%8C%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E5%92%8C%E8%AF%81%E4%B9%A6/</guid>
      <description>系统代理 #  vi ~/.profile  export http_proxy=&amp;#39;http://myproxy.example.com:1080/&amp;#39; export https_proxy=&amp;#39;https://myproxy.example.com:1080/&amp;#39; export ftp_proxy=&amp;#39;http://myproxy.example.com:1080/&amp;#39; export ALL_PROXY=&amp;#39;socks://myproxy.example.com:1080/&amp;#39; export all_proxy=&amp;#39;socks://myproxy.example.com:1080/&amp;#39; export no_proxy=&amp;#39;example.com&amp;#39; $ sudo apt-get install socat $ wget http://git.yoctoproject.org/cgit/cgit.cgi/poky/plain/scripts/oe-git-proxy $ cp oe-git-proxy ~/bin $ chmod +x ~/bin/oe-git-proxy  export GIT_PROXY_COMMAND=&amp;#34;oe-git-proxy&amp;#34; export NO_PROXY=$no_proxy vi ~/.wgetrc  https_proxy = http://socks.example.com:1080 http_proxy = http://socks.example.com:1080 ftp_proxy = http://socks.example.com:1080 no_proxy = example.com:1080;127.0.0.1 use_proxy = on  https://wiki.yoctoproject.org/wiki/Working_Behind_a_Network_Proxy
透明代理 #   https://blog.a1253247.info/2020/01/shadowsocks.html
代理转换 #  /etc/polipo/config
/etc/polipo/config  systemctl status polipo  www.</description>
    </item>
    
    <item>
      <title>3.资源管理</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/3.%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/3.%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid>
      <description>Resource Management #  13.Use objects tomanage resources #   获得资源后立刻放进管理对象，RAII(Resource Acquisition Is Initialization资源获取时机便是初始化时机) 管理对象运用析构函数确保资源被释放 auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作，vector和string几乎总是可以取代动态分配而得的数组，可以使用boost::scoped_array和boost::shared_array类  14.Think carefully about copying behavior in resource-managing classes #    如果复制动作对RAII class 并不合理，考虑禁止复制
  复制RAII对象必须一并复制它所管理的资源，常见的RAII class copying行为是：抑制copying，施行引用计数法
  15.Provide access to raw resources in resource-managing classes #    APIs往往要求访问原始资源，所以每个RAII class应该提供一个取得其所管理之资源的办法
  通常通过调用abort结束程序，来阻止异常从析构函数传播出去
  class Font{ public:  explicit Font(FontHandle fh):f(fh)  {}  ~Font()  {  releaseFont(f);  }  operator FontHandle() const;//隐式转换函数  {  return f;  } private:  FontHandle f; } 16.</description>
    </item>
    
    <item>
      <title>BBB板使用NFS挂载文件系统</title>
      <link>https://swifteen.github.io/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/BBB%E6%9D%BF%E4%BD%BF%E7%94%A8NFS%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/BBB%E6%9D%BF%E4%BD%BF%E7%94%A8NFS%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>版本说明 #   BBB板使用NFS挂载文件系统    日期 版本 修改内容     2022/03/03 V0.1 创建      将TI SDK中提供的文件系统目录NFS导出 #  解压文件系统
cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.</description>
    </item>
    
    <item>
      <title>git高级使用</title>
      <link>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</guid>
      <description>版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      个人使用总结 #  Merge节点 #  Git有两种合并：一种是&amp;quot;直进式合并&amp;quot;（fast forward），不生成单独的合并节点；另一种是&amp;quot;非直进式合并&amp;quot;（none fast-forword），会生成单独节点。
前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用--no-ff参数）。只要发生合并，就要有一个单独的合并节点。
 push策略 #  不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。
$ git config --global push.default matching # 或者 $ git config --global push.default simple 解决merge 和 rebase 合并冲突 #  #merge 和 rebase 对于 ours 和 theirs 的定义是完全相反的。在 merge 时，ours 指代的是当前分支，theirs 代表需要被合并的分支。而在 rebase 过程中，ours 指向了修改参考分支，theirs 却是当前分支 git checkout --ours src/MyFile.</description>
    </item>
    
    <item>
      <title>QSS样式</title>
      <link>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/QSS%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/QSS%E6%A0%B7%E5%BC%8F/</guid>
      <description>QSS样式 #  直接调用控件的 setstylesheet, 结果是每个控件 style 返回的对象都是不同的(地址不同足以证明是不同的对象), 而只给 QApplication 对象 setStyleSheet, 每个控件的 style 函数返回的对象都是相同的. 基于以上原因, 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有 一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是.
默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(&amp;quot;*{outline:0px;}&amp;quot;);
outline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控 件, 也不一定是矩形
outline: none; width, height 两个属性, 设置的均是盒子的内容的宽高, 而我们在 c++ 代码中的窗口的 width 与 height 指的是整个盒子的宽度与高度,
指示器设置样式 #   可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置，  *::down-arrow{}*::menu-indicator{}*::up-arrow:disabled{}*::up-arrow:off{} QPushButton左对齐文字 #    QPushButton左对齐文字，需要设置样式表
QPushButton{text-align:left;}   三种设置文本的方法 #  QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。
//常规办法 ui-&amp;gt;label-&amp;gt;setText(&amp;#34;hello&amp;#34;); //取巧办法 ui-&amp;gt;label-&amp;gt;setProperty(&amp;#34;text&amp;#34;, &amp;#34;hello&amp;#34;); //属性大法 ui-&amp;gt;label-&amp;gt;setStyleSheet(&amp;#34;qproperty-text:hello;&amp;#34;); 样式表不起作用 #   Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。   方法一：设置属性 this-&amp;gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。  void Widget::paintEvent(QPaintEvent *){QStyleOption option;option.</description>
    </item>
    
    <item>
      <title>其它</title>
      <link>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E5%85%B6%E5%AE%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/Ubuntu/%E5%85%B6%E5%AE%83/</guid>
      <description>ubuntu扩容 #   https://blog.csdn.net/qq_34160841/article/details/113058756
linux命令 #   https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html
安装armhf ubuntu #   https://wiki.ubuntu.com/ARM/RaspberryPi</description>
    </item>
    
    <item>
      <title>4.设计与声明</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/4.%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/4.%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</guid>
      <description>Designs and Declarations #  18.Make interfaces easy to use correctly and hard to use incorrectly #    好的接口容易被正确使用 ，不容易被误用
  阻止误用的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任
  19.Treat class design as type design #    Class的设计就是type的设计
  标准string和STL窗口都不被设计作为base classed使用，因为它们的析构函数都不带virtual
  20.Prefer pass-by-reference-to-const to pass-by-value #    对于内置类型，以及STL的迭代器和函数对象，使用pass-by-value更合适
  C++编译器底层中的references往往是以指针方式实现的，意味着真正传递的是指针
  21.Don&amp;rsquo;t try to return a reference when you must return an object #  当必须返回新对象时，就让那个函数返回新对象，如下</description>
    </item>
    
    <item>
      <title>5.实现</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/5.%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/5.%E5%AE%9E%E7%8E%B0/</guid>
      <description>Implementations #  26.Postpone variable definitions as long as possible #  std::string encryptPassword(const std::string&amp;amp; password) {  std::string encrypted;//默认构造 	encrypted = passwd;//赋值操作  encrypt(encrypted);  return encrypted; } 更推荐下面的做法，更高效
std::string encryptPassword(const std::string&amp;amp; password) {  std::string encrypted(passwd);//copy构造  encrypt(encrypted);  return encrypted; } //1次构造，1次析构，n次赋值 Widget w; for(int i = 0;i &amp;lt; n; ++i) {  w = ... } 更推荐上面的做法，更高效
//n次构造，n次析构 for(int i = 0;i &amp;lt; n; ++i) {  Widget w;  w = .</description>
    </item>
    
    <item>
      <title>ZeroTier内网穿透</title>
      <link>https://swifteen.github.io/posts/zerotier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/posts/zerotier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>ZeroTier内网穿透 #  安装方式1：脚本自动安装 #  sudo curl -s https://install.zerotier.com|sudo bash 在ubuntu下成功安装，在树莓派上可能失败
安装方式2：源码安装 #  wget https://github.com/zerotier/ZeroTierOne/archive/refs/tags/1.8.4.tar.gz tar zxvf 1.8.4.tar.gz cd ZeroTierOne-1.8.4/ make -j make install 注册账号 #  申请ID,参考https://blog.csdn.net/kai3123919064/article/details/109662499
运行 #  1、在每个设备端上运行服务端zerotier-one，并将每一个设备添加到相同的NetworkID组，这样同一下 NetworkID组下的所有成员就能相互穿透了
先安装zerotier-one服务并运行，这样以后开机自动启动此服务
#在源码目录下可以看到此文件 ~/Public/ZeroTierOne-1.8.4 $ cat debian/zerotier-one.service [Unit] Description=ZeroTier One After=network-online.target Wants=network-online.target  [Service] ExecStart=/usr/sbin/zerotier-one Restart=always KillMode=process  [Install] WantedBy=multi-user.target 注意检查上面的/usr/sbin/zerotier-one路径是否存在
#将此文件 拷贝到/lib/systemd/system/目录下 $ cp debian/zerotier-one.service /lib/systemd/system/ #启动服务 $ systemctl start zerotier-one.service #查看服务状态 $ systemctl status zerotier-one.</description>
    </item>
    
    <item>
      <title>搭建HUGO博客</title>
      <link>https://swifteen.github.io/posts/Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/posts/Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/</guid>
      <description>搭建HUGO博客 #  安装hugo #  进入 release页面下载，选择下载 hugo_extended_0.97.0_Linux-64bit.deb带extended后缀的安装包
sudo dpkg -i hugo_extended_0.97.0_Linux-64bit.deb 创建hugo工程 #  mkdir ~/Public/Book cd ~/Public/Book hugo new site ./ 下载主题 #  git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book cp -R themes/hugo-book/exampleSite/content . 运行Web服务 #  ubuntu:~/Public/Book$ hugo server --minify --theme hugo-book --bind=&amp;#34;0.0.0.0&amp;#34; -p 8888 Start building sites … hugo v0.97.0-c07f3626e7c8160943591f4d209977efa02c3dca+extended linux/amd64 BuildDate=2022-04-14T08:45:07Z VendorInfo=gohugoio WARN 2022/04/16 01:47:16 Expand shortcode is deprecated. Use &amp;#39;details&amp;#39; instead. WARN 2022/04/16 01:47:16 Page &amp;#39;/layout/variables&amp;#39; not found in &amp;#39;posts/goisforlovers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/Linux-World/Raspberry/%E5%B8%B8%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/Raspberry/%E5%B8%B8%E7%94%A8/</guid>
      <description>apt源 #  修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）：
清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi
阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib
修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源：
deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
使用代理
apt update -o Acquire::http::proxy=&amp;#34;socks5h://192.168.31.181:10808/&amp;#34; raspberry-qt #   https://github.com/tranter/raspberry-pi-qt-builds/releases
cd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake  https://blog.csdn.net/tianfour/article/details/76068656
youtube-dl #  channel_url=&amp;#34;https://www.youtube.com/user/channelname/playlists&amp;#34;https://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlistshttps://www.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/%E9%85%8D%E7%BD%AE/</guid>
      <description>vim退出时不清除屏幕内容 #  1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示：
 2、然后执行source /etc/profile即可
vim设置colorSchema #  mkdir -p ~/.vim/colors  https://github.com/tomasr/molokai
设置蓝色 #  eval `dircolors | sed -e &amp;#39;s/;34:/;36:/&amp;#39;` pi@raspberrypi:~ $ echo $LS_COLORS  rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then  test -r ~/.dircolors &amp;amp;&amp;amp; eval &amp;#34;$(dircolors -b ~/.dircolors)&amp;#34; || eval &amp;#34;$(dircolors -b)&amp;#34;  alias ls=&amp;#39;ls --color=auto&amp;#39;  #alias dir=&amp;#39;dir --color=auto&amp;#39;  #alias vdir=&amp;#39;vdir --color=auto&amp;#39;   alias grep=&amp;#39;grep --color=auto&amp;#39;  alias fgrep=&amp;#39;fgrep --color=auto&amp;#39;  alias egrep=&amp;#39;egrep --color=auto&amp;#39; fi  LS_COLORS=&amp;#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Linux-World/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</guid>
      <description>find ./ -type d -name &amp;#34;Backup&amp;#34; -exec rm -rf {} \;  sed -i &amp;#34;s/&amp;lt;cups\/cups.h&amp;gt;/\&amp;#34;cups\/cups.h\&amp;#34;/g&amp;#34; `grep &amp;#34;cups/cups.h&amp;#34; -rl .`  find . -type f -size +100M -print0 | xargs -0 du -h | sort -nr  cat *.txt | sort | uniq &amp;gt; test  #导出svn版本差异 for i in $(svn diff --summarize -r 248:276 svn://192.168.10.200/rootfs/ | awk &amp;#39;{ print $2 }&amp;#39;); do p=$(echo $i | sed -e &amp;#39;s{svn://192.168.10.200/rootfs/{{&amp;#39;); mkdir -p $(dirname $p); svn export $i $p; done  #获取awk .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/%E6%95%B4%E7%90%86Qt-snippet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/Qt%E6%80%BB%E7%BB%93/%E6%95%B4%E7%90%86Qt-snippet/</guid>
      <description>延时异步加载 #  用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。
//异步执行load函数QMetaObject::invokeMethod(this, &amp;#34;load&amp;#34;, Qt::QueuedConnection);//延时10毫秒执行load函数QTimer::singleShot(10, this, SLOT(load())); 获取类的属性和方法 #  //拿到控件元对象 const QMetaObject *metaObject = widget-&amp;gt;metaObject();  //所有属性的数量 int propertyCount = metaObject-&amp;gt;propertyCount(); //propertyOffset是自定义的属性开始的位置 int propertyOffset = metaObject-&amp;gt;propertyOffset(); //循环取出控件的自定义属性, int i = 0 表示所有属性 for (int i = propertyOffset; i &amp;lt; propertyCount; ++i) {  QMetaProperty metaProperty = metaObject-&amp;gt;property(i);  const char *name = metaProperty.name();  const char *type = metaProperty.typeName();  QVariant value = widget-&amp;gt;property(name);  qDebug() &amp;lt;&amp;lt; name &amp;lt;&amp;lt; type &amp;lt;&amp;lt; value; }  //所有方法的数量 int methodCount = metaObject-&amp;gt;methodCount(); //methodOffset是自定义的方法开始的位置 int methodOffset = metaObject-&amp;gt;methodOffset(); //循环取出控件的自定义方法, int i = 0 表示所有方法 for (int i = methodOffset; i &amp;lt; methodCount; ++i) {  QMetaMethod metaMethod = metaObject-&amp;gt;method(i);  const char *name = metaMethod.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E4%B9%B1%E7%A0%81/</guid>
      <description>因此以下几行等价（以 UTF-8 编码保存 C++ 源文件）：
const char s1[] = &amp;#34; 最喜欢 C++ 了！ &amp;#34;; const char s2[] = &amp;#34;\xe6\x9c\x80\xe5\x96\x9c\xe6\xac\xa2\x43\x2b&amp;#34; &amp;#34;\x2b\xe4\xba\x86\xef\xbc\x81&amp;#34;; const char s3[] = { 0xe6, 0x9c, 0x80, 0xe5, 0x96, 0x9c, 0xe6, 0xac, 0xa2, 0x43, 0x2b, 0x2b, 0xe4, 0xba, 0x86, 0xef, 0xbc, 0x81, 0x00 }; 在兼顾了计算性能和存储性能之后， Qt 小组决定 将 UTF-16 作为 QString 的编码格式
源代码中出现的中文字符串常量，在被 Qt 使用之前， 都经历了一次由「多字节编码」转换为 UTF-16 的过程
QString 可以在必要的时候由 const char* 隐 式 或 显 式 转 换 而 成 。 这 个 过 程 中 使 用 的 编 码 ， 就 是 QTextCodec::codecForCStrings</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764
attach [database] filename as database_name;detach [database] database_name; Squeezing Performance from SQLite: Insertions #   https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2
CREATE INDEX tag_titles ON tags (title);EXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = &amp;#34;Kotlin&amp;#34;; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</guid>
      <description>版本说明 #   日志模块实现    日期 版本 修改内容     2022/03/01 V0.1 创建      实现目标 #    整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦
  整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时
  能做到内存中始终能导出最近的日志到U盘中
  程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0)
  参考实现 #  Qt5官方日志QLoggingCategory测试 #  QLoggingCategory represents a certain logging category - identified by a string - at runtime. A category can be configured to enable or disable logging of messages per message type.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/Table-Model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/Table-Model/</guid>
      <description>Qt&amp;rsquo;s model/view architecture #   Qt&amp;rsquo;s model hierarchy #   关联Table Model中的数据到QComboBox，并过滤重复数据 #  void MainWindow::createComboBoxModel(QComboBox *comboBox, int column) { 	delete comboBox-&amp;gt;model(); 	UniqueProxyModel *uniqueProxyModel = new UniqueProxyModel(column,this); 	uniqueProxyModel-&amp;gt;setSourceModel(model); 	uniqueProxyModel-&amp;gt;sort(column, Qt::AscendingOrder); 	comboBox-&amp;gt;setModel(uniqueProxyModel); 	comboBox-&amp;gt;setModelColumn(column); } 清除QTableView中的选择 #  QItemSelectionModel *selectionModel = tableView-&amp;gt;selectionModel(); selectionModel-&amp;gt;clearSelection(); QItemSelection和QItemSelectionModel进行任意行组合选择 #   QItemSelection selection;  int firstSelectedRow = -1;  for (int row = 0; row &amp;lt; proxyModel-&amp;gt;rowCount(); ++row) {  QModelIndex index = proxyModel-&amp;gt;index(row, Zipcode);   QItemSelection rowSelection(index, index);  selection.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/Tree-Model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Advanced-Qt-Programming/Tree-Model/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/4th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/4th-level/</guid>
      <description>4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/6th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/6th-level/</guid>
      <description>4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/12th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/12th-level/</guid>
      <description>11th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/8th-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/8th-level/</guid>
      <description>14th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.
Venasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto!</description>
    </item>
    
  </channel>
</rss>
