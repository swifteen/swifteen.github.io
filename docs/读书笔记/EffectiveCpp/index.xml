<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Freedom Book</title>
    <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/</link>
    <description>Recent content on Freedom Book</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Accustoming Yourself to C&#43;&#43;</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC&#43;&#43;/</guid>
      <description>将构造函数声明为explicit，可阻止被用来执行隐式类型转换，仍可被用来进行显示类型转换
class C{ public:  explicit C(int x); } 区分copy构造和copy赋值 #  class Widget{ public:  Widget();//default构造  Widget(const Widget&amp;amp; rhs);//copy构造  Widget&amp;amp; operator=(const Widget&amp;amp; rhs);//copy assignment操作符 }; Widget w1;//default构造 Widget w2(w1);//copy构造 w1 = w2;//copy assignment操作符 Widget w3 = w2;//copy构造 通过是否真正产生新的对象来区分copy构造和拷贝赋值 Accustoming Yourself to C++ #  View C++ as a federation of languages #   C Object-Oriented C++ Template C++ STL  Perfer consts,enums,and inlines to#defines #  一旦宏被定义，在其后的编译过程中一直有效，除非在某处被#undef</description>
    </item>
    
    <item>
      <title>构造、析构、赋值运算</title>
      <link>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://swifteen.github.io/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/EffectiveCpp/%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</guid>
      <description>Constructors,Destructors,and Assignment Operators #  6.Know what functions C++ silently writes and calls #    编译器可以暗自为class创建default构造函数 、copy构造函数、copy assignment操作符，以及析构函数
  所有编译器产出的函数都是public，为驳回编译器自动提供的机能，可将相应的成员函数声明为Private并且不予实现
#define Q_DISABLE_COPY(Class) \ 	Class(const Class &amp;amp;) = delete;\ 	Class &amp;amp;operator=(const Class &amp;amp;) = delete; class Uncopyable { protected://允许derived对象构造和析构  Uncopyable(){}  ~Uncopyable(){} private:  Uncopyable(const Uncopyable&amp;amp;);  Uncopyable&amp;amp; operator=(const Uncopyable&amp;amp;); } //继承Uncopyable可以阻止HomeForSale对象被拷贝 class HomeForSale:private Uncopyable {  ... }   7.Declare destructors virtual in polymorphic base classes #    只有当class内含至少一个virtual函数才为它声明virtual析构函数</description>
    </item>
    
  </channel>
</rss>
