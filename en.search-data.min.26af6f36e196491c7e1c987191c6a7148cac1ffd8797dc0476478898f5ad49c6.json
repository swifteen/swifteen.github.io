[{"id":0,"href":"/posts/Google%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/","title":"Google编译规范总结","section":"Blog","content":"版本说明 #   Google编译规范总结     日期 版本 修改内容     20211029 V0.1 创建    目的 #  使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要.\n项目主页:\n  Google Style Guide  Google 开源项目风格指南 - 中文版  代码规范 #  头文件 #  前置声明 #    尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可\n  前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。\n If a class only appears in the header as a pointer or reference, then a forward declaration is sufficient\n   也就是说，类在头文件中，只是以指针或者引用的形式存在时，使用前置声明就够了。但原则上还是尽量避免使用前置声明\n内联函数 #    只有当函数只有 10 行甚至更少时才将其定义为内联函数.\n  内联那些包含循环或 switch 语句的函数常常是得不偿失\n  有些函数即使声明为内联的也不一定会被编译器内联， 虚函数和递归函数就不会被正常内联\n  类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cc 文件里\n  #include 的路径及顺序 #  dir2/foo2.h (优先位置, 详情如下)，让别人的头文件先出错，避免首先怀疑自己的头文件出现错误\n  C 系统文件\n  C++ 系统文件\n  其他库的 .h 文件\n  本项目内 .h 文件\n  在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯\n#include \u0026#34;foo/public/fooserver.h\u0026#34; // 优先位置 #include \u0026lt;sys/types.h\u0026gt;//C 系统文件#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;hash_map\u0026gt;//C++ 系统文件 #include \u0026lt;vector\u0026gt; #include \u0026#34;base/basictypes.h\u0026#34;//其他库的 .h 文件#include \u0026#34;base/commandlineflags.h\u0026#34; #include \u0026#34;foo/public/bar.h\u0026#34; //本项目内 .h 文件作用域 #  命名空间 #    不应该使用 using 指示 引入整个命名空间的标识符号\n  不要在命名空间 std 内声明任何东西\n  不要在头文件中使用 命名空间别名\n  禁止用内联命名空间\n  匿名命名空间和静态变量 #   https://roachsinai.github.io/Cpp-learning-notes/declaration/namespace/anonymous.html\n  在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static\n  单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间\n//推荐 namespace myproject { namespace foo_bar { void Function1(); void Function2(); } // namespace foo_bar } // namespace myproject //不推荐 namespace myproject { class FooBar {  public:  static void Function1();  static void Function2(); }; } // namespace myproject   非成员函数、静态成员函数和全局函数 #  如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 2.1. 命名空间 或 static 链接关键字 (如 static int Foo() {\u0026hellip;}) 限定其作用域.\n局部变量 #    C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值\nint j = g(); // 好——初始化时声明  int i; i = f(); // 坏——初始化和声明分离   局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」\n  注意别在循环犯大量构造和析构的低级错误\n Foo f; // 构造函数和析构函数只调用 1 次  for (int i = 0; i \u0026lt; 1000000; ++i) {  f.DoSomething(i);  } // 低效的实现 for (int i = 0; i \u0026lt; 1000000; ++i) {  Foo f; // 构造函数和析构函数分别调用 1000000 次!  f.DoSomething(i); }   静态全局变量Static and Global Variables #   不推荐给非局部变量动态分配空间，通常禁止这样做   Dynamic initialization of nonlocal variables is discouraged, and in general it is forbidden.\n 允许给静态局部变量动态分配空间   Dynamic initialization of static local variables is allowed (and common).\n 当一个初始化指向另一个具有静态存储期限的变量时，有可能导致一个对象在其生命周期开始前（或在其生命周期结束后）被访问。此外，当一个程序启动的线程在退出时没有加入，如果对象的析构器已经运行，这些线程可能试图在其生命周期结束后访问对象。   When one initialization refers to another variable with static storage duration, it is possible that this causes an object to be accessed before its lifetime has begun (or after its lifetime has ended). Moreover, when a program starts threads that are not joined at exit, those threads may attempt to access objects after their lifetime has ended if their destructor has already run.\n  静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体\n  只允许 POD 类型的静态变量，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])来作为静态变量。\n  多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug\n  禁止使用类的 静态储存周期 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。\n  尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;\n   同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。\n 类 #  构造函数 #    构造函数不得调用虚函数。 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患\n  不要在无法报出错误时进行可能失败的初始化。如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法\n  隐式类型转换 #   转换运算符和单参数构造函数, 请使用 explicit 关键字   This keyword is a declaration specifier that can only be applied to in-class constructor declarations . An explicit constructor cannot take part in implicit conversions. It can only be used to explicitly construct an object 。\n  https://www.jianshu.com/p/af8034ec0e7a\n为避免隐式转换, 需将单参数构造函数声明为 explicit;   explicit的作用是用来声明类构造函数是显示调用的，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的\n 可拷贝类型和可移动类型 #    拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.\n  如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之\n  //MyClass is neither copyable nor movable. MyClass(const MyClass\u0026amp;) = delete; MyClass\u0026amp; operator=(const MyClass\u0026amp;) = delete;  如果你的基类需要可复制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现.\n  为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;\nprivate: \tMyClass(const MyClass \u0026amp;other); \tMyClass \u0026amp;operator = (const MyClass \u0026amp;other);    If a class contains pointer-type member variables, the copy constructor and the Assignment operator should either be explicitly implemented or declared as \u0026ldquo;private\u0026rdquo; (and not implemented). This ensures that the compiler does not generate any defaults for these methods that produce a \u0026ldquo;flat\u0026rdquo; copy of such objects and thus possibly create memory problems.\n 对于有指针成员变量的类，拷贝构造和赋值构造必须显式实现或者声明为私有\n结构体 VS. 类 #  仅当只有数据成员时使用 struct, 其它一概使用 class\n继承 #    如果使用继承的话, 定义为 public 继承.\n  必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数.\n  子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做\n  如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.\n  只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.\n  存取控制 #  将所有数据成员声明为 private, 除非是 static const 类型成员\n声明顺序 #    将相似的声明放在一起, 将 public 部分放在最前.\n  类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:\n  建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员\nMyClass { public:  typedef xxx  {  int x,  }yyy;   const int kMyValue = 100; public:  MyClass();  MyClass(const MyClass\u0026amp;);  ~MyClass(); protected:  void func_a(); private:  void func_b(); private:  int m_iValue; };   不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中\n  函数 #  参数顺序 #    将所有的输入参数置于输出参数之前\n  在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.\n  引用参数 #    定义引用参数可以防止出现 (*pval)++ 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针\n  大多时候输入形参往往是 const T\u0026amp;. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑\n  函数重载 #   如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append().  缺省参数 #    对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作.\n  我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。\n  智能指针 #    scoped_ptr 和 auto_ptr 已过时. 现在是 shared_ptr 和 uniqued_ptr 的天下了。不要使用 std::auto_ptr, 使用 std::unique_ptr 代替它\n  如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 std::unique_ptr 来明确所有权传递\n   std::unique_ptr\u0026lt;Foo\u0026gt; FooFactory();\rvoid FooConsumer(std::unique_ptr\u0026lt;Foo\u0026gt; ptr); 如果确实要使用共享所有权, 建议于使用 std::shared_ptr  其它C++特性 #  友元 #  如果你只允许另一个类访问该类的私有成员时\n异常 #    Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难\n  很多 C++ 书籍上都提到当构造失败时只有异常可以处理\n   https://www.zhihu.com/question/22889420\n  类型转换 #  C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类\n  用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.\n  用 const_cast 去掉 const 限定符.\n  用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换.\n  流 #    不要使用流, 除非是日志接口需要. 使用 printf 之类的代替.\n  使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.\n  前置自增和自减 #  对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).\nconst 用法 #   关键字 mutable 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.  const int* foo; //提倡但不强制 int const *foo; 注意初始化 const 对象时，必须在初始化的同时值初始化  整型 #  int 与 unsigned int 运算时，前者被提升为 unsigned int 而有可能溢出\n//无限循环 for (unsigned int i = foo.Length()-1; i \u0026gt;= 0; --i) ... 使用断言来指出变量为非负数, 而不是使用无符号型!不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.\n预处理宏 #    宏具有全局作用域\n  用 # 字符串化, 用 ## 连接\n  不要在 .h 文件中定义宏\n  在马上要使用时才进行 #define, 使用后要立即 #undef\n  0, nullptr 和 NULL #    整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 \u0026lsquo;\\0\u0026rsquo;.\n  C++11 项目用 nullptr; C++03 项目则用 NULL\n  sizeof #  尽可能用 sizeof(varname) 代替 sizeof(type)\n//下面代码存在错误，只对data的前4个字节执行了memset Struct* data = NULL; data = new Struct; memset(data, 0, sizeof(data)); auto #    auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。\n  永远别列表初始化 auto 变量\n  auto 在涉及迭代器的循环语句里挺常用\n  命名约定 #  函数命名, 变量命名, 文件命名要有描述性; 少用缩写\n文件命名 #  文件名要全部小写, 可以包含下划线 (_)\n定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar\n类型命名 #  类型名称的每个单词首字母均大写, 不包含下划线。类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n// 类和结构体 class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ...  // 类型定义 typedef hash_map\u0026lt;UrlTableProperties *, string\u0026gt; PropertiesMap;  // using 别名 using PropertiesMap = hash_map\u0026lt;UrlTableProperties *, string\u0026gt;;  // 枚举 enum UrlTableErrors { ... 变量命名 #  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接\n常量命名 #  声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合\nconst int kDaysInAWeek = 7; 函数命名 #  常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配。写作 StartRpc() 而非 StartRPC()。驼峰变量名\n枚举命名 #  单独的枚举值应该优先采用 常量 的命名方式\nenum UrlTableErrors {  kOK = 0,  kErrorOutOfMemory,  kErrorMalformedInput, }; 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式\n注释 #  如果类的声明和定义分开了(例如分别放在了 .h 和 .cc 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起。不要在 .h 和 .cc 之间复制注释, 这样的注释偏离了注释的实际意义.\n函数声明 #    函数是否分配了必须由调用者释放的空间.\n  参数是否可以为空指针\n  实现注释 #  对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.\n实现技巧 #   如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例.  ProductOptions options; options.set_precision_decimals(7); options.set_use_cache(ProductOptions::kDontUseCache); const DecimalNumber product =  CalculateProduct(values, options, /*completion_callback=*/nullptr); 你所提供的注释应当解释代码 为什么 要这么做和代码的目的, 或者最好是让代码自文档化.  if (!IsAlreadyProcessed(element)) {  Process(element); } TODO 注释 #  // TODO(kl@gmail.com): Use a \u0026#34;*\u0026#34; here for concatenation operator. // TODO(Zeke) change this to use relations. // TODO(bug 12345): remove the \u0026#34;Last visitors\u0026#34; feature 格式 #  制表符 #  不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.\n函数声明与定义 #    左圆括号总是和函数名在同一行.\n  函数名和左圆括号间永远没有空格\n  圆括号与参数间没有空格\n  左大括号总在最后一个参数同一行的末尾处, 不另起新行.\n  右圆括号和左大括号间总是有一个空格\n  条件语句 #  if (condition) { // 好 - IF 和 { 都与空格紧邻.\n预处理指令 #  预处理指令不要缩进, 从行首开始\n// 好 - 指令从行首开始  if (lopsided_score) { #if DISASTER_PENDING // 正确 - 从行首开始  DropEverything(); # if NOTIFY // 非必要 - # 后跟空格  NotifyClient(); # endif #endif  BackToNormal();  } 命名空间内容不缩进\nnamespace {  void foo() { // 正确. 命名空间内没有额外的缩进.  ... }  } / 垂直留白 #  垂直留白越少越好,同一屏可以显示的代码越多, 越容易理解程序的控制流\n"},{"id":1,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","title":"Git常用配置","section":"Git","content":"Github国内加速克隆及下载 #  fastgit.org https://doc.fastgit.org/\ngitclone.com https://gitclone.com/\ngitee https://gitee.com/mirrors\ncnpmjs.org https://github.com.cnpmjs.org/\nGithub documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot).\ngit代理 #  git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 #  Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e [--global]  # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34;  自定义配置： #  git config --global core.editor \u0026#34;vim\u0026#34; git config --global alias.unstage \u0026#34;reset HEAD\u0026#34; #chmod产生的变化应该忽略 git config --global core.filemode false git config --global core.autocrlf true git config --global gui.encoding utf-8 git config --global core.quotepath false git config --global color.ui true git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.cp cherry-pick git config --global alias.lg \u0026#34;log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit --date=format:\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;\u0026#34; 增加全局git配置文件/etc/gitconfig\nroot@3520f78b5030:/home/imac# cat /etc/gitconfig [color]  ui = true [alias]  co = checkout  ci = commit  br = branch  lg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd) %C(white blue bold)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit --date=iso  st = status  unstage = reset HEAD  cp = cherry-pick  lgg = log --color --graph --pretty=format:\u0026#39;%C(yellow)%d%Creset %s \u0026#39; --abbrev-commit  alias = ! git config --get-regexp ^alias\\\\. | sed -e s/^alias\\\\.// -e s/\\\\ /\\\\ =\\\\ /  lggg = log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(white blue bold)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit [gui]  encoding = utf-8 [push]  default = current [credential]  helper = store [core]  quotepath = false  fileMode = false  sharedRepository = true "},{"id":2,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/","title":"工具","section":"Linux World","content":"Linux必备工具\n  Git  Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   Vim  配置 vim退出时不清除屏幕内容 # 1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示： 2、然后执行source /etc/profile即可 vim设置colorSchema # mkdir -p ~/.vim/colors https://github.com/tomasr/molokai 设置蓝色 # eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34; alias ls=\u0026#39;ls --color=auto\u0026#39; #alias dir=\u0026#39;dir --color=auto\u0026#39; #alias vdir=\u0026#39;vdir --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.   常用 Linux命令  find ./ -type d -name \u0026#34;Backup\u0026#34; -exec rm -rf {} \\; sed -i \u0026#34;s/\u0026lt;cups\\/cups.h\u0026gt;/\\\u0026#34;cups\\/cups.h\\\u0026#34;/g\u0026#34; `grep \u0026#34;cups/cups.h\u0026#34; -rl .` find . -type f -size +100M -print0 | xargs -0 du -h | sort -nr cat *.txt | sort | uniq \u0026gt; test #导出svn版本差异 for i in $(svn diff --summarize -r 248:276 svn://192.168.10.200/rootfs/ | awk \u0026#39;{ print $2 }\u0026#39;); do p=$(echo $i | sed -e \u0026#39;s{svn://192.168.10.200/rootfs/{{\u0026#39;); mkdir -p $(dirname $p); svn export $i $p; done #获取awk .   "},{"id":3,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"读书笔记","section":"Introduction","content":"记录读书笔记，看过的书隔段时间总会忘记，总结在此，方便检索\n  深入理解计算机系统  第一章 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   "},{"id":4,"href":"/posts/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90/","title":"浮点数计算误差分析","section":"Blog","content":"版本说明 #   内容: 浮点数计算误差分析 时间: 2022/02/28 版本: V 0.1  浮点数计算误差分析 #  通过分析汇编代码，分析浮点数运行产生的误差\n测试程序 #  例子 1 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*sizeof(short)*(a); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 例子 2 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*1000*sizeof(short)* (double)(a/1000.0); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 例子1输出878800 例子2输出878799\n为何会产生差异呢，只能从汇编代码入手，一点一点分析浮点计算的过程\n例子1汇编代码 #  例子1不涉及浮点数，因此汇编代码比较简单，先通过例子1的汇编代码进行了解。\n将例子1生成汇编文件，把汇编代码分4个重要部分说明，如下\n片段1 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-stack-manage.html\nThe push instruction at the beginning of this function:\n Pushes the return address, the value contained in the lr register, onto the stack. Pushes the caller\u0026rsquo;s frame pointer, the value contained in the fp register, onto the stack. Updates the sp to show that two 32-bit values have been pushed onto the top of the stack.  The add instruction adds 4 to the value in the sp register and stores the sum in the fp register, thus setting the frame pointer for this function such that it points to the location on the stack where the frame pointer of the calling function is stored.\npush\t{fp, lr}\t; 1、返回地址保存在lr (r13) 寄存器中，将lr寄存器中的值入栈;2、将fp寄存器中的值入栈\r.save {fp, lr}\r.setfp fp, sp, #4\radd\tfp, sp, #4\t; 将sp寄存器中的值加4之后的和，保存到fp寄存器中\r.pad #16\rsub\tsp, sp, #16 .save .setfp .pad\n片段2 #  ldr\tr3, .L3\t; 将.L3处的值加载到r3寄存器中 代码中.L3处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-16]\t; 将r3寄存器中的值保存到栈fp-16的位置\rldr\tr3, [fp, #-16]\t; 将栈fp-16位置的值加载到r3寄存器中，这里为何多此一举，担心其它进程覆盖r3吗？ 片段3 #  mov\tr2, r3\t; 将r3寄存器中的值拷贝到r2寄存器中\rmov\tr3, r2\t; 将r2寄存器中的值拷贝到r3寄存器中，这里为何多此一举\rlsl\tr3, r3, #1\t; Logical shift left逻辑左移1位，相当于乘以2\radd\tr3, r3, r2\t; 将r2寄存器和r3寄存器中的值相加得到的和，保存到r3寄存器中\rlsl\tr3, r3, #2\t; Logical shift left逻辑左移2位，相当于乘以4，这里把r3寄存器中值乘以4\radd\tr3, r3, r2\t; 将r2寄存器和r3寄存器中的值相加得到的和，保存到r3寄存器中\rlsl\tr3, r3, #1\t; Logical shift left逻辑左移1位，相当于乘以2\rmov\tr2, r3\t; 将r3寄存器中的值拷贝到r2寄存器中\rmov\tr3, #0\t; 将数值0拷贝到r3寄存器中\rstrd\tr2, [fp, #-12]\t; 将r2寄存器中的值保存到栈fp-12位置\rldrd\tr2, [fp, #-12]\t; 将栈fp-12位置的值保存到r2寄存器中\rldr\tr0, .L3+4\t; 将.L3+4处的值保存到r0寄存器中，代码中.L3+4代表[%lld]\\012\\000，即为printf函数的输入参数 13 * 2 * 33800 = [ (33800 * 2 + 33800) * 4 + 33800 ] * 2\n可知数字13会被分解成 (2 + 1) * 4 + 1\n片段4 #  bl\tprintf\t; 调用printf函数\rmov\tr3, #0\rmov\tr0, r3\rsub\tsp, fp, #4\r@ sp needed\rpop\t{fp, pc}\r.L3:\r.word\t33800\r.word\t.LC0 解释1：A calling function uses the bl instruction to call a function, which places the return address in the lr (r13) register.\n解释2：So this instruction effectively pops the caller\u0026rsquo;s frame pointer off the top of the stack, back into the fp register. Then the return address is popped into the pc, and the stack pointer, sp, is updated to the new top of the stack. This acts as an epilogue to clean up the stack after performing the algorithm that is the purpose of this function.\npop {fp, pc} 例子2汇编代码 #  #include \u0026lt;stdio.h\u0026gt;int main() { \tint a = 33800; \tlong long b = 13*1000*sizeof(short)* (double)(a/1000.0); \tprintf(\u0026#34;[%lld]\\n\u0026#34;,b); } 汇编片段 #  .LC0:\r.ascii\t\u0026#34;[%lld]\\012\\000\u0026#34;\r.text\r.align\t2\r.global\tmain\r.arch armv6\r.syntax unified\r.arm\r.fpu vfp\r.type\tmain, %function .LFB0: ......\t;省略了部分\rsub\tsp, sp, #16\rldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置 对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中\rvmov\ts15, r3\t@ int\t; 将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中\rvcvt.f64.s32\td6, s15\t; 将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0)\rvldr.64\td5, .L3\t; 将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位\rvdiv.f64\td7, d6, d5\t; 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中\rvldr.64\td6, .L3+8\t; 将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736\rvmul.f64\td7, d7, d6\t; 将d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中\rvmov\tr0, r1, d7\t; 将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中\rbl\t__aeabi_d2lz\t; double to long long C-style conversion ,此时r0, r1为输入参数\rmov\tr2, r0\rmov\tr3, r1\rstrd\tr2, [fp, #-20]\rldrd\tr2, [fp, #-20]\rldr\tr0, .L3+20\rbl\tprintf\rmov\tr3, #0\rmov\tr0, r3\rsub\tsp, fp, #4\r@ sp needed\rpop\t{fp, pc}\r.L3:\r.word\t0\t;double类型1000.0的低32位\r.word\t1083129856\t;double类型1000.0的高32位\r.word\t0\t;double类型26000.0的低32位 编译时就进行了计算得到26000\r.word\t1087988736\t;double类型26000.0的高32位 编译时就进行了计算得到26000\r.word\t33800\r.word\t.LC0 运算步骤 #   将32位整型33800赋值到单精度浮点寄存器s15中 将单精度浮点寄存器s15中的值转换为双精度浮点数，保存到双精度浮点寄存器d6中(33800.0) 加载1000.0这个双精度浮点数(编译时就转换为双精度了)到双精度浮点寄存器d5中 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中 加载26000.0这个双精度浮点数(编译时就进行了计算得到26000，并转换为双精度了)到双精度浮点寄存器d6中 将d7保存的double值乘以d6保存的double值(26000.0)，得到值保存到d7双精度浮点寄存器中 将d7双精度浮点寄存器中的高32位保存到r0寄存器中，低32位保存到r1寄存器中 调用__aeabi_d2lz指令，以r0和r1中保存的浮点数为参数，将浮点数转换成long long类型  代码中的浮点数常量 #  根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：\n  (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 M表示有效数字，大于等于1，小于2。 2^E表示指数位。  对于double双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数，其中指数域称为阶码\n   高32位十进制 2位二进制表示 S e的二进制 e的十进制 E(E = e - 1023) M V     1083129856 0100 0000 1000 1111 0100 0000 0000 0000 0 100 0000 1000 1032 1032-1023=9 1.111101 1000   1087988736 0100 0000 1101 1001 0110 0100 0000 0000 0 100 0000 1101 1037 1037-1023=14 1.1001011001 26000    由上可知26000和1000.0在编译时就已经提前转换为双精度浮点数保存到.L3指定的常量区域了\ngdb调试跟踪每条指令 #  gdb基本命令 #  先从简单的gdb命令入手，参考https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb1.html#p-342\n(gdb) li\t#打印行号 (gdb) br 8\t#在第8行打一个断点 (gdb) s\t#执行到下一个断点 (gdb) print b #打印变量b Starting program: /home/pi/shared/boox/test_double1_gdb  Breakpoint 1, main () at test_double1_gdb.cpp:6 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); (gdb) li 1 #include \u0026lt;stdio.h\u0026gt; 2 int main() 3 { 4 int a = 33800; 5 //long long b = 13*1000*sizeof(short)* (double)(a/1000.0); 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); 7 long long c = b; 8 printf(\u0026#34;[%lf][%lld]\\n\u0026#34;,b,c); 9 } (gdb) br 8 Note: breakpoint 3 also set at pc 0x10508. Breakpoint 4 at 0x10508: file test_double1_gdb.cpp, line 8. (gdb) r The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/pi/shared/boox/test_double1_gdb  Breakpoint 1, main () at test_double1_gdb.cpp:6 6 double b = 13*1000*sizeof(short)* (double)(a/1000.0); (gdb) s  Breakpoint 2, main () at test_double1_gdb.cpp:7 7 long long c = b; (gdb) s  Breakpoint 3, main () at test_double1_gdb.cpp:8 8 printf(\u0026#34;[%lf][%lld]\\n\u0026#34;,b,c); (gdb) print b $6 = 878799.99999999988 (gdb) print c $7 = 878799 从上面可知浮点计算得到878799.99999999988后，再强制转换为long long丢掉了小数部分，导致最后结果为878799\n对比添加-g选项生成汇编文件 #  由下图可知，编译时添加-g选项后，并不影响真正有用的汇编代码，也不影响寄存器的使用，只是插入了一些辅助的指令而已\n gdb打印所有寄存器中的值 #  通过info all-registers命令可以打印通用寄存器、双精度浮点寄存器d0~d31、单精度浮点寄存器s0~s31的值。使用寄存器的值时，要注意字节序\n(gdb) info all-registers r0 0xd68cf 878799 r1 0x0 0 r2 0xd68cf 878799 r3 0x0 0 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x10504 0x10504 \u0026lt;main()+68\u0026gt; cpsr 0x20000010 536870928  //以下只列出了使用到的几个双精度浮点寄存器 d5 { u32 = {0x0, 0x41f00000}, u64 = 0x41f0000000000000, f32 = {0x0, 0x1e}, f64 = 0x100000000} d6 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf} d7 { u32 = {0x0, 0xd68cf}, u64 = 0xd68cf00000000, f32 = {0x0, 0x0}, f64 = 0x0}  //以下只列出了使用到的几个单精度浮点寄存器 s11 30 (raw 0x41f00000) s12 -nan(0x7fffff) (raw 0xffffffff) s13 10.676177 (raw 0x412ad19f) s14 0 (raw 0x00000000) s15 1.23145969e-39 (raw 0x000d68cf) 汇编分解 #  将例子2中的汇编指令进行指令级分解，观察每次指令操作后寄存器中值的变化，进而了解浮点运算的每一步动作。\n需要使用的gdb命令：\n参考https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error\n(gdb) display/i $pc\t#告诉gdb显示下一个汇编指令\r(gdb) si\t#执行下一条汇编指令 step instruction\r(gdb) info all-registers\t#打印通用寄存器、双精度浮点寄存器d0~d31、单精度浮点寄存器s0~s31的值 在关键位置打好断点后，先输入s，进入打断点的位置，然后重复输入si，查看每次的汇编指令，同时输入info all-registers查看每次执行一条汇编指令后，寄存器中的值。\n下面逐步分解上面例子2中对应的汇编指令执行后的寄存器状态，只分析最关键的浮点操作部分汇编\nldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置\t对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中\rvmov\ts15, r3\t@ int\t; 将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中\rvcvt.f64.s32\td6, s15\t; 将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0)\rvldr.64\td5, .L3\t; 将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位\rvdiv.f64\td7, d6, d5\t; 将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中\rvldr.64\td6, .L3+8\t; 将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736\rvmul.f64\td7, d7, d6\t; 将d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中\rvmov\tr0, r1, d7\t; 将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中\rbl\t__aeabi_d2lz\t; double to long long C-style conversion ,此时r0, r1为输入参数 1.初始寄存器状态，r3中保存的值为局布变量a的值33800 #  此时所有双精度浮点寄存器和单精度浮点寄存器的值都为0，下面故意没有展示出来，没必要展示。\nldr\tr3, .L3+16\t; 将.L3+16处的值加载到r3寄存器中 代码中.L3+16处实际的值为33800，即将33800保存到r3寄存器中\rstr\tr3, [fp, #-8]\t; 将r3寄存器中的值保存到栈fp-8的位置\t对应代码int a = 33800;将局布变量入栈\rldr\tr3, [fp, #-8]\t; 将栈fp-8位置的值加载到r3寄存器中 r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104d8 0x104d8 \u0026lt;main()+24\u0026gt; cpsr 0x60000010 1610612752 2.将r3寄存器的值(33800)拷贝到s15单精度浮点寄存器中 #  0x104d8 \u0026lt;main()+24\u0026gt;: vmov s15, r3\tr0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104dc 0x104dc \u0026lt;main()+28\u0026gt; cpsr 0x60000010 1610612752  d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0} s15 4.73638881e-41 (raw 0x00008408) 3.将s15浮点寄存器中32位单精度浮点数转换为64位双精度浮点保存到d6双精度浮点寄存器中(33800.0) #  0x104dc \u0026lt;main()+28\u0026gt;: vcvt.f64.s32 d6, s15 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e0 0x104e0 \u0026lt;main()+32\u0026gt; cpsr 0x60000010 1610612752  d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0}  s13 7.01574707 (raw 0x40e08100) s14 0 (raw 0x00000000) s15 4.73638881e-41 (raw 0x00008408) 可以看出此时d6寄存器中f64值为0x8408，代表浮点数33800.0\n4.将.L3处的值加载到d5寄存器中 .L3处前32位值为0存为double的低32位，后32位值为1083129856存为double的高32位 #  =\u0026gt; 0x104e0 \u0026lt;main()+32\u0026gt;: vldr d5, [pc, #56] ; 0x10520 \u0026lt;main()+96\u0026gt; (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e4 0x104e4 \u0026lt;main()+36\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x0, 0x8408}, u64 = 0x840800000000, f32 = {0x0, 0x0}, f64 = 0x0}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 7.01574707 (raw 0x40e08100) s14 0 (raw 0x00000000) s15 4.73638881e-41 (raw 0x00008408) 可以看出此时d5寄存器中f64值为0x3e8，代表浮点数1000.0\n5.将d6保存的double值(33800.0)除以d5保存的double值(1000.0)，得到值保存到d7双精度浮点寄存器中 #  =\u0026gt; 0x104e4 \u0026lt;main()+36\u0026gt;: vdiv.f64 d7, d6, d5 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104e8 0x104e8 \u0026lt;main()+40\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40e08100}, u64 = 0x40e0810000000000, f32 = {0x0, 0x7}, f64 = 0x8408} d7 { u32 = {0x66666666, 0x4040e666}, u64 = 0x4040e66666666666, f32 = {0xffffffff, 0x3}, f64 = 0x21}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 7.01574707 (raw 0x40e08100) s14 2.72008302e+23 (raw 0x66666666) s15 3.0140624 (raw 0x4040e666) 可以看出此时d7寄存器中f64值为0x21，代表浮点数33.0\n6.将.L3+8处的值加载到d6双精度浮点寄存器中 代码中.L3+8处前32位的值为0，后32位的值为1087988736 #  =\u0026gt; 0x104e8 \u0026lt;main()+40\u0026gt;: vldr d6, [pc, #56] ; 0x10528 \u0026lt;main()+104\u0026gt; (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104ec 0x104ec \u0026lt;main()+44\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0x66666666, 0x4040e666}, u64 = 0x4040e66666666666, f32 = {0xffffffff, 0x3}, f64 = 0x21}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 2.72008302e+23 (raw 0x66666666) s15 3.0140624 (raw 0x4040e666) 可以看出此时d6寄存器中f64值为0x6590，代表浮点数26000.0\n7.d7保存的double值乘以d6保存的double值，得到值保存到d7双精度浮点寄存器中 #  =\u0026gt; 0x104ec \u0026lt;main()+44\u0026gt;: vmul.f64 d7, d7, d6 (gdb) info all-registers r0 0x1 1 r1 0x7efff5e4 2130703844 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104f0 0x104f0 \u0026lt;main()+48\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 可以看出此时d7寄存器中f64值为0xd68cf，代表浮点数878799.0\n其中高32位为0x412ad19f，低32位为0xffffffff，见下图分解\n 8.将d7双精度浮点寄存器中的低32位的值保存到r0中，将d7双精度浮点寄存器中的高32位的值保存到r1中 #  =\u0026gt; 0x104f0 \u0026lt;main()+48\u0026gt;: vmov r0, r1, d7 (gdb) info all-registers r0 0xffffffff 4294967295 r1 0x412ad19f 1093325215 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x76e38718 1994622744 pc 0x104f4 0x104f4 \u0026lt;main()+52\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 其中r0为浮点数d7寄存器中的低32位0xffffffff，r1为浮点数d7寄存器中的高32位0x412ad19f\n9.double to long long C-style conversion ,此时r0, r1为输入参数 #  =\u0026gt; 0x104f4 \u0026lt;main()+52\u0026gt;: bl 0x10538 \u0026lt;__fixdfdi\u0026gt; (gdb) info all-registers r0 0xffffffff 4294967295 r1 0x412ad19f 1093325215 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x10538 0x10538 \u0026lt;__fixdfdi\u0026gt; cpsr 0x60000010 1610612752  d5 { u32 = {0x0, 0x408f4000}, u64 = 0x408f400000000000, f32 = {0x0, 0x4}, f64 = 0x3e8} d6 { u32 = {0x0, 0x40d96400}, u64 = 0x40d9640000000000, f32 = {0x0, 0x6}, f64 = 0x6590} d7 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf}  s11 4.4765625 (raw 0x408f4000) s12 0 (raw 0x00000000) s13 6.79345703 (raw 0x40d96400) s14 -nan(0x7fffff) (raw 0xffffffff) s15 10.676177 (raw 0x412ad19f) 10.将d7寄存器的高32位保存到r0寄存器中，将d7寄存器的低32位保存到r1寄存器中 #  从以下寄存器中的值可以看出，__fixdfdi函数执行后，将转换后的long long 值保存在了d7寄存器中，然后d7寄存器中的值转移到r0和r1，从而得到double转换为long long 的结果\r =\u0026gt; 0x10538 \u0026lt;__fixdfdi\u0026gt;: vmov d7, r0, r1 (gdb) info all-registers r0 0xd68cf 878799 r1 0x0 0 r2 0x7efff5ec 2130703852 r3 0x8408 33800 r4 0x0 0 r5 0x105a8 66984 r6 0x103d0 66512 r7 0x0 0 r8 0x0 0 r9 0x0 0 r10 0x76fff000 1996484608 r11 0x7efff494 2130703508 r12 0x7efff510 2130703632 sp 0x7efff480 0x7efff480 lr 0x104f8 66808 pc 0x104f8 0x104f8 \u0026lt;main()+56\u0026gt; cpsr 0x20000010 536870928  d5 { u32 = {0x0, 0x41f00000}, u64 = 0x41f0000000000000, f32 = {0x0, 0x1e}, f64 = 0x100000000} d6 { u32 = {0xffffffff, 0x412ad19f}, u64 = 0x412ad19fffffffff, f32 = {0x0, 0xa}, f64 = 0xd68cf} d7 { u32 = {0x0, 0xd68cf}, u64 = 0xd68cf00000000, f32 = {0x0, 0x0}, f64 = 0x0}  fpscr 0x20000010 536870928 s0 0 (raw 0x00000000) s1 0 (raw 0x00000000) s2 0 (raw 0x00000000) s3 0 (raw 0x00000000) s4 0 (raw 0x00000000) s5 0 (raw 0x00000000) s6 0 (raw 0x00000000) s7 0 (raw 0x00000000) s8 0 (raw 0x00000000) s9 0 (raw 0x00000000) s10 0 (raw 0x00000000) s11 30 (raw 0x41f00000) s12 -nan(0x7fffff) (raw 0xffffffff) s13 10.676177 (raw 0x412ad19f) s14 0 (raw 0x00000000) s15 1.23145969e-39 (raw 0x000d68cf) 总结 #  1、不要将浮点运算得到的值，用来做精确的比较后去做某事\n2、计算机中的浮点数也是用二进制表示的，不是所有浮点数都能用二进制精确的表示。\n比如0.2，二进制小数0.00110011，对应的十进制小数0.19921875\n 使用二进制表达十进制的小数时，某些数字无法被有限位的二进制小数表示； 单精度和双精度的浮点数只包括 7 位或者 15 位的有效小数位，存储需要无限位表示的小数时只能存储近似值；  参考知识 #  gcc参数 #  使用-save-temps参数产生所有的中间步骤的文件 #  -save-temps可以做4,5,6步骤的工作。通过这个参数，所有中间阶段的文件都会存储在当前文件夹中，注意它也会产生可执行文件。\n$ gcc -save-temps main.c  $ ls a.out main.c main.i main.o main.s 从例子中我们可以看到各个中间文件以及可执行文件。\n-Wl #   用来向链接器指定参数 gcc -Wl, --wrap,malloc -Wl,--wrap,free -o int1 A.o B.o 则链接器的参数会有两个 --wrap malloc --wrap free 可以看到--wrap,free 变成了--wrap free 也就是, 变成了空格\n objdump反汇编 #  pi@raspberrypi:~/shared/boox $ objdump -d test_double2.o  test_double2.o: file format elf32-littlearm   Disassembly of section .text:  00000000 \u0026lt;main\u0026gt;:  0: e92d4800 push {fp, lr}  4: e28db004 add fp, sp, #4  8: e24dd010 sub sp, sp, #16  c: e59f3048 ldr r3, [pc, #72] ; 5c \u0026lt;main+0x5c\u0026gt;  10: e50b3010 str r3, [fp, #-16]  14: e51b3010 ldr r3, [fp, #-16]  18: e1a02003 mov r2, r3  1c: e1a03002 mov r3, r2  20: e1a03083 lsl r3, r3, #1  24: e0833002 add r3, r3, r2  28: e1a03103 lsl r3, r3, #2  2c: e0833002 add r3, r3, r2  30: e1a03083 lsl r3, r3, #1  34: e1a02003 mov r2, r3  38: e3a03000 mov r3, #0  3c: e14b20fc strd r2, [fp, #-12]  40: e14b20dc ldrd r2, [fp, #-12]  44: e59f0014 ldr r0, [pc, #20] ; 60 \u0026lt;main+0x60\u0026gt;  48: ebfffffe bl 0 \u0026lt;printf\u0026gt;  4c: e3a03000 mov r3, #0  50: e1a00003 mov r0, r3  54: e24bd004 sub sp, fp, #4  58: e8bd8800 pop {fp, pc}  5c: 00008408 .word 0x00008408  60: 00000000 .word 0x00000000 nm查看符号表 #  pi@raspberrypi:~/shared/boox $ nm test_double2.o  U __aeabi_unwind_cpp_pr1 00000000 T main  U printf fp寄存器解释 #  The frame pointer ($fp) points to the start of the stack frame and does not move for the duration of the subroutine call. This points to the base of the stack frame, and the parameters that are passed in to the subroutine remain at a constant spot relative to the frame pointer.\n 寄存器用途 #  The column labeled “Restore Contents?” shows whether the function needs to ensure that the value in the register is the same when it returns to the calling function as it contained when the this function was called.\n   Register Synonym（相同） Restore Contents Purpose     r0  N argument/results   r1  N argument/results   r2  N argument/results   r3  N argument/results   r4  Y local variable   r5  Y local variable   r6  Y local variable   r7  Y local variable   r8  Y local variable   r9  Y depends on platform standard   r10  Y local variable   r11 fp Y frame pointer/local variable   r12 ip N intra-procedure-call scratch   r13 sp Y stack pointer   r14 lr N link register   r15 pc N program counter    汇编指令 #  BL #   LDR #   STR #   LSL、LSR #   VMOV #   VCVT #   VLDR #   参考https://www.codenong.com/cs106577545/\n https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-instrs-1.html#instr-ldr\n四、参考链接 #  浮点数转换 #   https://blog.csdn.net/weixin_43955216/article/details/107385732?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0\u0026spm=1001.2101.3001.4242\n汇编指令 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-stack-manage.html\ngdb调试 #   https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb1.html#p-342\n https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gdb2.html\nYou can use stepi or nexti (which can be abbreviated to si or ni) to step through your machine code.\nThe most useful thing you can do here is display/i $pc, before using stepi as already suggested in R Samuel Klatchko\u0026rsquo;s answer. This tells gdb to disassemble the current instruction just before printing the prompt each time; then you can just keep hitting Enter to repeat the stepi command.\n https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error\n"},{"id":5,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/FalconMode/","title":"FalconMode模式","section":"工程实践","content":"版本说明 #   FalconMode模式    日期 版本 修改内容     2021/11/21 V0.1 创建      FalconMode模式 #  Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel\nFalcon mode: U-Boot SPL -\u0026gt; Kernel\n https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7\nOnce you are booted up into the Linux Kernel there should be NO difference.\n 测试启动时间 #     模式 文件系统 tftp下载时间 内核到telnet时间     正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒   正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒   Falcon模式       Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK\nMulti-user refers to an Initialization Run Time Target or Run Level. This is the initialization for the OOB PLSDK.\nSingle-user refers to shell.\n官方README.falcon #   https://github.com/u-boot/u-boot/blob/master/doc/README.falcon\nFalcon Mode relies on the SPL framework. In fact, to make booting faster, U-Boot is split into two parts: the SPL (Secondary Program Loader) and U-Boot image.\nuse the \u0026ldquo;spl export\u0026rdquo; command to generate the kernel parameters area or the DT\nHowever at the end of an succesful \u0026lsquo;spl export\u0026rsquo; run it will print the RAM address of temporary storage. The RAM address of FDT will also be set in the environment variable \u0026lsquo;fdtargsaddr\u0026rsquo;, the new length of the prepared FDT will be set in the environment variable \u0026lsquo;fdtargslen\u0026rsquo;. These environment variables can be used in scripts for writing updated FDT to persistent storage.\nsetenv falcon_args_file args setenv boot_os 1 setenv spl_load_image_fat_os uImage setenv falcon_image_file uImage   https://blog.csdn.net/donglicaiju76152/article/details/77920015\nnand read 0x82000000 NAND.kernel nand read 0x88000000 NAND.u-boot-spl-os run nandargs spl export fdt 0x82000000 - 0x88000000 md \u0026lt;address\u0026gt; nand write \u0026lt;address\u0026gt; bootparms 0x4000 注意事项 #  需要使用uImage，不能使用zImage\nThe falcon mode is supported only by uImage. You should make uImage with the LOADADDR=0x80008000.\n=\u0026gt; run args_mmc =\u0026gt; run loadimage 8942296 bytes read in 610 ms (14 MiB/s) =\u0026gt; run loadfdt 58129 bytes read in 56 ms (1013.7 KiB/s) =\u0026gt; spl export fdt ${loadaddr} - ${fdtaddr}  https://e2e.ti.com/support/processors-group/processors/f/processors-forum/544446/how-to-use-falcon-mode-in-u-boot\n./mkimage -A arm -O linux -T kernel -C none -a 0x80008000 -e fdtoverlay工具使用 #  Falcon mode assumes one dtb, so you either patch your based device tree or you manually use fdtoverlay to apply the overlay to the base dtb: voodoo@hestia:~$ fdtoverlay \u0026ndash;help Usage: apply a number of overlays to a base blob fdtoverlay  [\u0026lt;overlay.dtbo\u0026gt; [\u0026lt;overlay.dtbo\u0026gt;]]  s=string,…\ndebian@beaglebone:~$ fdtoverlay --help Usage: apply a number of overlays to a base blob  fdtoverlay \u0026lt;options\u0026gt; [\u0026lt;overlay.dtbo\u0026gt; [\u0026lt;overlay.dtbo\u0026gt;]]  \u0026lt;type\u0026gt; s=string, i=int, u=unsigned, x=hex  Optional modifier prefix:  hh or b=byte, h=2 byte, l=4 byte (default)  Options: -[i:o:vhV]  -i, --input \u0026lt;arg\u0026gt; Input base DT blob  -o, --output \u0026lt;arg\u0026gt; Output DT blob  -v, --verbose Verbose messages  -h, --help Print this help and exit  -V, --version Print version and exit  #下面命令将am335x-boneblack-uboot.dtb这个基础设备树上，添加了4层设备配置节点，生成了一个新的am335x-falcon.dtb设备树 fdtoverlay -i am335x-boneblack-uboot.dtb BB-BONE-eMMC1-01-00A0.dtbo BB-HDMI-TDA998x-00A0.dtbo BB-ADC-00A0.dtbo BB-UART1-00A0.dtbo -o am335x-falcon.dtb 设备树DTB #  $ sudo apt-get install device-tree-compiler  Device trees do not need to be compiled with \u0026#34;architecture-aware\u0026#34; tools. The dtc compiler on your ubuntu machine is probably current enough to compile your device tree. Or you can download the latest source and compile it yourself. The dtc compiler can be found here:  https://git.kernel.org/pub/scm/utils/dtc/dtc.git  There are some good documents in that package that will help you better understand device trees in general.  It\u0026#39;s pretty easy to compile (and disassemble) device trees. For example  $ dtc -O dtb -o p4080ds.dtb p4080ds.dts To get the device tree in text from from the device tree blob, do this:  $ dtc -I dtb -O dts p4080ds.dtb On linux we can directly open dtb file by using fdtdump\nfdtdump dtb_file.dtb \u0026gt; /tmp/test.txt  https://elinux.org/Device_Tree_Usage\n https://elinux.org/Device_Tree_Reference\n减少启动时间 #  从硬件角度 #  1、从更快的存储设备上启动\n2、Power Management Integrated Circuits (PMIC)\n3、Processor Operating Performance Point (OPP)\nAM335x from PORz runs ROM at 600MHz OPP100 voltage.After MLO loads and runs, the processor clock and voltages are set as needed.\n从软件角度 #  uBoot阶段 #   使用Falcon模式，跳过uBoot，直接加载内核 内核命令行参数添加quiet Add loops per jiffy LPJ to the command line （在BBB板子上测试了两次，都是lpj=4980736） DisableConsole - Turn off serial console output during boot  kernel阶段 #   修改内核编译选项，减少内核大小 使用压缩的内核镜像，切换内核压缩方式到LZ4 修改设备树只开启必要的功能 选择哪一些驱动被初始化 No Probe Missing Devices - Disable probes for non-existent devices (including keyboards, etc.) Load Drivers Later - Use modules where possible to move driver initialization later in the boot sequence  rc脚本 #   减少rc脚本 延后rc脚本  用户空间 #    用户空间使用单用户，不要使用多用户模式\n  文件系统分区，将只读分区与写分区隔离\n  Avoid writes to flash memory\n  Keep writable files in RAM, and write them to flash after boot\n  Stripping your program,To get the highest savings, use \u0026ldquo;strip \u0026ndash;strip-unneeded \u0026rdquo;\n  Compiler options for program size,You can use \u0026ldquo;gcc -Os\u0026rdquo; to optimize for size.\n  LPJ值 #   https://elinux.org/Preset_LPJ\n测试了两次，都是lpj=4980736\nMay 24 14:08:04 user.info kernel: [ 0.000000] OMAP clockevent source: timer2 at 24000000 Hz May 24 14:08:04 user.info kernel: [ 0.000014] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns May 24 14:08:04 user.info kernel: [ 0.000033] clocksource: timer1: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns May 24 14:08:04 user.info kernel: [ 0.000041] OMAP clocksource: timer1 at 24000000 Hz May 24 14:08:04 user.crit kernel: [ 0.000283] timer_probe: no matching timers found May 24 14:08:04 user.info kernel: [ 0.000457] Console: colour dummy device 80x30 May 24 14:08:04 user.err kernel: [ 0.000493] WARNING: Your \u0026#39;console=ttyO0\u0026#39; has been replaced by \u0026#39;ttyS0\u0026#39; May 24 14:08:04 user.err kernel: [ 0.000499] This ensures that you still see kernel messages. Please May 24 14:08:04 user.err kernel: [ 0.000503] update your kernel commandline. May 24 14:08:04 user.info kernel: [ 0.000549] Calibrating delay loop... 996.14 BogoMIPS (lpj=4980736) May 24 14:08:04 user.info kernel: [ 0.089150] pid_max: default: 32768 minimum: 301 May 24 14:08:04 user.info kernel: [ 0.089359] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) May 24 14:08:04 user.info kernel: [ 0.089372] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) May 24 14:08:04 user.info kernel: [ 0.090211] CPU: Testing write buffer coherency: ok May 24 14:08:04 user.info kernel: [ 0.090275] CPU0: Spectre v2: using BPIALL workaround Library Optimizer Tool #   http://libraryopt.sourceforge.net/\nThe Library Optimizer Tool is used to reduce the size of shared libraries for an embedded system or other size-contrained environment.\nStatic Linking #  If your set of applications is small, sometimes it makes more sense to statically link your applications than to use shared libraries. Shared libraries by default include all symbols (functions and data structures) for the features a library provides. However, when you static link a program to a library, only the symbols that are actually referenced are linked in and included in the program.\n/proc/meminfo #   https://lwn.net/Articles/28345/\nMTD #   http://www.linux-mtd.infradead.org/faq/general.html\n http://www.linux-mtd.infradead.org/doc/ubi.html\n http://www.linux-mtd.infradead.org/faq/ubi.html\nmmap函数 #  Using mmap() instead of read() for initial application data load\nAn application may load a large amount of data when it is first initialized. This can result in a long delay as the file data is read into memory. It is possible to avoid the initial cost of this read, by using mmap() instead of read().\nInstead of loading all of the data into memory with the read system call, the file can be mapped into memory with the mmap system call. Once the data file is mapped, individual pages will be demand loaded during execution, when the application reads them. Depending on the initial working set size of the data in the file, this can result in significant time savings. (For example, if an application only initially uses 50% of the data from the file, then only 50% of the data will be read into memory from persistent storage. There is extra overhead due to the cost of page-faults incurred in loading the pages on demand. However, this page fault overhead is offset by the savings in the number of page reads (compared to the read() case).\n http://0pointer.de/blog/projects/systemd.html\nStarting more in parallel means that if we have to run something, we should not serialize its start-up (as sysvinit does), but run it all at the same time, so that the available CPU and disk IO bandwidth is maxed out, and hence the overall start-up time minimized.\nTraditionally on Unix a process that does double-forking can escape the supervision of its parent,\ntiny_fs启动日志 #  Starting kernel ...  [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 5.4.106-g023faefa70 (oe-user@oe-host) (gcc version 9.2.1 20191025 (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10))) #1 PREEMPT Mon May 24 09:04:10 UTC 2021 [ 0.000000] CPU: ARMv7 Processor [413fc082] revision 2 (ARMv7), cr=10c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache [ 0.000000] OF: fdt: Machine model: TI AM335x BeagleBone Black [ 0.000000] Memory policy: Data cache writeback [ 0.000000] efi: Getting EFI parameters from FDT: [ 0.000000] efi: UEFI not found. [ 0.000000] cma: Reserved 48 MiB at 0x9c800000 [ 0.000000] CPU: All CPU(s) started in SVC mode. [ 0.000000] AM335X ES2.1 (sgx neon) [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 129666 [ 0.000000] Kernel command line: console=ttyO0,115200n8 root=/dev/nfs rw rootfstype=ext4 rootwait fixrtc nfsroot=192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm,vers=3 ip=192.168.31.87:192.168.31.85:192.168.31.1:255.255.255.0::eth0:off [ 0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes, linear) [ 0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes, linear) [ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off [ 0.000000] Memory: 453832K/523264K available (9216K kernel code, 295K rwdata, 3092K rodata, 1024K init, 254K bss, 20280K reserved, 49152K cma-reserved, 0K highmem) [ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1 [ 0.000000] rcu: Preemptible hierarchical RCU implementation. [ 0.000000] Tasks RCU enabled. [ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies. [ 0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16 [ 0.000000] IRQ: Found an INTC at 0x(ptrval) (revision 5.0) with 128 interrupts [ 0.000000] random: get_random_bytes called from start_kernel+0x2b4/0x470 with crng_init=0 [ 0.000000] OMAP clockevent source: timer2 at 24000000 Hz [ 0.000015] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns [ 0.000033] clocksource: timer1: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns [ 0.000042] OMAP clocksource: timer1 at 24000000 Hz [ 0.000286] timer_probe: no matching timers found [ 0.000457] Console: colour dummy device 80x30 [ 0.000493] WARNING: Your \u0026#39;console=ttyO0\u0026#39; has been replaced by \u0026#39;ttyS0\u0026#39; [ 0.000498] This ensures that you still see kernel messages. Please [ 0.000502] update your kernel commandline. [ 0.000550] Calibrating delay loop... 996.14 BogoMIPS (lpj=4980736) [ 0.089147] pid_max: default: 32768 minimum: 301 [ 0.089357] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) [ 0.089369] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear) [ 0.090201] CPU: Testing write buffer coherency: ok [ 0.090268] CPU0: Spectre v2: using BPIALL workaround [ 0.091064] Setting up static identity map for 0x80100000 - 0x80100060 [ 0.091200] rcu: Hierarchical SRCU implementation. [ 0.091276] EFI services will not be available. [ 0.091648] devtmpfs: initialized [ 0.101487] VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 3 [ 0.101853] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns [ 0.101874] futex hash table entries: 256 (order: -1, 3072 bytes, linear) [ 0.105462] pinctrl core: initialized pinctrl subsystem [ 0.106218] DMI not present or invalid. [ 0.106672] NET: Registered protocol family 16 [ 0.108840] DMA: preallocated 256 KiB pool for atomic coherent allocations [ 0.132269] l3-aon-clkctrl:0000:0: failed to disable [ 0.134331] cpuidle: using governor ladder [ 0.134359] cpuidle: using governor menu [ 0.149334] No ATAGs? [ 0.149344] hw-breakpoint: debug architecture 0x4 unsupported. [ 0.164048] debugfs: Directory \u0026#39;49000000.edma\u0026#39; with parent \u0026#39;dmaengine\u0026#39; already present! [ 0.164083] edma 49000000.edma: TI EDMA DMA engine driver [ 0.165756] iommu: Default domain type: Translated [ 0.167761] SCSI subsystem initialized [ 0.168195] mc: Linux media interface: v0.10 [ 0.168239] videodev: Linux video capture interface: v2.00 [ 0.168326] pps_core: LinuxPPS API ver. 1 registered [ 0.168334] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti \u0026lt;giometti@linux.it\u0026gt; [ 0.168353] PTP clock support registered [ 0.168384] EDAC MC: Ver: 3.0.0 [ 0.169692] Advanced Linux Sound Architecture Driver Initialized. [ 0.170897] clocksource: Switched to clocksource timer1 [ 0.177850] thermal_sys: Registered thermal governor \u0026#39;fair_share\u0026#39; [ 0.177859] thermal_sys: Registered thermal governor \u0026#39;bang_bang\u0026#39; [ 0.177875] thermal_sys: Registered thermal governor \u0026#39;step_wise\u0026#39; [ 0.177881] thermal_sys: Registered thermal governor \u0026#39;user_space\u0026#39; [ 0.177886] thermal_sys: Registered thermal governor \u0026#39;power_allocator\u0026#39; [ 0.178442] NET: Registered protocol family 2 [ 0.179511] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear) [ 0.179542] TCP established hash table entries: 4096 (order: 2, 16384 bytes, linear) [ 0.179580] TCP bind hash table entries: 4096 (order: 2, 16384 bytes, linear) [ 0.179617] TCP: Hash tables configured (established 4096 bind 4096) [ 0.179730] UDP hash table entries: 256 (order: 0, 4096 bytes, linear) [ 0.179748] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear) [ 0.179909] NET: Registered protocol family 1 [ 0.180480] RPC: Registered named UNIX socket transport module. [ 0.180493] RPC: Registered udp transport module. [ 0.180498] RPC: Registered tcp transport module. [ 0.180503] RPC: Registered tcp NFSv4.1 backchannel transport module. [ 0.180518] PCI: CLS 0 bytes, default 64 [ 0.181556] hw perfevents: enabled with armv7_cortex_a8 PMU driver, 5 counters available [ 0.182739] Initialise system trusted keyrings [ 0.183094] workingset: timestamp_bits=14 max_order=17 bucket_order=3 [ 0.187549] squashfs: version 4.0 (2009/01/31) Phillip Lougher [ 0.188342] NFS: Registering the id_resolver key type [ 0.188381] Key type id_resolver registered [ 0.188388] Key type id_legacy registered [ 0.188429] ntfs: driver 2.1.32 [Flags: R/O]. [ 0.189098] Key type asymmetric registered [ 0.189113] Asymmetric key parser \u0026#39;x509\u0026#39; registered [ 0.189162] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 244) [ 0.189172] io scheduler mq-deadline registered [ 0.189179] io scheduler kyber registered [ 0.194203] OMAP GPIO hardware version 0.1 [ 0.219145] omap-mailbox 480c8000.mailbox: omap mailbox rev 0x400 [ 0.232000] pinctrl-single 44e10800.pinmux: 142 pins, size 568 [ 0.278706] Serial: 8250/16550 driver, 10 ports, IRQ sharing enabled [ 0.283028] 44e09000.serial: ttyS0 at MMIO 0x44e09000 (irq = 29, base_baud = 3000000) is a 8250 [ 0.910654] printk: console [ttyS0] enabled [ 0.917463] omap_rng 48310000.rng: Random Number Generator ver. 20 [ 0.923850] random: fast init done [ 0.927477] random: crng init done [ 0.947065] brd: module loaded [ 0.956774] loop: module loaded [ 0.964693] libphy: Fixed MDIO Bus: probed [ 1.030923] davinci_mdio 4a101000.mdio: davinci mdio revision 1.6, bus freq 1000000 [ 1.038628] libphy: 4a101000.mdio: probed [ 1.044140] davinci_mdio 4a101000.mdio: phy[0]: device 4a101000.mdio:00, driver SMSC LAN8710/LAN8720 [ 1.053556] cpsw 4a100000.ethernet: initialized cpsw ale version 1.4 [ 1.059940] cpsw 4a100000.ethernet: ALE Table size 1024 [ 1.065342] cpsw 4a100000.ethernet: cpts: overflow check period 500 (jiffies) [ 1.072635] cpsw 4a100000.ethernet: Detected MACID = 64:33:db:30:5c:a6 [ 1.081079] i2c /dev entries driver [ 1.087040] cpuidle: enable-method property \u0026#39;ti,am3352\u0026#39; found operations [ 1.094525] sdhci: Secure Digital Host Controller Interface driver [ 1.100737] sdhci: Copyright(c) Pierre Ossman [ 1.106464] omap_gpio 44e07000.gpio: Could not set line 6 debounce to 200000 microseconds (-22) [ 1.115257] omap_hsmmc 48060000.mmc: Got CD GPIO [ 1.171240] omap_hsmmc 47810000.mmc: RX DMA channel request failed [ 1.177990] sdhci-pltfm: SDHCI platform and OF driver helper [ 1.186248] ledtrig-cpu: registered to indicate activity on CPUs [ 1.196794] davinci-mcasp 48038000.mcasp: IRQ common not found [ 1.204286] NET: Registered protocol family 10 [ 1.210089] Segment Routing with IPv6 [ 1.214008] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver [ 1.220619] NET: Registered protocol family 17 [ 1.225569] Key type dns_resolver registered [ 1.230093] omap_voltage_late_init: Voltage driver support not added [ 1.237154] Loading compiled-in X.509 certificates [ 1.267316] mmc1: new high speed MMC card at address 0001 [ 1.273483] mmcblk1: mmc1:0001 M62704 3.56 GiB [ 1.278259] mmcblk1boot0: mmc1:0001 M62704 partition 1 2.00 MiB [ 1.284810] mmcblk1boot1: mmc1:0001 M62704 partition 2 2.00 MiB [ 1.291419] mmcblk1rpmb: mmc1:0001 M62704 partition 3 512 KiB, chardev (243:0) [ 1.302104] mmcblk1: p1 [ 1.311542] tps65217 0-0024: TPS65217 ID 0xe version 1.2 [ 1.453148] tda998x 0-0070: found TDA19988 [ 1.460370] tilcdc 4830e000.lcdc: bound 0-0070 (ops tda998x_ops) [ 1.466493] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013). [ 1.473148] [drm] No driver support for vblank timestamp query. [ 1.479736] [drm] Initialized tilcdc 1.0.0 20121205 for 4830e000.lcdc on minor 0 [ 1.624968] Console: switching to colour frame buffer device 240x67 [ 1.664525] tilcdc 4830e000.lcdc: fb0: tilcdcdrmfb frame buffer device [ 1.671308] omap_i2c 44e0b000.i2c: bus 0 rev0.11 at 400 kHz [ 1.678948] omap_i2c 4819c000.i2c: bus 2 rev0.11 at 100 kHz [ 1.689514] hctosys: unable to open rtc device (rtc0) [ 1.696161] cpsw 4a100000.ethernet: initializing cpsw version 1.12 (0) [ 1.801937] SMSC LAN8710/LAN8720 4a101000.mdio:00: attached PHY driver [SMSC LAN8710/LAN8720] (mii_bus:phy_addr=4a101000.mdio:00, irq=POLL) [ 3.921758] cpsw 4a100000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off [ 3.950973] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready [ 3.981089] IP-Config: Complete: [ 3.984352] device=eth0, hwaddr=64:33:db:30:5c:a6, ipaddr=192.168.31.87, mask=255.255.255.0, gw=192.168.31.1 [ 3.994813] host=192.168.31.87, domain=, nis-domain=(none) [ 4.000767] bootserver=192.168.31.85, rootserver=192.168.31.85, rootpath= [ 4.008715] ALSA device list: [ 4.011980] No soundcards found. [ 4.049139] VFS: Mounted root (nfs filesystem) on device 0:17. [ 4.055963] devtmpfs: mounted [ 4.062264] Freeing unused kernel memory: 1024K [ 4.081524] Run /sbin/init as init process INIT: version 2.96 booting "},{"id":6,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"git基本使用","section":"Git","content":"版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      Git对比SVN #   1.小步提交，互不干扰 #  并行开发过程中各开发人员可以随时多次commit代码且互不影响，最后在merage到主分支，并且能记录所有成员的所有commint记录。SVN只能大量的一次性提交到中心库。\n2.打断开发：在开发新功能过程中，突然需要你去修复一个Bug #  使用Git，你可以直接stash/commit当前改动，然后switch到主分支去修复Bug，之后在pop/switch回你原来的分支继续开发。\n3.Git分支切换-指针移动，SVN分支切换-Copy项目 #  Git支持本地无限Branches，当我们个体在本地创建多个branches用于不同目的的时候（修改，新增，探索），分支轻量化，秒创分支，创建分支满足客户定制化需求\n4.Git Tag-指针标示，SVN Tag-Copy项目 #  Git管理的项目要比SVN小得多。Git初次拉取代码的速度也远小于SVN。\n5.两级提交 #  本地创建分支开发，本地提交，需要合并时再提交到远程\n6.日志查看 #  Git本地包含了完整的日志，闪电的速度查看（并且无需网络)。SVN需要从服务拉取。\n7.安全 #  Git是分布式版本控制系统，每个用户都相当于一份备份， 管理员无需为数据备份而担心。SVN作为集中式版本控制系统，存在单点故障的风险。备份版本库的任务非常繁重。\nlinus在google的演讲感悟 链接：https://www.zhihu.com/question/19601997/answer/95363587\n 自洽的、最少依赖的个人工作得到支持。1000多人的Linux开发团队是分布在世界各地的，使用git也就不必依赖中心服务器、不必需要很少的网络。就在自己的电脑上就有完整的仓库，可以做任何版本管理，除了分享代码。SVN显然是不合适的，因为单点故障大家甚至无法提交，更加无法开分支，这是无法忍受的。 剔除害群之马很简单。如果Linus经过观察，发现有些程序员特别容易出漏子，那么封杀的办法就是不必拉取即可。实际上Linus就是这样干过。如果是SVN，就变成了撤销惹麻烦的开发者的账号或者限定他的访问范围，并且从仓库中移除麻烦的代码提交。就是说，封杀的方法在git而言，是不做某事即可，SVN是做一系列事情才可以。一正一反，大家可以体会一下。Linus喜欢前者，并且得心应手。这样的工作流程就避开了很多“政治”问题，让他的集成代码过程变得主动。 可以使用信任网络。Linux太大了，不可能完全看完补丁代码的方式来识别信任，这个Linus曾经干过，最后的结果当然是放弃。如果发现有些程序员特别优秀，他只要选择拉取他们的实现。这些程序员也只是拉取他们信任的程序员的实现。这样的信任网络是可以层次化的，因此对应于1000多人的开发者来说，这样做确实可以通过分层的信任网络达成大规模的团队协作。如果是SVN，我不知道如何做可以更好 轻量的分支开销鼓励大量被使用。对于这样的团队，为了敏捷的迭代，如果有想法就分支（这样的开发隔离想法是很有价值的），那么在svn上分支是海量的并且全局的大家互相影响，因此是要命的。而对于Git总数当然是海量，但是每个人的分支都在自己的仓库内，不会影响到他人。且分支无需连接服务器，因此是飞速的。  Git工作流 #   http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\n https://www.jianshu.com/p/5e847c12709c\n http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\nGit 作为一个源码管理系统，不可避免涉及到多人协作。\n协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。\u0026ldquo;工作流程\u0026quot;在英语里，叫做\u0026quot;workflow\u0026quot;或者\u0026quot;flow\u0026rdquo;，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。\n都采用 \u0026ldquo;功能驱动式开发\u0026rdquo;（Feature-driven development，简称FDD）。\n它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。\n   工作流 策略 缺点     Git flow 2个长期分支(master| develop)、3种短期分支(feature |hotfix |release) 经常要切换分支，非常烦人   Github flow 1个长期分支 master,发起一个 pull request（简称PR）    Gitlab flow \u0026ldquo;上游优先\u0026rdquo;（upsteam first）     对于\u0026quot;版本发布\u0026quot;的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。\n以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号。\ngit flow工作流程： #    devloper：新功能开发分支一般命名为（feature_name或feature/name）；开发人员在进行功能开发的时候，先从master 分支checkout新的feature分支（例如feature/open_activity）,分支拉取后，开发人员在当前分支开发自己的功能，开发完成后，merge feature/open_activity到 qa分支进行功能测试，经过QA测试该功能没有问题，merge feature/open_activity 到 release 分支（release 分支不能直接push代码，需要request merge,code review之后，就可以在灰度环境测试，然后上线了），到此为止新的功能已经上线完成，delete feature/open_activity分支、 merge release 分支到master 分支，并且打下tag。整个一个开发流程结束，新的需求一个轮回又开始了； bugfix:bugfix分支一般命名为（bugfix_name或bugfix/name）； bugfix 是对重大bug的修改，修改完成后，需要合并到qa分支进行测试，整个流程与 #devloper# 的流程一致； hotfix: hotfix分支一般命名为（hotfix_name或hotfix/name）； hotfix为线上代码的热更新，比如配置文件的修改或者极小的功能修改。开发人员从master 拉取hotfix/mysql_config分支，然后进行bug fix ,完成后，merger 到release分支code review之后上线。到此bug热修复完成，delete hotfix/mysql_config分支、merge release 分支到master 分支，hotfix一般不需要打tag；  Git命令 #  Git命令流程图 #      http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n一、新建代码库 #   # 在当前目录新建一个Git代码库 $ git init  # 新建一个目录，将其初始化为Git代码库 $ git init [project-name]  # 下载一个项目和它的整个代码历史 $ git clone [url]  二、配置 #  Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n # 显示当前的Git配置 $ git config --list  # 编辑Git配置文件 $ git config -e [--global]  # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34;  三、增加/删除文件 #   # 添加指定文件到暂存区 $ git add [file1] [file2] ...  # 添加指定目录到暂存区，包括子目录 $ git add [dir]  # 添加当前目录的所有文件到暂存区 $ git add .  # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p  # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ...  # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file]  # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]  四、代码提交 #   # 提交暂存区到仓库区 $ git commit -m [message]  # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message]  # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a  # 提交时显示所有diff信息 $ git commit -v  # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message]  # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ...  五、分支 #   # 列出所有本地分支 $ git branch  # 列出所有远程分支 $ git branch -r  # 列出所有本地分支和远程分支 $ git branch -a  # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name]  # 新建一个分支，并切换到该分支 $ git checkout -b [branch]  # 新建一个分支，指向指定commit $ git branch [branch] [commit]  # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch]  # 切换到指定分支，并更新工作区 $ git checkout [branch-name]  # 切换到上一个分支 $ git checkout -  # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch]  # 合并指定分支到当前分支 $ git merge [branch]  # 选择一个commit，合并进当前分支 $ git cherry-pick [commit]  # 删除分支 $ git branch -d [branch-name]  # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch]  六、标签 #   # 列出所有tag $ git tag  # 新建一个tag在当前commit $ git tag [tag]  # 新建一个tag在指定commit $ git tag [tag] [commit]  # 删除本地tag $ git tag -d [tag]  # 删除远程tag $ git push origin :refs/tags/[tagName]  # 查看tag信息 $ git show [tag]  # 提交指定tag $ git push [remote] [tag]  # 提交所有tag $ git push [remote] --tags  # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag]  七、查看信息 #   # 显示有变更的文件 $ git status  # 显示当前分支的版本历史 $ git log  # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat  # 搜索提交历史，根据关键词 $ git log -S [keyword]  # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s  # 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 $ git log [tag] HEAD --grep feature  # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file]  # 显示指定文件相关的每一次diff $ git log -p [file]  # 显示过去5次提交 $ git log -5 --pretty --oneline  # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn  # 显示指定文件是什么人在什么时间修改过 $ git blame [file]  # 显示暂存区和工作区的差异 $ git diff  # 显示暂存区和上一个commit的差异 $ git diff --cached [file]  # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD  # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch]  # 显示今天你写了多少行代码 $ git diff --shortstat \u0026#34;@{0 day ago}\u0026#34;  # 显示某次提交的元数据和内容变化 $ git show [commit]  # 显示某次提交发生变化的文件 $ git show --name-only [commit]  # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename]  # 显示当前分支的最近几次提交 $ git reflog  八、远程同步 #   # 下载远程仓库的所有变动 $ git fetch [remote]  # 显示所有远程仓库 $ git remote -v  # 显示某个远程仓库的信息 $ git remote show [remote]  # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url]  # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch]  # 上传本地指定分支到远程仓库 $ git push [remote] [branch]  # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force  # 推送所有分支到远程仓库 $ git push [remote] --all  九、撤销 #   # 恢复暂存区的指定文件到工作区 $ git checkout [file]  # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file]  # 恢复暂存区的所有文件到工作区 $ git checkout .  # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file]  # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard  # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit]  # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit]  # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit]  # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit]  # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop  十、其他 #   # 生成一个可供发布的压缩包 $ git archive  Git 使用规范流程 #   http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\n第一步：新建分支 #  首先，每次开发新功能，都应该新建一个单独的分支\n # 获取主干最新代码 $ git checkout master $ git pull  # 新建一个开发分支myfeature $ git checkout -b myfeature  第二步：提交分支commit #  分支修改后，就可以提交commit了。\n $ git add --all $ git status $ git commit --verbose  git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。\ngit status 命令，用来查看发生变动的文件。\ngit commit 命令的verbose参数，会列出 diff 的结果。\n第三步：撰写提交信息 #  提交commit时，必须给出完整扼要的提交信息，下面是一个范本。\n Present-tense summary under 50 characters  * More information about commit (under 72 characters). * More information about commit (under 72 characters).  http://project.management-system.com/ticket/123  第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。\n第四步：与主干同步 #  分支的开发过程中，要经常与主干保持同步。\n $ git fetch origin $ git rebase origin/master  第五步：合并commit #  分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。\n那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。\n $ git rebase -i origin/master  git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。\n下面采用 Tute Costa的例子，来解释怎么合并commit。\n pick 07c5abd Introduce OpenPGP and teach basic usage pick de9b1eb Fix PostChecker::Post#urls pick 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  # Rebase 8db7e8b..fa20af3 onto 8db7e8b # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out  上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。\n4个commit的下面是一大堆注释，列出可以使用的命令。\n  pick：正常选中 reword：选中，并且修改提交信息； edit：选中，rebase时会暂停，允许你修改这个commit（参考 这里） squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令   上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。\n pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls s 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。\n # This is a combination of 3 commits. # The first commit\u0026#39;s message is: Introduce OpenPGP and teach basic usage  # This is the 2nd commit message: Fix PostChecker::Post#urls  # This is the 3rd commit message: Hey kids, stop all the highlighting  如果将第三行的squash命令改成fixup命令。\n pick 07c5abd Introduce OpenPGP and teach basic usage s de9b1eb Fix PostChecker::Post#urls f 3e7ee36 Hey kids, stop all the highlighting pick fa20af3 git interactive rebase, squash, amend  运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。\n # This is a combination of 3 commits. # The first commit\u0026#39;s message is: Introduce OpenPGP and teach basic usage  # This is the 2nd commit message: Fix PostChecker::Post#urls  # This is the 3rd commit message: # Hey kids, stop all the highlighting   Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。\n $ git reset HEAD~5 $ git add . $ git commit -am \u0026#34;Here\u0026#39;s the bug fix that closes #28\u0026#34; $ git push --force  squash和fixup命令，还可以当作命令行参数使用，自动合并commit。\n $ git commit --fixup $ git rebase -i --autosquash  这个用法请参考 这篇文章，这里就不解释了。\n第六步：推送到远程仓库 #  合并commit后，就可以推送当前分支到远程仓库了。\n $ git push --force origin myfeature  git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（参见 这里）。\n第七步：发出Pull Request #  提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。\n个人总结 #  1、修改的代码每次提交commit后，这个commit就像组装好的零件，在之后可以进行任意拼装或拆分\n2、大胆创建、修改分支，随意commit，不用关心冲突问题，所有的修改全部上传自己独有的临时分支，commit原则：一个功能、一个模块、一个子缺陷上传，不用在乎commit数量的多少，主要是为了之后回滚方便\n3、还有很多强大的高级功能需要慢慢探索，最好是遇到需求再去搜索能否用git实现\n"},{"id":7,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/","title":"工程实践","section":"Introduction","content":"Introduction #  #    FalconMode模式  版本说明 # FalconMode模式 日期 版本 修改内容 2021/11/21 V0.1 创建 FalconMode模式 # Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel Falcon mode: U-Boot SPL -\u0026gt; Kernel https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7 Once you are booted up into the Linux Kernel there should be NO difference. 测试启动时间 # 模式 文件系统 tftp下载时间 内核到telnet时间 正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒 正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒 Falcon模式 Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK   BBB板使用NFS挂载文件系统  版本说明 # BBB板使用NFS挂载文件系统 日期 版本 修改内容 2022/03/03 V0.1 创建 将TI SDK中提供的文件系统目录NFS导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.   "},{"id":8,"href":"/docs/Linux-World/Ubuntu/%E7%9B%AE%E5%BD%95%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE/","title":"目录共享配置","section":"Ubuntu","content":"Samba配置 #  samba配置后，仍然无法访问 #   https://blog.csdn.net/Panda_YinLP/article/details/104687438\n访问window共享目录 #  sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 #   https://linuxhint.com/install_tftp_server_ubuntu/\n https://download.samba.org/pub/samba/\nNFS挂载 #   https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04\n将文件系统目录导出 #  解压文件系统\ncd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/targetNFS 测试NFS目录是否成功\n3B-pi@raspberrypi:~ $ sudo mkdir /mnt/tisdk-default-image-am335x-evm ;sudo mount -t nfs 192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm /mnt/tisdk-default-image-am335x-evm -o nolock Automatically Mounting NFS File Systems with /etc/fstab #   https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-18-04\nOn the Host #  On the host server, install the nfs-kernel-server package, which will allow you to share your directories. Since this is the first operation that you’re performing with apt in this session, refresh your local package index before the installation:\nsudo apt update sudo apt install nfs-kernel-server Once these packages are installed, switch to the client server.\nOn the Client #  On the client server, we need to install a package called nfs-common, which provides NFS functionality without including any server components. Again, refresh the local package index prior to installation to ensure that you have up-to-date information:\nsudo apt update sudo apt install nfs-common sudo systemctl restart nfs-kernel-server sudo mount -t nfs 192.168.31.87:/home/debian /mnt/bbb/ -o nolock sudo mount -t nfs 192.168.31.115:/home/pi/Public /mnt/rpi4/ -o nolock sudo mkdir /mnt/ubuntu1604;sudo mount -t nfs 192.168.31.85:/home/qq/Public/ /mnt/ubuntu1604 -o nolock 修改/etc/fstab #  # \u0026lt;file system\u0026gt; \u0026lt;dir\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt;\t\u0026lt;pass\u0026gt; 10.10.0.10:/backups /var/backups nfs defaults 0 0 "},{"id":9,"href":"/docs/Linux-World/Ubuntu/%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E5%92%8C%E8%AF%81%E4%B9%A6/","title":"系统代理和证书","section":"Ubuntu","content":"透明代理 #   https://blog.a1253247.info/2020/01/shadowsocks.html\n代理转换 #  /etc/polipo/config\n/etc/polipo/config  systemctl status polipo  www.codevoila.com/post/16/convert-socks-proxy-to-http-proxy-using-polipo\n测试网速 #  # Server tankywoo@gentoo-local::~/ » iperf -s ------------------------------------------------------------ Server listening on TCP port 5001 TCP window size: 85.3 KByte (default) ------------------------------------------------------------ [ 4] local 127.0.0.1 port 5001 connected with 127.0.0.1 port 56071 [ ID] Interval Transfer Bandwidth [ 4] 0.0-10.0 sec 27.0 GBytes 23.2 Gbits/sec  # Client tankywoo@gentoo-local::~/ » iperf -c localhost ------------------------------------------------------------ Client connecting to localhost, TCP port 5001 TCP window size: 647 KByte (default) ------------------------------------------------------------ [ 3] local 127.0.0.1 port 56071 connected with 127.0.0.1 port 5001 [ ID] Interval Transfer Bandwidth [ 3] 0.0-10.0 sec 27.0 GBytes 23.2 Gbits/sec 由于没有公钥，无法验证下列签名： #  apt updtate 时提示错误 NO_PUBKEY 648ACFD622F3D138 NO_PUBKEY 0E98404D386FA1D9\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0E98404D386FA1D9 server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none #  touch /etc/apt/apt.conf.d/99verify-peer.conf \u0026amp;\u0026amp; echo \u0026gt;\u0026gt;/etc/apt/apt.conf.d/99verify-peer.conf \u0026#34;Acquire { https::Verify-Peer false }\u0026#34; "},{"id":10,"href":"/docs/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/BBB%E6%9D%BF%E4%BD%BF%E7%94%A8NFS%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"BBB板使用NFS挂载文件系统","section":"工程实践","content":"版本说明 #   BBB板使用NFS挂载文件系统    日期 版本 修改内容     2022/03/03 V0.1 创建      将TI SDK中提供的文件系统目录NFS导出 #  解压文件系统\ncd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 #  $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 #  $ sudo exportfs -a 查看NFS导出列表 #  #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm * /usr/local/ti-sdk-am335x-evm-07.03.00.005/targetNFS 测试NFS目录是否成功\n3B-pi@raspberrypi:~ $ sudo mkdir /mnt/tisdk-default-image-am335x-evm ; 3B-pi@raspberrypi:~ $ sudo mount -t nfs 192.168.31.85:/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm /mnt/tisdk-default-image-am335x-evm -o nolock NFS方式启动BBB #  上电后，按下SPACE键，进入uboot提示界面\n分析uboot的nfsboot环境变量 #  nfs_options=,vers=3 nfsrootfstype=ext4 rootwait fixrtc root_dir=/home/userid/targetNFS #主机文件系统目录 server_ip=192.168.1.100\t#tftp服务器地址，即主机地址 bootfile=zImage\t#通过tftp从服务器下载的内核文件名 fdtfile=undefined\t#通过tftp从服务器下载的设备树文件名  nfsargs=setenv bootargs console=${console} ${optargs} ${cape_disable} ${cape_enable} ${cape_uboot} root=/dev/nfs rw rootfstype=${nfsrootfstype} nfsroot=${nfsroot} ip=${ip} ${cmdline} nfsboot=echo Booting from ${server_ip} ...; setenv nfsroot ${server_ip}:${root_dir}${nfs_options}; setenv ip ${client_ip}:${server_ip}:${gw_ip}:${netmask}:${hostname}:${device}:${autoconf}; setenv autoload no; setenv serverip ${server_ip}; setenv ipaddr ${client_ip}; tftp ${loadaddr} ${tftp_dir}${bootfile}; tftp ${fdtaddr} ${tftp_dir}dtbs/${fdtfile}; run nfsargs; bootz ${loadaddr} - ${fdtaddr} 准备内核镜像文件 #  通过bootfile环境变量指定了内核镜像文件名为zImage，而TI SDK中提供的内核镜像名为zImage-am335x-evm.bin，这里干脆拷贝一份\ncp tftpboot/zImage-am335x-evm.bin tftpboot/zImage 设置uboot环境变量 #  **特别注意：**由于默认的nfsboot环境变量，tftp下载设备树时，会从tftp服务目录之下的dtbs目录下载设备树，例如服务器的tftp目录为/home/qq/tftpboot，它会从/home/qq/tftpboot/dtbs/目录下，下载am335x-boneblack.dtb文件\ncd tftpboot mkdir dtbs cp am335x-boneblack.dtb dtbs/ setenv client_ip 192.168.31.87 setenv ipaddr 192.168.31.87 setenv gw_ip 192.168.31.1 setenv server_ip 192.168.31.85 setenv fdtfile am335x-boneblack.dtb setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm_manual_hplip setenv root_dir /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-base-image-am335x-evm_debug_hplip_cups 启动NFS文件系统 #  ==\u0026gt; run nfsboot qtcreator配置交叉编译工具 #  安装qtcreator #  sudo apt install qtcreator 设置编译工具 #   ![qt-build_run-Qt Versions-1](/images/BBB板使用NFS挂载文件系统/qt-build_run-Qt Versions-1.png)\n   遇到问题 #  不能解析qt工程，运行时报错如下 #  /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(39): system(execute) requires one or two arguments. Project ERROR: Cannot run compiler \u0026#39;arm-none-linux-gnueabihf-g++ --sysroot=/usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/armv7at2hf-neon-linux-gnueabi\u0026#39;. Output: =================== =================== Maybe you forgot to setup the environment? /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(85): Variable QMAKE_CXX.COMPILER_MACROS is not defined. /usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/x86_64-arago-linux/mkspecs/features/toolchain.prf(210): system(execute) requires one or two arguments. Project ERROR: Cannot run compiler \u0026#39;arm-none-linux-gnueabihf-g++ --sysroot=/usr/local/ti-sdk-am335x-evm-07.03.00.005/linux-devkit/sysroots/armv7at2hf-neon-linux-gnueabi\u0026#39;. Output: =================== =================== Maybe you forgot to setup the environment? Error while parsing file /home/qq/qt_project/test_tisdk/test_tisdk.pro. Giving up. 解决办法\n https://doc-snapshots.qt.io/qtcreator-4.0/creator-build-settings.html#batch-editing\n将执行source之后的PATH变量保存到qtcreator\u0026ndash;\u0026gt;Options\u0026ndash;\u0026gt;build\u0026amp;run \u0026ndash;\u0026gt;kits \u0026ndash;\u0026gt;Environment中\n![build\u0026amp;run kits Environment-1](/images/BBB板使用NFS挂载文件系统/build\u0026amp;run kits Environment-1.png)\n运行时错误 #  Failed to create wl_display (No such file or directory) qt.qpa.plugin: Could not load the Qt platform plugin \u0026#34;wayland\u0026#34; in \u0026#34;\u0026#34; even though it was found. This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  sh: line 1: 2516 Aborted (core dumped) DISPLAY=\u0026#39;:0.0\u0026#39; /home/debian/test_tisdk Application finished with exit code 134. 解决办法\n使用vnc方式运行，添加运行时参数-platform vnc\n wayland测试 #   https://forum.qt.io/topic/60865/qt5-wayland-gui-application/3\nmkdir -p /tmp/$USER-weston chmod 0700 /tmp/$USER-weston export XDG_RUNTIME_DIR=/tmp/$USER-weston weston --tty=1 --backend=fbdev-backend.so \u0026amp;  Then I successfully ran my QT5 gui application with the wayland platform specifier:  ./myQt5App -platform wayland  https://stackoverflow.com/questions/49851562/qt-wayland-failed-to-create-display-no-such-file-or-directory\nI finally fixed this by deploying the libs needed by wayland-egl plugin:\nthe lib \u0026ldquo;libQt5WaylandClient.so.5\u0026rdquo; should be included in the deployed package. which used by the plugin.\nroot@am335x-evm:~# weston Date: 2021-05-24 UTC [08:59:53.616] weston 8.0.0  https://wayland.freedesktop.org  Bug reports to: https://gitlab.freedesktop.org/wayland/weston/issues/  Build: 8.0.0 [08:59:53.619] Command line: weston [08:59:53.619] OS: Linux, 5.4.106-g023faefa70, #1 PREEMPT Mon May 24 09:04:10 UTC 2021, armv7l [08:59:53.620] warning: XDG_RUNTIME_DIR \u0026#34;/tmp/root-weston\u0026#34; is not configured correctly. Unix access mode must be 0700 (current mode is 755), and must be owned by the user (current owner is UID 0). Refer to your distribution on how to get it, or http://www.freedesktop.org/wiki/Specifications/basedir-spec on how to implement it. [08:59:53.623] Using config file \u0026#39;/etc//weston.ini\u0026#39; [08:59:53.628] Output repaint window is 7 ms maximum. [08:59:53.631] Loading module \u0026#39;/usr/lib/libweston-8/x11-backend.so\u0026#39; [08:59:53.632] Failed to load module: /usr/lib/libweston-8/x11-backend.so: cannot open shared object file: No such file or directory [08:59:53.632] fatal: failed to create compositor backend root@am335x-evm:~# eglinfo -sh: eglinfo: command not found root@am335x-evm:~# modinfo pvrsrvkm filename: /lib/modules/5.4.106-g023faefa70/extra/pvrsrvkm.ko license: Dual MIT/GPL author: Imagination Technologies Ltd. \u0026lt;gpl-support@imgtec.com\u0026gt; license: Dual MIT/GPL author: Imagination Technologies Ltd. \u0026lt;gpl-support@imgtec.com\u0026gt; srcversion: 533BB7E5866E52F63B9ACCB alias: of:N*T*Cti,omap4-sgx540-120C* alias: of:N*T*Cti,omap4-sgx540-120 alias: of:N*T*Cti,omap3-sgx530-121C* alias: of:N*T*Cti,omap3-sgx530-121 alias: of:N*T*Cti,am3352-sgx530C* alias: of:N*T*Cti,am3352-sgx530 alias: of:N*T*Cti,am4376-sgx530C* alias: of:N*T*Cti,am4376-sgx530 alias: of:N*T*Cti,dra7-sgx544C* alias: of:N*T*Cti,dra7-sgx544 alias: of:N*T*Cti,am654-sgx544C* alias: of:N*T*Cti,am654-sgx544 depends: name: pvrsrvkm vermagic: 5.4.106-g023faefa70 preempt mod_unload modversions ARMv7 p2v8 parm: gPVRDebugLevel:Sets the level of debug output (default 0x7) (uint) root@am335x-evm:~# lsmod Module Size Used by xfrm_user 32768 2 xfrm_algo 16384 1 xfrm_user sha512_generic 20480 0 sha512_arm 24576 0 sha256_generic 16384 0 libsha256 20480 1 sha256_generic sha1_generic 16384 0 sha1_arm_neon 20480 0 sha1_arm 16384 1 sha1_arm_neon md5 16384 0 ecb 16384 0 aes_arm 16384 0 aes_generic 40960 1 aes_arm aes_arm_bs 24576 0 crypto_simd 16384 1 aes_arm_bs cryptd 24576 1 crypto_simd des_generic 16384 0 libdes 28672 1 des_generic cbc 16384 0 pru_rproc 24576 0 icss_iep 20480 0 irq_pruss_intc 16384 1 pru_rproc prueth_ecap 16384 0 musb_dsps 20480 0 musb_hdrc 106496 1 musb_dsps udc_core 28672 1 musb_hdrc phy_am335x 16384 2 usbcore 225280 1 musb_hdrc phy_generic 16384 1 phy_am335x usb_common 16384 5 phy_am335x,udc_core,musb_hdrc,musb_dsps,usbcore phy_am335x_control 16384 1 phy_am335x pruss 16384 1 pru_rproc pvrsrvkm 405504 0 pm33xx 16384 0 omap_aes_driver 24576 0 crypto_engine 16384 1 omap_aes_driver omap_crypto 16384 1 omap_aes_driver libaes 16384 4 omap_aes_driver,aes_arm_bs,aes_arm,aes_generic ti_emif_sram 16384 1 pm33xx omap_sham 32768 0 wkup_m3_ipc 16384 1 pm33xx at24 20480 0 rtc_omap 20480 4 pm33xx omap_wdt 16384 0 wkup_m3_rproc 16384 1 musb_am335x 16384 0 sch_fq_codel 20480 1 uio_module_drv 16384 0 uio 20480 1 uio_module_drv cryptodev 53248 1 libicu-dev is already the newest version (57.1-4).\rlibicu-dev set to manually installed. 运行程序\n./application -platform wayland 或者 export QT_QPA_PLATFORM=wayland ./application  https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1164/handouts/qt-creator-troubleshooting.html\n测试各种模式，除了vnc模式和offscreen，其它都运行失败\nroot@am335x-evm:/home/debian# ./test_tisdk -platform vnc QVncServer created on port 5900 ^C root@am335x-evm:/home/debian# ^C root@am335x-evm:/home/debian# ./test_tisdk -platform xcb qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;xcb\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform linuxfb Unable to figure out framebuffer device. Specify it manually. linuxfb: Failed to initialize screen qt.qpa.input: xkbcommon not available, not performing key mapping no screens available, assuming 24-bit color Cannot create window: no screens available Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform eglfs MESA-LOADER: failed to open kms_swrast (search paths /usr/lib/dri) failed to load driver: kms_swrast MESA-LOADER: failed to open swrast (search paths /usr/lib/dri) failed to load swrast driver Could not create GBM device (No such device) Could not open DRM device Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform minimalegl Opened display 0x311a0  Could not initialize egl display  EGL error Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform waylang-egl qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;waylang-egl\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform waylang qt.qpa.plugin: Could not find the Qt platform plugin \u0026#34;waylang\u0026#34; in \u0026#34;\u0026#34; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, wayland-egl, wayland.  Aborted (core dumped) root@am335x-evm:/home/debian# ./test_tisdk -platform offscreen This plugin does not support propagateSizeHints() uboot启动分析 #  命令说明 #  =\u0026gt; gpio -h gpio - query and control gpio pins  Usage: gpio \u0026lt;input|set|clear|toggle\u0026gt; \u0026lt;pin\u0026gt;  - input/set/clear/toggle the specified pin gpio status [-a] [\u0026lt;bank\u0026gt; | \u0026lt;pin\u0026gt;] - show [all/claimed] GPIOs test -n 字符串\t字符串的长度不为零则为真 test -e 文件名\t如果文件存在则为真 以下为uboot环境变量中boot的值 #  从打印日志可以看出，boot值为启动时执行的第一个命令\nboot=${devtype} dev ${mmcdev} if ${devtype} rescan; then  gpio set 54  setenv bootpart ${mmcdev}:1  if test -e ${devtype} ${bootpart} /etc/fstab; then setenv mmcpart 1; fi  echo Checking for: /uEnv.txt ...  if test -e ${devtype} ${bootpart} /uEnv.txt; then  if run loadbootenv; then  gpio set 55  echo Loaded environment from /uEnv.txt  run importbootenv  fi  echo Checking if uenvcmd is set ...  if test -n ${uenvcmd}; then  gpio set 56  echo Running uenvcmd ...  run uenvcmd  fi  echo Checking if client_ip is set ...  if test -n ${client_ip}; then  if test -n ${dtb}; then  setenv fdtfile ${dtb}  echo using ${fdtfile} ...  fi  gpio set 56  if test -n ${uname_r}; then  echo Running nfsboot_uname_r ...  run nfsboot_uname_r  fi  echo Running nfsboot ...  run nfsboot  fi  fi  echo Checking for: /${script} ...  if test -e ${devtype} ${bootpart} /${script}; then  gpio set 55  setenv scriptfile ${script}  run loadbootscript  echo Loaded script from ${scriptfile}  gpio set 56  run bootscript  fi  echo Checking for: /boot/${script} ...  if test -e ${devtype} ${bootpart} /boot/${script}; then  gpio set 55  setenv scriptfile /boot/${script}  run loadbootscript  echo Loaded script from ${scriptfile}  gpio set 56  run bootscript  fi  echo Checking for: /boot/uEnv.txt ...  for i in 1 2 3 4 5 6 7; do  setenv mmcpart ${i}  setenv bootpart ${mmcdev}:${mmcpart}  if test -e ${devtype} ${bootpart} /boot/uEnv.txt; then  gpio set 55  load ${devtype} ${bootpart} ${loadaddr} /boot/uEnv.txt  env import -t ${loadaddr} ${filesize}  echo Loaded environment from /boot/uEnv.txt  if test -n ${dtb}; then  echo debug: [dtb=${dtb}] ...  setenv fdtfile ${dtb}  echo Using: dtb=${fdtfile} ...  fi  echo Checking if uname_r is set in /boot/uEnv.txt...  if test -n ${uname_r}; then  gpio set 56  setenv oldroot /dev/mmcblk${mmcdev}p${mmcpart}  echo Running uname_boot ...  run uname_boot  fi  fi  done fi 设置默认NFS启动 #  从上面脚本可以得知，想要每次直接进行NFS挂载，需要在根目录下，存在uEnv.tx文件，且uEnv.txt中包含client_ip变量，如下即可，之后每次都会先检查eMMC中的根目录的uEnv.txt，判断是否需要NFS启动了\n#uname_r=4.19.94-ti-r42 client_ip=192.168.31.87 gw_ip=192.168.31.1 server_ip=192.168.31.85 dtb=am335x-boneblack.dtb root_dir=/usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-tiny-image-am335x-evm 下面为uboot日志\ngpio: pin 56 (gpio 56) value is 0 gpio: pin 55 (gpio 55) value is 0 gpio: pin 54 (gpio 54) value is 0 gpio: pin 53 (gpio 53) value is 1 Card did not respond to voltage select! Card did not respond to voltage select! switch to partitions #0, OK mmc1(part 0) is current device Scanning mmc 1:1... gpio: pin 56 (gpio 56) value is 0 gpio: pin 55 (gpio 55) value is 0 gpio: pin 54 (gpio 54) value is 0 gpio: pin 53 (gpio 53) value is 1 switch to partitions #0, OK mmc1(part 0) is current device gpio: pin 54 (gpio 54) value is 1 Checking for: /uEnv.txt ... Checking for: /boot.scr ... Checking for: /boot/boot.scr ... Checking for: /boot/uEnv.txt ... gpio: pin 55 (gpio 55) value is 1 "},{"id":11,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/git%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/","title":"git高级使用","section":"Git","content":"版本说明 #   git基本使用    日期 版本 修改内容     2021/02/19 V0.3 创建      个人使用总结 #  Merge节点 #  Git有两种合并：一种是\u0026quot;直进式合并\u0026quot;（fast forward），不生成单独的合并节点；另一种是\u0026quot;非直进式合并\u0026quot;（none fast-forword），会生成单独节点。\n前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用--no-ff参数）。只要发生合并，就要有一个单独的合并节点。\n push策略 #  不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n$ git config --global push.default matching # 或者 $ git config --global push.default simple 解决merge 和 rebase 合并冲突 #  #merge 和 rebase 对于 ours 和 theirs 的定义是完全相反的。在 merge 时，ours 指代的是当前分支，theirs 代表需要被合并的分支。而在 rebase 过程中，ours 指向了修改参考分支，theirs 却是当前分支 git checkout --ours src/MyFile.cs. git checkout --theirs src/MyFile.cs  git checkout HEAD -- src/MyFile.cs git checkout my_branch -- src/MyFile.cs git checkout 6a363d8 -- src/MyFile.cs  revert 、rebase 、cherry-pick后面都可以跟 \u0026ndash;continue \u0026ndash;skip \u0026ndash;abort\n cherry-pick使用 #  cherry-pick (somebody/something) to choose the best people or things from a group and leave those that are not so good\n#62ecb3为分支上的commit git cherry-pick 62ecb3  #合并多个commit git cherry-pick A B C D E F  #会把从从版本A（不包含）到B（包含）即（A，B]的版本pull到当前分支 git cherry-pick A..B git cherry-pick A..B C..D E..F  git cherry-pick --continue git cherry-pick --quit git cherry-pick --abort 打标记： #  #默认给当前分支的HEAD打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34;  #给指定分支的HEAD打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34; dev_new_feature  #给指定的commit_id打标记 git tag -a v1.0.23.39 -m \u0026#34;release:v1.0.1\u0026#34; a2701a9  #上传标记 git push origin tag_name,例如： git push origin v1.0.1  #上传所有标记 git push origin --tags 删除文件 #  配合.gitignore文件\n#删除 untracked files  git clean -f  #连 untracked 的目录也一起删掉  git clean -fd  #连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）  git clean -xfd  #在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删  git clean -nxfd  git clean -nf  git clean -nfd 《pro git》总结 #  #查看已经暂存起来的变化 git diff --cached  #重新提交，合并到上一次提交 git commit –amend  #如果要一次推送所有本地新增的标签上去，可以使用 --tags 选项 git push origin --tags  #若要查看各个分支最后一个提交对象的信息，运行 git branch -v  #查看哪些分支已被并入当前分支 git branch –merged  #查看尚未合并的工作 git branch --no-merged  #查看master到contrib之间的所有差异提交 git diff master...contrib  #在 git log 后加 -p 选项将展示每次提交的内容差异。  #查看简报 git shortlog --no-merges master --not v1.0.1  #如果你想查找所有从refA 或refB 包含的但是不被refC 包含的提交 git log refA refB ^refC  #提交时将差异分块添加 git add -p 或者git add –patch  #储藏（Stashing） git stash git stash list git stash apply stash@{2} git stash apply --index git stash pop git stash clear  #查看历史提交记录，被删除后不在分支上的commit也能在这里找到 git reflog  #垃圾回收 git fsck --full SVN迁移到Git #   https://blog.axosoft.com/migrating-git-svn/\n https://git-scm.com/book/en/v2/Git-and-Other-Systems-Migrating-to-Git\n安装工具\nsudo apt-get install git-svn Git其它用途 #  格式化代码 #   https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks\n使用了git提供的hook pre-commit\n#!/bin/bash array=`git diff-index --name-only HEAD`  for name in ${array} do  extension=${name##*.}  if [[ ${extension} == \u0026#34;h\u0026#34; || ${extension} == \u0026#34;cpp\u0026#34; || ${extension} == \u0026#34;c\u0026#34; ]]  then # echo \u0026#34;###astyle###\u0026#34;$name  if [ -f ${name} ]; then  #去掉window下的^M  # fromdos ${name}  #去掉文件头中的BOM标记  sed -i \u0026#39;1s/^\\xEF\\xBB\\xBF//\u0026#39; ${name}  #格式化代码  astyle --style=ansi -s4 -S -N -L -m0 -M40 -f -U -k1 -W1 -j -xL -n ${name}  fi  git add ${name}  fi done 创建提交hook软链接文件 chmod +x pre-commit.sh cd .git/hooks/ ln -s ../../pre-commit.sh pre-commit\n通过git-web提供的hook发送邮件 #  原理：\n1、当有push event时就触发web hook，发送事件信息到指定的服务端\n2、服务端接收到事件，解析事件，构造html页\n3、使用smtp将html以邮件发送\n root@7f438265e3c9:/home/root# cat web_hook_server.py  #-*- coding:utf-8 -*- import BaseHTTPServer import SocketServer import CGIHTTPServer import logging import json import urllib import urlparse from urlparse import unquote import send_notify  class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):  \u0026#39;\u0026#39;\u0026#39;处理请求并返回页面\u0026#39;\u0026#39;\u0026#39;  def do_POST(self):  logging.debug(\u0026#39;POST %s\u0026#39; % (self.path))  print( \u0026#34;incomming http: \u0026#34;, self.path )   content_length = int(self.headers[\u0026#39;Content-Length\u0026#39;]) # \u0026lt;--- Gets the size of data  post_data = self.rfile.read(content_length) # \u0026lt;--- Gets the data itself  #将URL编码方式的字符转换为普通字符串  js_str = urllib.unquote(post_data[8:])  send_notify.sendNotify(js_str)  self.send_response(200)  if __name__ == \u0026#39;__main__\u0026#39;:  serverAddress = (\u0026#39;\u0026#39;, 5410)  SocketServer.TCPServer.allow_reuse_address = True  server = SocketServer.TCPServer(serverAddress, RequestHandler)  server.serve_forever() 解决xls文件在git比较差异 #   https://stackoverflow.com/questions/17083502/how-to-perform-better-document-version-control-on-excel-files-and-sql-schema-fil\n https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#Binary-Files\n https://gitlab.inria.fr/sgilles/homepage/-/wikis/enable-diffing-of-excel-files-with-git\n通过指定不同格式的文件读取工具，将工具的输出进行对比\n# -*- coding: utf-8 -*-  #!/usr/bin/env python  import sys from mmap import mmap,ACCESS_READ from xlrd import open_workbook # http://www.python-excel.org/ # 使得 sys.getdefaultencoding() 的值为 \u0026#39;utf-8\u0026#39;  reload(sys) # reload 才能调用 setdefaultencoding 方法  sys.setdefaultencoding(\u0026#39;utf-8\u0026#39;) # 设置 \u0026#39;utf-8\u0026#39;   file_name=sys.argv[1]  wb = open_workbook(file_name)  s = wb.sheets()[0]  r_count = s.nrows c_count = s.ncols  for row in range(r_count):  for col in range(c_count):  print (\u0026#34;row[%4d],col[%4d],value[%s]\u0026#34; % (row,col,s.cell(row, col).value))  continue  sys.stdout.write(\u0026#39;\\n\u0026#39;) 制作补丁包 #  将发布的二进制包用git管理之后，可以用git命令导出，两个版本之前的删除、新增和修改文件列表\ngit diff\n--name-status Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean.  --diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]] Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.  Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled. 获取删除文件列表\ngit diff --diff-filter=D --name-only 05e0ccf fd48e04 opt/ 获取新增和修改文件列表，并拷贝到输出目录output_dir\ngit diff old_commit new_commit --diff-filter=AM --name-only |xargs -t -i{} cp --parents -d {} output_dir cp选项说明\n--parents use full source file name under DIRECTORY #copies the file a/b/c to existing_dir/a/b/c, creating any missing intermediate directories. #即，当被复制的源文件路径包含子目录名，--parent 选项会在目标目录下自动创建不存在的子目录。目标目录本身必须已经存在。 cp --parents a/b/c existing_dir  -d same as --no-dereference --preserve=links #当拷贝软链接时，如果不添加-d选项，则会拷贝软链接对应的文件，加了-d选项后，则直接拷贝这个软链接 mantis plugin集成（未实现） #  作用：\n开发人员执行commit时，当日志信息中包含Fix #xxxx等信息时，mantis中对应的缺陷会自动修改状态为已修正，已解决，并将日志信息添加到mantis中。减少了开发人员工作量，方便缺陷与代码的跟踪\n https://github.com/mantisbt-plugins/source-integration/blob/master/SourceGitlab/README.md\n https://noswap.com/blog/integrating-git-svn-with-mantisbt\n   使用Git管理WIKI（未实现） #  gollum \u0026ndash; A git-based Wikihttps://github.com/gollum/gollum\ngitlab集成了gollum工具\n作用：记录项目迭代中的所有文档，集中管理\nCI和CD（未实现） #  CI 持续集成（Continuous Integration）\nCD 持续交付（Continuous Delivery）\nCD 持续部署（Continuous Deployment）\n https://www.redhat.com/zh/topics/devops/what-is-ci-cd\n 对于iMAC项目的应用场景：\n实现代码提交后，执行编译、打包、FTP上传发布\ngit生成patch #  3B-pi@raspberrypi:~/Public/Qin-master/patch $ git lg * 92770dd - (HEAD -\u0026gt; master, origin/master) style:change handle_Default(int keyId) to handle_Default(int unicode, int keyId) =\u0026gt; QinIMTables.h (9 hours ago) \u0026lt;author2\u0026gt; * c8a0e5a - style:格式化代码 (10 hours ago) \u0026lt;author1\u0026gt; * f281c86 - fix:完善五笔和仓颉的翻页功能 (10 hours ago) \u0026lt;author2\u0026gt; * 5e8aecf - style:删除无用文件 (10 hours ago) \u0026lt;author2\u0026gt; * b807285 - feat: 增加仓颉和五笔输入法 (10 hours ago) \u0026lt;author2\u0026gt; * 09d81b2 - style:将TableIM(无虾米)从IMBase中分离出来 (10 hours ago) \u0026lt;author2\u0026gt; * 05657a6 - fix:shift三种状态的转换 (10 hours ago) \u0026lt;author2\u0026gt; * 1ddf8ed - feat:谷歌拼音输入法实现用户自定义造词逻辑 (11 hours ago) \u0026lt;author1\u0026gt; * a94fece - feat:谷歌拼音完成选择候选词上屏 (14 hours ago) \u0026lt;author1\u0026gt; * ff34572 - feat:谷歌拼音增加候选词翻页 (14 hours ago) \u0026lt;author1\u0026gt; * 1fdcf02 - fix:修改UI文件中指定的字母按键键值 (32 hours ago) \u0026lt;author1\u0026gt; * 3c86422 - fix:完善谷歌拼音输入法 (32 hours ago) \u0026lt;author1\u0026gt; * d710041 - feat:候选增加左右按钮完成翻页功能 (7 days ago) \u0026lt;author2\u0026gt; * cadc079 - feat:增加长按连续输入，长按连续删除。设置setAutoRepeat(true)属性 (7 days ago) \u0026lt;author2\u0026gt; * b633021 - fix:符号|和\\，=和+切换显示有问题 符号\u0026amp;不能显示 (7 days ago) \u0026lt;author2\u0026gt; * 1940107 - feat:添加谷歌拼音核心代码 (8 days ago) \u0026lt;author1\u0026gt; * 9ae1441 - chore:整理开源依赖库目录，添加谷歌拼音输入法 (8 days ago) \u0026lt;author1\u0026gt; * d17947c - feat:增加数字符号切换按钮 (3 weeks ago) \u0026lt;author1\u0026gt; * 646a407 - fix:解决英文输入下，按空格无效 (3 weeks ago) \u0026lt;author1\u0026gt; * b588a3b - feat:左右shift按钮状态关联，准备添加左右翻页按钮 (3 weeks ago) \u0026lt;author1\u0026gt; * 9644ac2 - feat:在虚拟键盘布局中增加虚拟键盘关闭按钮 (4 weeks ago) \u0026lt;author1\u0026gt; * 3b97463 - (dev_init) init (4 weeks ago) \u0026lt;author1\u0026gt;  #生成区间范围的补丁 git format-patch 3b97463..92770dd  #结果如下 3B-pi@raspberrypi:~/Public/Qin-master/patch $ ls -lth total 20M -rw-r--r-- 1 pi pi 1.3K Feb 18 00:08 0021-style-change-handle_Default-int-keyId-to-handle_Defa.patch -rw-r--r-- 1 pi pi 163K Feb 18 00:08 0020-style.patch -rw-r--r-- 1 pi pi 32K Feb 18 00:08 0019-fix.patch -rw-r--r-- 1 pi pi 5.1M Feb 18 00:08 0018-style.patch -rw-r--r-- 1 pi pi 13M Feb 18 00:08 0017-feat.patch -rw-r--r-- 1 pi pi 11K Feb 18 00:08 0016-style-TableIM-IMBase.patch -rw-r--r-- 1 pi pi 7.6K Feb 18 00:08 0015-fix-shift.patch -rw-r--r-- 1 pi pi 9.2K Feb 18 00:08 0014-feat.patch -rw-r--r-- 1 pi pi 2.7K Feb 18 00:08 0013-feat.patch -rw-r--r-- 1 pi pi 14K Feb 18 00:08 0012-feat.patch -rw-r--r-- 1 pi pi 20K Feb 18 00:08 0011-fix-UI.patch -rw-r--r-- 1 pi pi 7.7K Feb 18 00:08 0010-fix.patch -rw-r--r-- 1 pi pi 14K Feb 18 00:08 0008-feat-setAutoRepeat-true.patch -rw-r--r-- 1 pi pi 5.6K Feb 18 00:08 0009-feat.patch -rw-r--r-- 1 pi pi 4.0K Feb 18 00:08 0007-fix.patch -rw-r--r-- 1 pi pi 11K Feb 18 00:08 0006-feat.patch -rw-r--r-- 1 pi pi 1.4M Feb 18 00:08 0005-chore.patch -rw-r--r-- 1 pi pi 16K Feb 18 00:08 0004-feat.patch -rw-r--r-- 1 pi pi 4.5K Feb 18 00:08 0003-fix.patch -rw-r--r-- 1 pi pi 8.0K Feb 18 00:08 0002-feat-shift.patch -rw-r--r-- 1 pi pi 7.0K Feb 18 00:08 0001-feat.patch  #应用补丁 git am ~/Public/Qin-master/patch/*.patch git批量修改author #  参考 https://www.git-tower.com/learn/git/faq/change-author-name-email\n  Run the following script from terminal after changing the variable values\n#!/bin/sh  git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;your-old-email@example.com\u0026#34; CORRECT_NAME=\u0026#34;Your Correct Name\u0026#34; CORRECT_EMAIL=\u0026#34;your-correct-email@example.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags   Push the corrected history to GitHub:\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39;   OR if you like to push selected references of the branches then use\ngit push --force --tags origin \u0026#39;refs/heads/develop\u0026#39; git验证机制更新 #   https://www.bswen.com/2021/09/others-how-to-solve-github-issue1.html\n"},{"id":12,"href":"/docs/Linux-World/Ubuntu/%E5%85%B6%E5%AE%83/","title":"其它","section":"Ubuntu","content":"ubuntu扩容 #   https://blog.csdn.net/qq_34160841/article/details/113058756\nlinux命令 #   https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html\n安装armhf ubuntu #   https://wiki.ubuntu.com/ARM/RaspberryPi\n"},{"id":13,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/","title":"工作总结","section":"Introduction","content":"Introduction #  记录工作中遇到的难点及解决方法\n  数据库  附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764 attach [database] filename as database_name;\rdetach [database] database_name; Squeezing Performance from SQLite: Insertions # https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2 CREATE INDEX tag_titles ON tags (title);\rEXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = \u0026#34;Kotlin\u0026#34;;   日志模块实现思路  版本说明 # 日志模块实现 日期 版本 修改内容 2022/03/01 V0.1 创建 实现目标 # 整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦 整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时 能做到内存中始终能导出最近的日志到U盘中 程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0) 参考实现 # Qt5官方日志QLoggingCategory测试 # QLoggingCategory represents a certain logging category - identified by a string - at runtime. A category can be configured to enable or disable logging of messages per message type.   "},{"id":14,"href":"/docs/Linux-World/","title":"Linux World","section":"Introduction","content":"记录Linux系统中常常遇到的问题对应的解决方法\n  工具  Linux必备工具 Git Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   Raspberry  常用 apt源 # 修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）： 清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib 修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 使用代理 apt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt # https://github.com/tranter/raspberry-pi-qt-builds/releases cd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake https://blog.csdn.net/tianfour/article/details/76068656 youtube-dl # channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.   Ubuntu  目录共享配置 Samba配置 # samba配置后，仍然无法访问 # https://blog.csdn.net/Panda_YinLP/article/details/104687438 访问window共享目录 # sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 # https://linuxhint.com/install_tftp_server_ubuntu/ https://download.samba.org/pub/samba/ NFS挂载 # https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04 将文件系统目录导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07. 系统代理和证书 透明代理 # https://blog.   "},{"id":15,"href":"/posts/zerotier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"ZeroTier内网穿透","section":"Blog","content":"ZeroTier内网穿透 #  安装方式1：脚本自动安装 #  sudo curl -s https://install.zerotier.com|sudo bash 在ubuntu下成功安装，在树莓派上可能失败\n安装方式2：源码安装 #  wget https://github.com/zerotier/ZeroTierOne/archive/refs/tags/1.8.4.tar.gz tar zxvf 1.8.4.tar.gz cd ZeroTierOne-1.8.4/ make -j make install 注册账号 #  申请ID,参考https://blog.csdn.net/kai3123919064/article/details/109662499\n运行 #  1、在每个设备端上运行服务端zerotier-one，并将每一个设备添加到相同的NetworkID组，这样同一下 NetworkID组下的所有成员就能相互穿透了\n先安装zerotier-one服务并运行，这样以后开机自动启动此服务\n#在源码目录下可以看到此文件 ~/Public/ZeroTierOne-1.8.4 $ cat debian/zerotier-one.service [Unit] Description=ZeroTier One After=network-online.target Wants=network-online.target  [Service] ExecStart=/usr/sbin/zerotier-one Restart=always KillMode=process  [Install] WantedBy=multi-user.target 注意检查上面的/usr/sbin/zerotier-one路径是否存在\n#将此文件 拷贝到/lib/systemd/system/目录下 $ cp debian/zerotier-one.service /lib/systemd/system/ #启动服务 $ systemctl start zerotier-one.service #查看服务状态 $ systemctl status zerotier-one.service ● zerotier-one.service - ZeroTier One  Loaded: loaded (/lib/systemd/system/zerotier-one.service; enabled; vendor preset: enabled)  Active: active (running) since Thu 2022-03-17 22:22:47 CST; 3 days ago  Main PID: 487 (zerotier-one)  Tasks: 5 (limit: 2059)  CGroup: /system.slice/zerotier-one.service  └─487 /usr/sbin/zerotier-one 2、在每个设备都添加到自己的局域网，每台设备都执行以下命令后，这样在相同your_network_id下的每个设备之间就组成局域网了，太简单了，但是还需要在下一步中的网页端上进行确认\nsudo zerotier-cli join your_network_id 3、在网页端中https://my.zerotier.com/network/your_network_id，启动刚刚添加的设备\n 4、在设备端可以看到，新增了一个网络接口和相应的路由表，并且IP地址显示为上图网页管理界面中的IP\n  5、此时网页管理界面中显示的两个成员就能相互访问了\nssh root@192.168.192.212 perfect!!!\n"},{"id":16,"href":"/posts/Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/","title":"搭建HUGO博客","section":"Blog","content":"搭建HUGO博客 #  安装hugo #  进入 release页面下载，选择下载 hugo_extended_0.97.0_Linux-64bit.deb带extended后缀的安装包\nsudo dpkg -i hugo_extended_0.97.0_Linux-64bit.deb 创建hugo工程 #  mkdir ~/Public/Book cd ~/Public/Book hugo new site ./ 下载主题 #  git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book cp -R themes/hugo-book/exampleSite/content . 运行Web服务 #  ubuntu:~/Public/Book$ hugo server --minify --theme hugo-book --bind=\u0026#34;0.0.0.0\u0026#34; -p 8888 Start building sites … hugo v0.97.0-c07f3626e7c8160943591f4d209977efa02c3dca+extended linux/amd64 BuildDate=2022-04-14T08:45:07Z VendorInfo=gohugoio WARN 2022/04/16 01:47:16 Expand shortcode is deprecated. Use \u0026#39;details\u0026#39; instead. WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/variables\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/functions\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/content/front-matter\u0026#39; not found in \u0026#39;posts/goisforlovers.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/overview/configuration/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/templates/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39; WARN 2022/04/16 01:47:16 Page \u0026#39;/doc/shortcodes/\u0026#39; not found in \u0026#39;posts/migrate-from-jekyll.md\u0026#39;   | EN | RU | ZH -------------------+----+----+-----  Pages | 57 | 7 | 7  Paginator pages | 0 | 0 | 0  Non-page files | 0 | 0 | 0  Static files | 78 | 78 | 78  Processed images | 0 | 0 | 0  Aliases | 12 | 2 | 2  Sitemaps | 2 | 1 | 1  Cleaned | 0 | 0 | 0  Built in 92 ms Watching for changes in ~/Public/Book/{archetypes,content,data,layouts,static,themes} Watching for config changes in ~/Public/Book/config.toml, ~/Public/Book/config/_default Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:8888/ (bind address 0.0.0.0) Press Ctrl+C to stop Hugo主题宽屏设置 #  修改文件themes/hugo-book/assets/_defaults.scss\n$container-max-width: 80rem !default; 修改为\n$container-max-width: 200rem !default; "},{"id":17,"href":"/docs/Linux-World/Raspberry/","title":"Raspberry","section":"Linux World","content":"  常用  apt源 # 修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）： 清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib 修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 使用代理 apt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt # https://github.com/tranter/raspberry-pi-qt-builds/releases cd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake https://blog.csdn.net/tianfour/article/details/76068656 youtube-dl # channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.   "},{"id":18,"href":"/docs/Linux-World/Ubuntu/","title":"Ubuntu","section":"Linux World","content":"  目录共享配置  Samba配置 # samba配置后，仍然无法访问 # https://blog.csdn.net/Panda_YinLP/article/details/104687438 访问window共享目录 # sudo mount -t cifs -l //192.168.31.181/raspberry /media/pi/win TFTP配置 # https://linuxhint.com/install_tftp_server_ubuntu/ https://download.samba.org/pub/samba/ NFS挂载 # https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nfs-mount-on-ubuntu-20-04 将文件系统目录导出 # 解压文件系统 cd /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/ sudo mkdir tisdk-default-image-am335x-evm sudo tar -Jxf tisdk-default-image-am335x-evm.tar.xz -C tisdk-default-image-am335x-evm 修改/etc/exports增加NFS导出目录后，重新加载 # $ vi /etc/exports #增加以下内容 /usr/local/ti-sdk-am335x-evm-07.03.00.005/filesystem/tisdk-default-image-am335x-evm *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 使NFS目录生效 # $ sudo exportfs -a 查看NFS导出列表 # #查看NFS导出列表 $ showmount -e Export list for ubuntu: /usr/local/ti-sdk-am335x-evm-07.   系统代理和证书  透明代理 # https://blog.a1253247.info/2020/01/shadowsocks.html 代理转换 # /etc/polipo/config /etc/polipo/config systemctl status polipo www.codevoila.com/post/16/convert-socks-proxy-to-http-proxy-using-polipo 测试网速 # # Server tankywoo@gentoo-local::~/ » iperf -s ------------------------------------------------------------ Server listening on TCP port 5001 TCP window size: 85.3 KByte (default) ------------------------------------------------------------ [ 4] local 127.0.0.1 port 5001 connected with 127.0.0.1 port 56071 [ ID] Interval Transfer Bandwidth [ 4] 0.0-10.0 sec 27.0 GBytes 23.2 Gbits/sec # Client tankywoo@gentoo-local::~/ » iperf -c localhost ------------------------------------------------------------ Client connecting to localhost, TCP port 5001 TCP window size: 647 KByte (default) ------------------------------------------------------------ [ 3] local 127.   其它  ubuntu扩容 # https://blog.csdn.net/qq_34160841/article/details/113058756 linux命令 # https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html 安装armhf ubuntu # https://wiki.ubuntu.com/ARM/RaspberryPi   "},{"id":19,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Git/","title":"Git","section":"工具","content":"  Git常用配置  Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   git基本使用  版本说明 # git基本使用 日期 版本 修改内容 2021/02/19 V0.3 创建 Git对比SVN # 1.小步提交，互不干扰 # 并行开发过程中各开发人员可以随时多次commit代码且互不影响，最后在merage到主分支，并且能记录所有成员的所有commint记录。SVN只能大量的一次性提交到中心库。 2.打断开发：在开发新功能过程中，突然需要你去修复一个Bug # 使用Git，你可以直接stash/commit当前改动，然后switch到主分支去修复Bug，之后在pop/switch回你原来的分支继续开发。 3.Git分支切换-指针移动，SVN分支切换-Copy项目 # Git支持本地无限Branches，当我们个体在本地创建多个branches用于不同目的的时候（修改，新增，探索），分支轻量化，秒创分支，创建分支满足客户定制化需求 4.Git Tag-指针标示，SVN Tag-Copy项目 # Git管理的项目要比SVN小得多。Git初次拉取代码的速度也远小于SVN。 5.两级提交 # 本地创建分支开发，本地提交，需要合并时再提交到远程 6.日志查看 # Git本地包含了完整的日志，闪电的速度查看（并且无需网络)。SVN需要从服务拉取。 7.安全 # Git是分布式版本控制系统，每个用户都相当于一份备份， 管理员无需为数据备份而担心。SVN作为集中式版本控制系统，存在单点故障的风险。备份版本库的任务非常繁重。 linus在google的演讲感悟 链接：https://www.zhihu.com/question/19601997/answer/95363587 自洽的、最少依赖的个人工作得到支持。1000多人的Linux开发团队是分布在世界各地的，使用git也就不必依赖中心服务器、不必需要很少的网络。就在自己的电脑上就有完整的仓库，可以做任何版本管理，除了分享代码。SVN显然是不合适的，因为单点故障大家甚至无法提交，更加无法开分支，这是无法忍受的。 剔除害群之马很简单。如果Linus经过观察，发现有些程序员特别容易出漏子，那么封杀的办法就是不必拉取即可。实际上Linus就是这样干过。如果是SVN，就变成了撤销惹麻烦的开发者的账号或者限定他的访问范围，并且从仓库中移除麻烦的代码提交。就是说，封杀的方法在git而言，是不做某事即可，SVN是做一系列事情才可以。一正一反，大家可以体会一下。Linus喜欢前者，并且得心应手。这样的工作流程就避开了很多“政治”问题，让他的集成代码过程变得主动。 可以使用信任网络。Linux太大了，不可能完全看完补丁代码的方式来识别信任，这个Linus曾经干过，最后的结果当然是放弃。如果发现有些程序员特别优秀，他只要选择拉取他们的实现。这些程序员也只是拉取他们信任的程序员的实现。这样的信任网络是可以层次化的，因此对应于1000多人的开发者来说，这样做确实可以通过分层的信任网络达成大规模的团队协作。如果是SVN，我不知道如何做可以更好 轻量的分支开销鼓励大量被使用。对于这样的团队，为了敏捷的迭代，如果有想法就分支（这样的开发隔离想法是很有价值的），那么在svn上分支是海量的并且全局的大家互相影响，因此是要命的。而对于Git总数当然是海量，但是每个人的分支都在自己的仓库内，不会影响到他人。且分支无需连接服务器，因此是飞速的。 Git工作流 # http://www.   git高级使用  版本说明 # git基本使用 日期 版本 修改内容 2021/02/19 V0.3 创建 个人使用总结 # Merge节点 # Git有两种合并：一种是\u0026quot;直进式合并\u0026quot;（fast forward），不生成单独的合并节点；另一种是\u0026quot;非直进式合并\u0026quot;（none fast-forword），会生成单独节点。 前者不利于保持commit信息的清晰，也不利于以后的回滚，建议总是采用后者（即使用--no-ff参数）。只要发生合并，就要有一个单独的合并节点。 push策略 # 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config --global push.default matching # 或者 $ git config --global push.default simple 解决merge 和 rebase 合并冲突 # #merge 和 rebase 对于 ours 和 theirs 的定义是完全相反的。在 merge 时，ours 指代的是当前分支，theirs 代表需要被合并的分支。而在 rebase 过程中，ours 指向了修改参考分支，theirs 却是当前分支 git checkout --ours src/MyFile.   "},{"id":20,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/","title":"Vim","section":"工具","content":"  配置  vim退出时不清除屏幕内容 # 1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示： 2、然后执行source /etc/profile即可 vim设置colorSchema # mkdir -p ~/.vim/colors https://github.com/tomasr/molokai 设置蓝色 # eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34; alias ls=\u0026#39;ls --color=auto\u0026#39; #alias dir=\u0026#39;dir --color=auto\u0026#39; #alias vdir=\u0026#39;vdir --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.   "},{"id":21,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","title":"深入理解计算机系统","section":"读书笔记","content":"  第一章  3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   第二章  9rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   "},{"id":22,"href":"/docs/Linux-World/Raspberry/%E5%B8%B8%E7%94%A8/","title":"常用","section":"Raspberry","content":"apt源 #  修改/etc/apt/sources.list，去掉自带的源，添加如下源（二选一即可）：\n清华源 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi\n阿里源 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib\n修改：/etc/apt/sources.list.d/raspi.list，去掉自带的源，添加如下源：\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui\n使用代理\napt update -o Acquire::http::proxy=\u0026#34;socks5h://192.168.31.181:10808/\u0026#34; raspberry-qt #   https://github.com/tranter/raspberry-pi-qt-builds/releases\ncd / sudo tar xf /home/pi/Qt5.10.1-RaspberryPi3-bin-full.tgz qtchooser -install qt-5.12.2 /usr/local/Qt-5.15.2/bin/qmake  https://blog.csdn.net/tianfour/article/details/76068656\nyoutube-dl #  channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34;\rhttps://www.youtube.com/channel/UCNT5WLWYnSV30mlKLnPzHTg/playlists\rhttps://www.youtube.com/watch?v=Tu-vU4zFre0\u0026amp;list=PLoZQ0sz6CBHGG1qoq-tISRs9tKCLwCyM\rhttps://www.youtube.com/user/numberblocks/playlists\rhttps://www.youtube.com/watch?v=2mQ0JtlddLI\u0026amp;list=PL9swKX1PviEor1JJ9oiJwidaT-q69tYW2\ryoutube-dl --yes-playlist -f best -ciw -o \u0026#34;${outdir}/%(uploader)s/playlists/%(playlist)s/videos/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; -v $channel_url\r-c, --continue Force resume of partially downloaded files. By default, youtube-dl will resume downloads if possible.\r-i, --ignore-errors Continue on download errors, for example to skip unavailable videos in a playlist\r-w, --no-overwrites Do not overwrite files #!/bin/bash url=\u0026#34;https://www.youtube.com/playlist?list=\u0026#34;$1 channel_url=\u0026#34;https://www.youtube.com/user/channelname/playlists\u0026#34; proxy=\u0026#34;--proxy socks5://localhost:1081\u0026#34; #args=\u0026#34;--no-check-certificate --restrict-filenames --no-warnings --ignore-errors\u0026#34; args=\u0026#34;--no-check-certificate --no-warnings --ignore-errors --continue --no-overwrites \u0026#34; get_info=\u0026#34; --get-id --get-filename --get-title\u0026#34; get_sub=\u0026#34;--write-auto-sub --skip-download\u0026#34;  list_dir=$2 name=${list_dir##*/} echo name list_path=$2\u0026#34;/$name.txt\u0026#34; if [ ! -d $list_dir ]; then  mkdir $list_dir fi echo $list_dir echo $list_path cd $list_dir youtube-dl $url $args $proxy -o \u0026#34;%(uploader)s/playlists/%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; #youtube-dl $url $args $proxy -o \u0026#34;${outdir}/%(uploader)s/playlists/%(playlist)s/videos/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; #youtube-dl $url $args $proxy -o \u0026#34;%(playlist_index)s-%(title)s.%(ext)s\u0026#34; 开启wifi #  pi@raspberrypi:~ $ sudo rfkill list all 0: phy0: Wireless LAN \tSoft blocked: no \tHard blocked: no 1: hci0: Bluetooth \tSoft blocked: yes \tHard blocked: no pi@raspberrypi:~ $ sudo rfkill unblock 0 升级固件 #  #安装CA证书 sudo apt-get install ca-certificates  #同步时间 sudo apt-get install ntpdate sudo ntpdate -u ntp.ubuntu.com   mkdir /root/.rpi-firmware cd /root/.rpi-firmware curl -L https://github.com/Hexxeh/rpi-firmware/archive/master.tar.gz -o master.tar.gz tar -xvzf master.tar.gz rm master.tar.gz  # 执行本地更新 UPDATE_SELF=0 SKIP_DOWNLOAD=1 rpi-update  # 重启 reboot How to get back to safety #  If you have done an rpi-update and things are not working as you wish, if your Raspberry Pi is still bootable you can return to the stable release using:\nsudo apt-get update\rsudo apt install --reinstall libraspberrypi0 libraspberrypi-{bin,dev,doc} raspberrypi-bootloader raspberrypi-kernel  https://www.raspberrypi.org/documentation/\n https://wiki.debian.org/DontBreakDebian#Don.27t_make_a_FrankenDebian\n安装armhf ubuntu #   https://wiki.ubuntu.com/ARM/RaspberryPi\nraspberry 启动流程 #   https://www.lions-wing.net/maker/raspberry-1/boot.html\n传感器 #  MPU6050 #   https://openest.io/en/2020/01/21/mpu6050-accelerometer-on-raspberry-pi/\n https://tutorials-raspberrypi.com/measuring-rotation-and-acceleration-raspberry-pi/\n https://howtomechatronics.com/tutorials/arduino/arduino-and-mpu6050-accelerometer-and-gyroscope-tutorial/\nhttps://www.stupid-projects.com/controlling-a-3d-object-in-unity3d-with-teensy-and-mpu-6050/ #  https://bitbucket.org/dimtass/teensy-hid-with-unity3d/src/master/ #   https://github.com/jrowberg/i2cdevlib/blob/master/RaspberryPi_bcm2835/MPU6050/examples/IMU_zero.cpp\n http://brettbeauregard.com/blog/2011/04/improving-the-beginner%e2%80%99s-pid-sample-time/\n#       字母名称 国际音标     俯仰角θ（pitch） Θ theta /\u0026lsquo;θi:tə/   偏航角ψ（yaw） Ψ psi /psaɪ/   滚转角Φ（roll） φ phi /faɪ/     ESP8266 #   https://blog.csdn.net/chentuo2000/article/details/105296166/?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1\u0026spm=1001.2101.3001.4242\n"},{"id":23,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/Vim/%E9%85%8D%E7%BD%AE/","title":"配置","section":"Vim","content":"vim退出时不清除屏幕内容 #  1、编辑/etc/profile,然后在文件中添加：export TERM=linux，如下图所示：\n 2、然后执行source /etc/profile即可\nvim设置colorSchema #  mkdir -p ~/.vim/colors  https://github.com/tomasr/molokai\n设置蓝色 #  eval `dircolors | sed -e \u0026#39;s/;34:/;36:/\u0026#39;` pi@raspberrypi:~ $ echo $LS_COLORS  rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36: vi ~/.bashrc # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then  test -r ~/.dircolors \u0026amp;\u0026amp; eval \u0026#34;$(dircolors -b ~/.dircolors)\u0026#34; || eval \u0026#34;$(dircolors -b)\u0026#34;  alias ls=\u0026#39;ls --color=auto\u0026#39;  #alias dir=\u0026#39;dir --color=auto\u0026#39;  #alias vdir=\u0026#39;vdir --color=auto\u0026#39;   alias grep=\u0026#39;grep --color=auto\u0026#39;  alias fgrep=\u0026#39;fgrep --color=auto\u0026#39;  alias egrep=\u0026#39;egrep --color=auto\u0026#39; fi  LS_COLORS=\u0026#39;rs=0:di=01;36:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:* .lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31 :*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm =01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mn g=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=0 1;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:* .mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\u0026#39;; export LS_COLORS "},{"id":24,"href":"/docs/Linux-World/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/","title":"常用 Linux命令","section":"工具","content":"find ./ -type d -name \u0026#34;Backup\u0026#34; -exec rm -rf {} \\;  sed -i \u0026#34;s/\u0026lt;cups\\/cups.h\u0026gt;/\\\u0026#34;cups\\/cups.h\\\u0026#34;/g\u0026#34; `grep \u0026#34;cups/cups.h\u0026#34; -rl .`  find . -type f -size +100M -print0 | xargs -0 du -h | sort -nr  cat *.txt | sort | uniq \u0026gt; test  #导出svn版本差异 for i in $(svn diff --summarize -r 248:276 svn://192.168.10.200/rootfs/ | awk \u0026#39;{ print $2 }\u0026#39;); do p=$(echo $i | sed -e \u0026#39;s{svn://192.168.10.200/rootfs/{{\u0026#39;); mkdir -p $(dirname $p); svn export $i $p; done  #获取awk ./a.out |awk \u0026#39;BEGIN{FS=\u0026#34;[()]\u0026#34;} NR==5{print $2}\u0026#39;  FS指定分隔符  NR指定读取第几行输出  #查找文件权限  find -type d -not -perm 775 -o -type f -not -perm 664    sed -n \u0026#39;/192.xxx/\u0026#39;p xxxx |awk \u0026#39;BEGIN{FS=\u0026#34;[ ]\u0026#34;} {print $5 }\u0026#39; |sort |uniq |wc -l "},{"id":25,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"数据库","section":"工作总结","content":"附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764\nattach [database] filename as database_name;\rdetach [database] database_name; Squeezing Performance from SQLite: Insertions #   https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2\nCREATE INDEX tag_titles ON tags (title);\rEXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = \u0026#34;Kotlin\u0026#34;; "},{"id":26,"href":"/docs/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/","title":"日志模块实现思路","section":"工作总结","content":"版本说明 #   日志模块实现    日期 版本 修改内容     2022/03/01 V0.1 创建      实现目标 #    整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦\n  整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时\n  能做到内存中始终能导出最近的日志到U盘中\n  程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0)\n  参考实现 #  Qt5官方日志QLoggingCategory测试 #  QLoggingCategory represents a certain logging category - identified by a string - at runtime. A category can be configured to enable or disable logging of messages per message type.\nSplit up logging messages in hierarchical categories.Category is identified by it\u0026rsquo;s name category.subcategory.subsubcategory[\u0026hellip;] Logging of messages can be enabled or disabled based on the category and message type, at runtime.\n优点：\n1、可以将各个模块日志通过各自的Debug Level进行控制\n2、运行时，动态修改各个模块的Debug Level\nImproving Logging Output #   https://community.kde.org/Guidelines_and_HOWTOs/Debugging/Using_Error_Messages\nQt provides a way of controlling the output of the logging methods via an environment variable. You can tell it to include the application name and PID, as well as the debugging category, and color-code the text. For example, running the following lines in your shell will produce something that looks quite like kDebug\u0026rsquo;s colored output:\nc=`echo -e \u0026#34;\\033\u0026#34;` export QT_MESSAGE_PATTERN=\u0026#34;%{appname}(%{pid})/(%{category}) $c\\[31m%{if-debug}$c\\[34m%{endif}%{function}$c\\[0m: %{message}\u0026#34; unset c See qSetMessagePattern documentation for the full list of placeholders.\n内部实现代码 #   https://stackoverflow.com/questions/55520757/how-to-use-q-logging-category-and-reference-the-category-in-a-templated-function\n#define Q_DECLARE_LOGGING_CATEGORY(name) \\ extern const QLoggingCategory \u0026amp;name();  #define Q_LOGGING_CATEGORY(name, ...) \\ const QLoggingCategory \u0026amp;name() \\ { \\ static const QLoggingCategory category(__VA_ARGS__); \\ return category; \\ }  //使用 #define qCDebug(category, ...) \\ for (bool qt_category_enabled = category().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false) \\ QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC, category().categoryName()).debug(__VA_ARGS__) moduo日志实现参考20210901 #  #define LOG_TRACE if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::TRACE) \\ muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream() #define LOG_DEBUG if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::DEBUG) \\ muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream() #define LOG_INFO if (muduo::Logger::logLevel() \u0026lt;= muduo::Logger::INFO) \\ muduo::Logger(__FILE__, __LINE__).stream() #define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream() #define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream() #define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream() #define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream() #define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream() syslog日志实现 #  日志消息级别syslog Level #   0 EMERG（紧急）：会导致主机系统不可用的情况 1 ALERT（警告）：必须马上采取措施解决的问题 2 CRIT（严重）：比较严重的情况 3 ERR（错误）：运行出现错误 4 WARNING（提醒）：可能会影响系统功能的事件 5 NOTICE（注意）：不会影响系统但值得注意 6 INFO（信息）：一般信息 7 DEBUG（调试）：程序或系统调试信息等     syslog journald priority level QtMsgType 说明     LOG_EMERG emerg QtFatalMsg System is unusable   LOG_ALERT alert  Should be corrected immediately   LOG_CRIT crit QtCriticalMsg Critical conditions   LOG_ERR err  Error conditions   LOG_WARNING warning QtWarningMsg May indicate that an error will occur if action is not taken.   LOG_NOTICE notice  Events that are unusual, but not error conditions.   LOG_INFO info QtInfoMsg Normal operational messages that require no action.   LOG_DEBUG debug QtDebugMsg Information useful to developers for debugging the application.    syslog与QDebug配合 #  Qt4封装\n#include \u0026lt;QApplication\u0026gt;#include \u0026lt;syslog.h\u0026gt; void customMessageHandler(QtMsgType type, const char* msg) {  switch(type)  {  case QtDebugMsg:  syslog(LOG_DEBUG, \u0026#34;%s\u0026#34;, msg);  break;  case QtInfoMsg:  syslog(LOG_INFO, \u0026#34;%s\u0026#34;, msg);  break;  case QtWarningMsg:  syslog(LOG_WARNING, \u0026#34;%s\u0026#34;, msg);  break;  case QtCriticalMsg:  syslog(LOG_CRIT, \u0026#34;%s\u0026#34;, msg);  break;  case QtFatalMsg:  syslog(LOG_ERR, \u0026#34;%s\u0026#34;, msg);  abort();//这里退出进程了  break;  default:  syslog(LOG_DEBUG, \u0026#34;%s\u0026#34;, msg);  break;  } }  int main(int argc, char* argv[]) {  QApplication a(argc, argv);  qInstallMsgHandler(customMessageHandler);  return a.exec(); } Qt5封装\n#include \u0026lt;QApplication\u0026gt;#include \u0026lt;syslog.h\u0026gt;static const char LOG_LEVEL_CHAR[8] = {\u0026#39;!\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;D\u0026#39;}; static void customMessageHandler(QtMsgType type, const QMessageLogContext \u0026amp;context, const QString \u0026amp;msg)  {  QByteArray localMsg = msg.toLocal8Bit();  const char *file = context.file ? context.file : \u0026#34;\u0026#34;;  const char *function = context.function ? context.function : \u0026#34;\u0026#34;;  const char *category = context.category ? context.category : \u0026#34;\u0026#34;;  int level = LOG_INFO;  switch (type) {  case QtDebugMsg:  level = LOG_DEBUG;  break;  case QtInfoMsg:  level = LOG_INFO;  break;  case QtWarningMsg:  level = LOG_WARNING;  break;  case QtCriticalMsg:  level = LOG_CRIT;  break;  case QtFatalMsg:  level = LOG_ERR;  break;  default:  break;  }  syslog(level, \u0026#34;[%c](%s,%s:%u, %s): %s \\n\u0026#34;, LOG_LEVEL_CHAR[level],category,file, context.line, function, localMsg.constData());  }  int main(int argc, char *argv[]) {  QApplication a(argc, argv);  qInstallMessageHandler(customMessageHandler);  return a.exec(); } Qt4中的qInstallMsgHandler函数被Qt5的qInstallMessageHandler替代了，增加了QMessageLogContext类，可以输出函数名、行号、文件路径信息\n测试结果如下，可以看出并没有显示函数名、行号等信息\nMay 24 09:43:23 am335x-evm test_log_category[954]: Debug: Log something:qCDebug 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Info: Log something:qCInfo 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Warning: Log something:qCWarning 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Critical: Log something:qCCritical 74 (:0, , awesomecategory) May 24 09:43:23 am335x-evm test_log_category[954]: Debug: Log something:qDebug 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Info: Log something:qInfo 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Warning: Log something:qWarning 74 (:0, , default) May 24 09:43:23 am335x-evm test_log_category[954]: Critical: Log something:qCritical 74 (:0, , default) 通过以下两种方式修改pro文件后，可以开启函数名、行号等信息显示\n#方式1 CONFIG += debug CONFIG(debug, debug|release) {  DESTDIR = build/debug } CONFIG(release, debug|release) {  DESTDIR = build/release } #方式2 #Note: By default, this information is recorded only in debug builds. #You can overwrite this explicitly by defining QT_MESSAGELOGCONTEXT or QT_NO_MESSAGELOGCONTEXT. DEFINES +=QT_MESSAGELOGCONTEXT May 24 10:14:49 am335x-evm test_log_category[916]: [D](category1,../widget.cpp:28, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCDebug1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](category1,../widget.cpp:29, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCInfo1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](category1,../widget.cpp:30, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCWarning1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](category1,../widget.cpp:31, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCCritical1 1 May 24 10:14:49 am335x-evm test_log_category[916]: [D](category2,../widget.cpp:34, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCDebug2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](category2,../widget.cpp:35, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCInfo2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](category2,../widget.cpp:36, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCWarning2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](category2,../widget.cpp:37, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCCritical2 1 May 24 10:14:49 am335x-evm test_log_category[916]: [D](default,../widget.cpp:39, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qDebug3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [I](default,../widget.cpp:40, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qInfo3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [W](default,../widget.cpp:41, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qWarning3 1 May 24 10:14:49 am335x-evm test_log_category[916]: [C](default,../widget.cpp:42, virtual void Widget::timerEvent(QTimerEvent*)): Log something:qCritical3 1 为了区分同一个进程内的不同模块日志，可使用QLoggingCategory类\nLogging kernel oops to MTD #  A kernel error, or oops, is normally logged via the klogd and syslogd daemons to a circular memory buffer or a file.\nFollowing a reboot, the log will be lost in the case of a ring buffer, and even in the case of a file, it may not have been properly written to before the system crashed.\nA more reliable method is to write oops and kernel panics to an MTD partition as a circular log buffer.\nYou can enable it with CONFIG_MTD_OOPS and add console=ttyMTDN to the kernel command line, with N being the MTD device number to write the messages to.\n• /var/log Generally, logging to flash memory is not desirable because of the many small write cycles it generates. A simple solution is to mount /var/log using tmpfs, making all log messages volatile. In the case of syslogd, BusyBox has a version that can log to a circular ring buffer.\njournald #  The journal collects:\n All data logged via libc syslog() The data from the kernel logged with printk() Everything written to STDOUT/STDERR of any system service  root@am335x-evm:~# systemctl status systemd-journald * systemd-journald.service - Journal Service  Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: disabled)  Active: active (running) since Mon 2021-05-24 08:05:14 UTC; 11min ago TriggeredBy: * systemd-journald.socket  * systemd-journald-dev-log.socket  * systemd-journald-audit.socket  Docs: man:systemd-journald.service(8)  man:journald.conf(5)  Main PID: 95 (systemd-journal)  Status: \u0026#34;Processing requests...\u0026#34;  Tasks: 1 (limit: 454)  Memory: 8.9M  CGroup: /system.slice/systemd-journald.service  `-95 /lib/systemd/systemd-journald  May 24 08:05:14 am335x-evm systemd-journald[95]: Journal started May 24 08:05:14 am335x-evm systemd-journald[95]: Runtime Journal (/run/log/journal/d962f275af8b4c3ca16323491f1b0a43) is 8.0M, max 64.0M, 56.0M free. May 24 08:05:15 am335x-evm systemd-journald[95]: Runtime Journal (/run/log/journal/d962f275af8b4c3ca16323491f1b0a43) is 8.0M, max 64.0M, 56.0M free. Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable. systemd-journald.service #  root@am335x-evm:~# cat /lib/systemd/system/systemd-journald.service # SPDX-License-Identifier: LGPL-2.1+ # # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version.  [Unit] Description=Journal Service Documentation=man:systemd-journald.service(8) man:journald.conf(5) DefaultDependencies=no Requires=systemd-journald.socket After=systemd-journald.socket systemd-journald-dev-log.socket systemd-journald-audit.socket syslog.socket Before=sysinit.target  [Service] OOMScoreAdjust=-250 CapabilityBoundingSet=CAP_SYS_ADMIN CAP_DAC_OVERRIDE CAP_SYS_PTRACE CAP_SYSLOG CAP_AUDIT_CONTROL CAP_AUDIT_READ CAP_CHOWN CAP_DAC_READ_SEARCH CAP_FOWNER CAP_SETUID CAP_SETGID CAP_MAC_OVERRIDE DeviceAllow=char-* rw ExecStart=/lib/systemd/systemd-journald FileDescriptorStoreMax=4224 IPAddressDeny=any LockPersonality=yes MemoryDenyWriteExecute=yes NoNewPrivileges=yes Restart=always RestartSec=0 RestrictAddressFamilies=AF_UNIX AF_NETLINK RestrictNamespaces=yes RestrictRealtime=yes RestrictSUIDSGID=yes Sockets=systemd-journald.socket systemd-journald-dev-log.socket systemd-journald-audit.socket StandardOutput=null SystemCallArchitectures=native SystemCallErrorNumber=EPERM SystemCallFilter=@system-service Type=notify WatchdogSec=3min  # If there are many split up journal files we need a lot of fds to access them # all in parallel. LimitNOFILE=524288 默认配置 journald.conf #  # This file is part of systemd. # # systemd is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as published by # the Free Software Foundation; either version 2.1 of the License, or # (at your option) any later version. # # Entries in this file show the compile time defaults. # You can change settings by editing this file. # Defaults can be restored by simply deleting this file. # # See journald.conf(5) for details.  [Journal] #Storage=auto #Compress=yes #Seal=yes #SplitMode=uid #SyncIntervalSec=5m #RateLimitIntervalSec=30s #RateLimitBurst=10000 #SystemMaxUse= #SystemKeepFree= #SystemMaxFileSize= #SystemMaxFiles=100 #RuntimeMaxUse= #RuntimeKeepFree= #RuntimeMaxFileSize= #RuntimeMaxFiles=100 #MaxRetentionSec= #MaxFileSec=1month #ForwardToSyslog=no #ForwardToKMsg=no #ForwardToConsole=no #ForwardToWall=yes #TTYPath=/dev/console #MaxLevelStore=debug #MaxLevelSyslog=debug #MaxLevelKMsg=notice #MaxLevelConsole=info #MaxLevelWall=emerg #LineMax=48K #ReadKMsg=yes Storage=\n/run/log/journal目录存在则保存到内存中，the existence of the directory controls the storage mode\nNote that journald will initially use volatile storage, until a call to journalctl \u0026ndash;flush (or sending SIGUSR1 to journald) will cause it to switch to persistent logging (under the conditions mentioned above). This is done automatically on boot via \u0026ldquo;systemd-journal-flush.service\u0026rdquo;.\nMaxLevelStore=`, `MaxLevelSyslog=`, `MaxLevelKMsg=`, `MaxLevelConsole=`, `MaxLevelWall= Controls the maximum log level of messages that are stored in the journal, forwarded to syslog, kmsg, the console or wall (if that is enabled, see above). As argument, takes one of \u0026ldquo;emerg\u0026rdquo;, \u0026ldquo;alert\u0026rdquo;, \u0026ldquo;crit\u0026rdquo;, \u0026ldquo;err\u0026rdquo;, \u0026ldquo;warning\u0026rdquo;, \u0026ldquo;notice\u0026rdquo;, \u0026ldquo;info\u0026rdquo;, \u0026ldquo;debug\u0026rdquo;, or integer values in the range of 0–7 (corresponding to the same levels). Messages equal or below the log level specified are stored/forwarded, messages above are dropped. Defaults to \u0026ldquo;debug\u0026rdquo; for MaxLevelStore= and MaxLevelSyslog=, to ensure that the all messages are stored in the journal and forwarded to syslog. Defaults to \u0026ldquo;notice\u0026rdquo; for MaxLevelKMsg=, \u0026ldquo;info\u0026rdquo; for MaxLevelConsole=, and \u0026ldquo;emerg\u0026rdquo; for MaxLevelWall=. These settings may be overridden at boot time with the kernel command line options \u0026ldquo;systemd.journald.max_level_store=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_syslog=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_kmsg=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_console=\u0026rdquo;, \u0026ldquo;systemd.journald.max_level_wall=\u0026rdquo;.\n通过查看man journald.conf手册，为了满足需要，只需要/etc/systemd/journald.conf 做如下配置\nRuntimeMaxUse=16M #重启日志模块 $ systemctl restart systemd-journald 测试发现，设置为8M时，能导出的日志文件大概在176KB，里面包含1673行日志\n测试发现，占用为72M时，能导出的日志文件大概在3726KB，里面包含29888行日志\n如果只设置RuntimeMaxUse=16M，发现最后占用的空间会超过设定的空间16M，，于是测试同时设置RuntimeKeepFree=100M，仍然会超过预想的16M\n如果同时设置RuntimeMaxUse=16M和RuntimeMaxFiles=2这两个配置项，才能达到预想的16M，最终的配置如下\nRuntimeMaxUse=16M RuntimeMaxFiles=2 测试日志轮转 #  while true; do echo testing 1234567890 | systemd-cat; done 备份日志脚本参考 #  [root@study ~]# vim /backups/backup.sh #!/bin/bash  if [ \u0026#34;${1}\u0026#34; == \u0026#34;log\u0026#34; ]; then  logger -p syslog.info \u0026#34;backup.sh is starting\u0026#34; fi source=\u0026#34;/etc /home /root /var/lib /var/spool/{cron,at,mail}\u0026#34; target=\u0026#34;/backups/backup-system-$（date +%Y-%m-%d）.tar.gz\u0026#34; [ ! -d /backups ] \u0026amp;\u0026amp; mkdir /backups tar -zcvf ${target} ${source} \u0026amp;\u0026amp;gt; /backups/backup.log if [ \u0026#34;${1}\u0026#34; == \u0026#34;log\u0026#34; ]; then  logger -p syslog.info \u0026#34;backup.sh is finished\u0026#34; fi  [root@study ~]# /backups/backup.sh log [root@study ~]# journalctl SYSLOG_FACILITY=5 -n 3 Aug 19 18:09:37 study.centos.vbird dmtsai[29850]: backup.sh is starting Aug 19 18:09:54 study.centos.vbird dmtsai[29855]: backup.sh is finished 测试syslog关联 #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;syslog.h\u0026gt;int main() {  printf(\u0026#34;hello world1\\n\u0026#34;);  syslog(LOG_INFO, \u0026#34;hello world2\\n\u0026#34;);  fprintf(stdout,\u0026#34;this is fprintf stdout test!\\n\u0026#34;);  fprintf(stderr,\u0026#34;this is fprintf stderr test!\\n\u0026#34;);  return 0; } 测试1：直接运行测试程序，可以看出syslog方式输出的日志被记录到journald日志系统中\nMay 24 09:57:30 am335x-evm test_journald[1918]: hello world2 测试2：将测试程序添加到systemd中\nroot@am335x-evm:~# cat /etc/systemd/system/test_journald.service [Unit] Description=test_journald After=network-online.target Wants=network-online.target  [Service] ExecStart=/home/root/test_journald Restart=always KillMode=process 可以看出，如果通过service方式启动，不管是printf,stdout,stderr,还是syslog方式，全部都被记录到journald日志系统中了\nroot@am335x-evm:~# systemctl restart test_journald root@am335x-evm:~# journalctl /home/root/test_journald May 24 14:01:12 am335x-evm test_journald[3799]: hello world2 May 24 14:01:12 am335x-evm test_journald[3799]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3799]: hello world1 May 24 14:01:12 am335x-evm test_journald[3799]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3801]: hello world2 May 24 14:01:12 am335x-evm test_journald[3801]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3801]: hello world1 May 24 14:01:12 am335x-evm test_journald[3801]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3802]: hello world2 May 24 14:01:12 am335x-evm test_journald[3802]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3802]: hello world1 May 24 14:01:12 am335x-evm test_journald[3802]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3803]: hello world2 May 24 14:01:12 am335x-evm test_journald[3803]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3803]: hello world1 May 24 14:01:12 am335x-evm test_journald[3803]: this is fprintf stdout test! May 24 14:01:12 am335x-evm test_journald[3804]: hello world2 May 24 14:01:12 am335x-evm test_journald[3804]: this is fprintf stderr test! May 24 14:01:12 am335x-evm test_journald[3804]: hello world1 May 24 14:01:12 am335x-evm test_journald[3804]: this is fprintf stdout test! 常用命令 #  $ journalctl --since=2012-10-15 --until=\u0026#34;2011-10-16 23:59:59\u0026#34; $ journalctl -u httpd --since=00:00 --until=9:30 $ journalctl /usr/sbin/vpnc /usr/sbin/dhclient  #The + is an explicit OR you can use in addition to the implied OR $ journalctl _HOSTNAME=theta _UID=70 + _HOSTNAME=epsilon _COMM=avahi-daemon #显示特定程序的所有消息 $ journalctl /usr/lib/systemd/systemd #查看特定位置的日志 $ journalctl -D /mnt/var/log/journal -xe  #Displaying Logs by Process ID $ journalctl _PID=1221  #只展示内核日志 $ journalctl -k #显示毫秒 $ journalctl -o short-precise  # 显示Priority level $ journalctl -p err..alert  #手动清理日志，会保留最新的日志，从旧的日志开始删除 $ journalctl --vacuum-size=10M $ journalctl --vacuum-time=2weeks  #查看当前使用空间 $ journalctl --disk-usage Archived and active journals take up 8.0M in the file system.   #修改/etc/systemd/journald.conf配置文件后，重启systemd-journald日志服务 $ systemctl restart systemd-journald 应用程序日志重定向 #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;syslog.h\u0026gt;#include \u0026lt;QDebug\u0026gt;int main() {  qDebug()\u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __FUNCTION__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt;\u0026#34;this is QDebug test1\u0026#34;;  printf(\u0026#34;this is printf test ,hello world1\\n\u0026#34;);  syslog(LOG_INFO, \u0026#34;this is syslog test,hello world2\\n\u0026#34;);  fprintf(stdout,\u0026#34;this is fprintf stdout test!\\n\u0026#34;);  fprintf(stderr,\u0026#34;this is fprintf stderr test!\\n\u0026#34;);  qDebug()\u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; __FUNCTION__ \u0026lt;\u0026lt; __LINE__ \u0026lt;\u0026lt;\u0026#34;this is QDebug test2\u0026#34;;  return 0; } 通过管道和systemd-cat程序，将程序中的所有日志重定向到journald中\n./test_journald 2\u0026gt;\u0026amp;1 |systemd-cat May 24 13:02:31.141452 am335x-evm cat[1438]: ../test.cpp main 6 this is QDebug test1 May 24 13:02:31.145114 am335x-evm test_journald[1437]: this is syslog test,hello world2 May 24 13:02:31.147729 am335x-evm cat[1438]: this is fprintf stderr test! May 24 13:02:31.152862 am335x-evm cat[1438]: ../test.cpp main 11 this is QDebug test2 May 24 13:02:31.152862 am335x-evm cat[1438]: this is printf test ,hello world1 May 24 13:02:31.152862 am335x-evm cat[1438]: this is fprintf stdout test! 从输出结果可以看出：\n1、通过systemd-cat导入到journald后，日志中的进程名为cat，而使用syslog后，能正确显示进程名\n2、QDebug和syslog的优先级比printf和fprintf stdout方式要高，并且QDebug和syslog会按照出现的顺序进行输出\n日志集中管理 #  利用rsyslog，将日志发送到远程服务器，可以使前期调试阶段更方便\n总结 #  1、为了将上层应用和内核的日志统一输出，便于定位问题，需要利用systemd中的强大的journald日志管理程序\n2、为了保证日志统一输出到journald中，针对Qt程序和非Qt程序调用统一封装日志接口宏，在日志接口宏中统一调用syslog接口\n3、对于Qt程序，可以利用QLoggingCategory类，可以控制日志按模块输出\n参考链接 #   http://highscalability.com/log-everything-all-time\n http://jinke.me/2018-05-10-muduo-logger/\n https://riccoqu.github.io/2016/03/24/Linux%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8ESyslog%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/\n鸟叔systemd-journald.service 简介 #   https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/160.html\njournald-logging-tutorial #   https://sematext.com/blog/journald-logging-tutorial/\n"},{"id":27,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/4th-level/","title":"4th Level","section":"第一章","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.工作\n"},{"id":28,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/6th-level/","title":"6th Level","section":"5th Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":29,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/5th-level/","title":"5th Level","section":"第一章","content":"5rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":30,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0/","title":"第一章","section":"深入理解计算机系统","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":31,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/12th-level/","title":"12th Level","section":"7th Level","content":"11th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":32,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/7th-level/","title":"7th Level","section":"第二章","content":"10rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":33,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/8th-level/","title":"8th Level","section":"第二章","content":"14th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":34,"href":"/docs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"第二章","section":"深入理解计算机系统","content":"9rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":35,"href":"/posts/","title":"Blog","section":"Introduction","content":"  Google编译规范总结  版本说明 # Google编译规范总结 日期 版本 修改内容 20211029 V0.1 创建 目的 # 使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 项目主页: Google Style Guide Google 开源项目风格指南 - 中文版 代码规范 # 头文件 # 前置声明 # 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可 前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。 If a class only appears in the header as a pointer or reference, then a forward declaration is sufficient   浮点数计算误差分析  浮点数计算误差分析   ZeroTier内网穿透  ZeroTier内网穿透   搭建HUGO博客  搭建HUGO博客 # 安装hugo # 进入 release页面下载，选择下载 hugo_extended_0.97.0_Linux-64bit.deb带extended后缀的安装包 sudo dpkg -i hugo_extended_0.97.0_Linux-64bit.deb 创建hugo工程 # mkdir ~/Public/Book cd ~/Public/Book hugo new site ./ 下载主题 # git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book cp -R themes/hugo-book/exampleSite/content . 运行Web服务 # ubuntu:~/Public/Book$ hugo server --minify --theme hugo-book --bind=\u0026#34;0.0.0.0\u0026#34; -p 8888 Start building sites … hugo v0.97.0-c07f3626e7c8160943591f4d209977efa02c3dca+extended linux/amd64 BuildDate=2022-04-14T08:45:07Z VendorInfo=gohugoio WARN 2022/04/16 01:47:16 Expand shortcode is deprecated. Use \u0026#39;details\u0026#39; instead. WARN 2022/04/16 01:47:16 Page \u0026#39;/layout/variables\u0026#39; not found in \u0026#39;posts/goisforlovers.   "},{"id":36,"href":"/docs/","title":"Introduction","section":"Introduction","content":"记录工作和学习\n  读书笔记  记录读书笔记，看过的书隔段时间总会忘记，总结在此，方便检索 深入理解计算机系统 第一章 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate. iscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.   工程实践  Introduction # # FalconMode模式 版本说明 # FalconMode模式 日期 版本 修改内容 2021/11/21 V0.1 创建 FalconMode模式 # Normal mode: U-Boot SPL -\u0026gt; U-Boot -\u0026gt; Kernel Falcon mode: U-Boot SPL -\u0026gt; Kernel https://forum.digikey.com/t/beaglebone-black-u-boot-overlays-and-falcon-mode/3008/7 Once you are booted up into the Linux Kernel there should be NO difference. 测试启动时间 # 模式 文件系统 tftp下载时间 内核到telnet时间 正常uBooty启动模式 tisdk-tiny-image-am335x-evm 6秒 10秒 正常uBooty启动模式 tisdk-base-image-am335x-evm 6秒 40~60秒 Falcon模式 Out-of-the-Box (OOB) boot times of the TI Processor Linux SDK BBB板使用NFS挂载文件系统 版本说明 # BBB板使用NFS挂载文件系统 日期 版本 修改内容 2022/03/03 V0.   工作总结  Introduction # 记录工作中遇到的难点及解决方法 数据库 附加数据库（Attach DB）https://blog.csdn.net/zhanglianyu00/article/details/78436764 attach [database] filename as database_name;\rdetach [database] database_name; Squeezing Performance from SQLite: Insertions # https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-insertions-971aff98eef2 CREATE INDEX tag_titles ON tags (title);\rEXPLAIN QUERY PLAN SELECT * FROM tags WHERE title = \u0026#34;Kotlin\u0026#34;; 日志模块实现思路 版本说明 # 日志模块实现 日期 版本 修改内容 2022/03/01 V0.1 创建 实现目标 # 整个上层日志最后能导出到一个文件中，方便根据日志记录顺序，查找问题。避免多日志文件不好查时序的麻烦 整个程序运行后，一直往内存中写日志，只在用户想要导出日志时，才写U盘，尽量减少程序运行时耗时 能做到内存中始终能导出最近的日志到U盘中 程序崩溃后，发生崩溃点的日志保存处理(在DEBUG版本中，将日志输出缓冲设置为0) 参考实现 # Qt5官方日志QLoggingCategory测试 # QLoggingCategory represents a certain logging category - identified by a string - at runtime.   Linux World  记录Linux系统中常常遇到的问题对应的解决方法 工具 Linux必备工具 Git Git常用配置 Github国内加速克隆及下载 # fastgit.org https://doc.fastgit.org/ gitclone.com https://gitclone.com/ gitee https://gitee.com/mirrors cnpmjs.org https://github.com.cnpmjs.org/ Github documentation contains a script that replaces the committer info for all commits in a branch (now irretrievable, this is the last snapshot). git代理 # git config --global https.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; git config --global http.proxy \u0026#39;socks5://192.168.31.181:10808\u0026#39; 基本配置 # Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.   "}]